{"version":3,"file":"ver3-2.vue.mjs","sources":["../../../../pages/ver3-2.vue"],"sourcesContent":["<template>\n    <div class=\"splash-container\">\n      <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n    </div>\n    <button \n        class=\"control-button\"\n        :disabled=\"!isReady\" \n        v-if=\"!isPlaying\"\n        @click=\"startPlay\">\n        Play\n    </button>\n  </template>\n  \n  <script setup>\n  import * as THREE from 'three';\n  import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\n  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n  import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n  \n  // --- Refs ---\n  const canvasContainer = ref(null);\n  \n  // --- State (Reactive Variables) ---\n  const isAutoRotating = ref(true);\n  const isFlowing = ref(false); // 預設不啟動流動\n  const isReady = ref(false); // 環境是否已準備好\n  const isPlaying = ref(false); // 是否已開始播放\n  \n  // Internal state (內部狀態變數)\n  let scene;\n  let camera;\n  let renderer;\n  let controls;\n  let effect;\n  let clock;\n  let material;\n  let pmremGenerator;\n  let animationFrameId;\n  \n  // Line Data (線條數據)\n  let lineStartTimes = [];\n  let randomDirections = [];\n  let currentTargetLengths = [];\n  let lineTypes = [];\n  let lineFlowState = [];     // 儲存每條線的流動狀態\n  \n  // 流動控制相關變數\n  let savedLineState = null;  // 儲存流動開始前的線條狀態，用於恢復\n  let savedCameraState = null; // 儲存流動開始前的攝影機狀態，用於恢復\n  let shrinkStartTime = null; // 收合開始時間，用於同步計算收合進度\n  let shrinkEndTime = null;   // 收合結束時間，用於同步計算收合完成度\n  let growStartTime = null;   // 生長開始時間，用於同步計算生長進度\n  let centerBallVisible = false;   // 球體可見性狀態，控制是否顯示中心球體\n  let globalFlowState = 'idle';    // 全局流動狀態，控制所有線條的統一動畫行為\n  let centerBallFadeStartTime = null; // 中心球體淡出開始時間\n  \n  // 所有控制參數整合\n  const flowParams = {\n      // 球體參數\n      centerBall: {\n          maxStrength: 1.0,         // 中心球體最大強度，控制球體最大大小\n          minStrength: 0.0,         // 中心球體最小強度，控制球體最小大小\n          fadeDuration: 5.0,        // 中心球體淡出持續時間（秒）\n          // 球體收縮曲線參數\n          fadeEasing: {\n              type: 'easeIn',       // 'easeIn' 由慢到快, 'easeOut' 由快到慢, 'linear' 線性變化\n              power: 0.5            // 曲線指數，值越大效果越明顯\n          }\n      },\n      \n      // 時間控制參數\n      timing: {\n          ballMaxReachAdvance: 1.0,    // 球體提前多少秒達到最大尺寸（秒）\n          ballShrinkStartAdvance: 1.0, // 球體提前多少秒開始收縮（秒）\n          lineShrinkDuration: 3.0,     // 線條收縮持續時間（秒）\n          baseShrinkDuration: 3.0,     // 基本收縮持續時間（秒），替代原先的BASE_SHRINK_DURATION\n          flowShrinkDurationFactor: 0.2 // 流動模式下的收縮持續時間因子，替代原先的FLOW_SHRINK_DURATION_FACTOR\n      },\n      \n      // 生長參數\n      growth: {\n          speed: 5.0,              // 線條生長速度，替代原先的growthSpeed\n          easeOutPower: 0.15,      // 生長緩動指數，控制生長速度變化曲線，替代原先的growthEaseOutPower\n          flowSpeedFactor: 0.1     // 流動模式下的生長速度因子，會使生長變慢，替代原先的FLOW_GROWTH_SPEED_FACTOR\n      },\n      \n      // 波浪效果參數\n      wave: {\n          frequency: 1.0,          // 波浪頻率，控制波浪振動的速度，替代原先的FLOW_WAVE_FREQUENCY\n          amplitudeFactor: 0.3,   // 波浪振幅因子，與基礎強度相乘得到波浪振幅，替代原先的FLOW_WAVE_AMPLITUDE_FACTOR\n          phaseFactor: Math.PI * 4 // 波浪相位因子，控制波浪的空間分佈，替代原先的FLOW_WAVE_PHASE_FACTOR\n      },\n      \n      // 渲染器設定\n      renderer: {\n          pixelRatio: 1.5,\n          antialias: true,\n          alpha: true\n      },\n      \n      // 相機設定\n      camera: {\n          fov: 45,\n          near: 0.1,\n          far: 1000,\n          position: { x: 0, y: 0, z: 25 }\n      },\n      \n      // 控制器設定\n      controls: {\n          enableDamping: true,\n          autoRotateSpeed: 5.0,\n          enablePan: false,\n          enableZoom: false\n      }\n  };\n  \n  // Constants (常數)\n  const numSegments = 50;\n  const subtract = 20;\n  \n  // --- 工具函數 ---\n  const utils = {\n      // 材質相關函數\n      material: {\n          generate() {\n              return new THREE.MeshPhysicalMaterial({\n                  color: 0xffffff,\n                  metalness: 0,\n                  roughness: 0,\n                  transparent: true,\n                  opacity: 0.75,\n                  transmission: 1, // 增加透光性，模擬玻璃效果\n                  ior: 1.33, // 折射率 (玻璃約為1.5，水約為1.33)\n                  thickness: 1.0, // 材質厚度\n                  envMap: null,\n                  envMapIntensity: 50.0,\n                  side: THREE.DoubleSide\n              });\n          },\n          \n          loadEnvironmentMap() {\n              return new Promise((resolve, reject) => {\n                  new EXRLoader()\n                      .setPath('/hdr/')\n                      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n                          texture.mapping = THREE.EquirectangularReflectionMapping;\n                          const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n                          pmremGenerator.dispose();\n                          texture.dispose();\n  \n                          console.log(\"本地 EXR 環境貼圖已載入並處理完成。\");\n                          scene.environment = envMap;\n                          if (material) {\n                              material.envMap = envMap;\n                              material.needsUpdate = true;\n                          }\n                          resolve(envMap);\n                      }, undefined, (error) => {\n                          console.error('無法載入本地 EXR 環境貼圖:', error);\n                          reject(error);\n                      });\n              });\n          }\n      },\n      \n      // 線條相關函數\n      line: {\n          updateMetaball(obj) {\n              if (!clock) return;\n              obj.reset();\n              const currentTime = clock.getElapsedTime();\n              const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n              const totalLines = lineTypes.length;\n  \n              // 更新全局流動狀態\n              if (isFlowing.value) {\n                  utils.flow.updateGlobalState(currentTime);\n              }\n  \n              // 添加中心metaball球體 (如果可見)\n              if (centerBallVisible) {\n                  // 計算中心球體的強度\n                  const centerBallStrength = utils.ball.calculateCenterStrength(currentTime);\n                  if (centerBallStrength > 0.01) {\n                      // 將中心球體添加到metaball系統\n                      obj.addBall(centerOffset.x, centerOffset.y, centerOffset.z, centerBallStrength, subtract);\n                  }\n              }\n  \n              // 如果尚未開始播放，只顯示中心球體\n              if (!isPlaying.value) {\n                  obj.update();\n                  return;\n              }\n  \n              for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n                  if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n                      continue;\n                  }\n  \n                  if (currentTargetLengths[lineIndex] === undefined) continue;\n                  \n                  const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n                  let localCurrentLength = 0;\n                  let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n  \n                  // 使用全局狀態控制所有線條\n                  if (isFlowing.value) {\n                      switch (globalFlowState) {\n                      case 'growing':\n                          if (localMaxLength > 0.001) {\n                                  const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n                              const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n                              const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                                  const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                              localCurrentLength = easedTime * localMaxLength;\n                          } else {\n                              localCurrentLength = 0;\n                          }\n                          break;\n                      case 'pauseAtEnd':\n                              localCurrentLength = localMaxLength;\n                          break;\n                      case 'shrinking':\n                              // 計算收合進度（所有線條使用相同的開始和結束時間）\n                              if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                                  const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                                  const timeSinceShrinking = currentTime - shrinkStartTime;\n                                  const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                                  const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n                          localCurrentLength = localMaxLength * shrinkFactor;\n                              } else {\n                                  localCurrentLength = localMaxLength;\n                          }\n                          break;\n                      case 'pauseAtStart':\n                              localCurrentLength = 0.001;\n                          break;\n                          default:\n                              localCurrentLength = 0;\n                              break;\n                      }\n                      \n                      // 更新單獨線條狀態以匹配全局狀態\n                      lineFlowState[lineIndex] = globalFlowState;\n                  } else {\n                      // 非流動模式的原始邏輯\n                      if (localMaxLength > 0.001) {\n                          const normalizedTime = Math.min(timeSinceStart / (localMaxLength / (flowParams.growth.speed / obj.scale.x)), 1.0);\n                          const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                              localCurrentLength = easedTime * localMaxLength;\n                          } else {\n                              localCurrentLength = 0;\n                          }\n                  }\n  \n                  if (localCurrentLength <= 0.001) continue;\n  \n                  const currentDirection = randomDirections[lineIndex];\n                  const currentLineType = lineTypes[lineIndex];\n                  if (!currentDirection || !currentLineType) continue;\n  \n                  // 計算Metaball強度和位置\n                  for (let i = 0; i <= numSegments; i++) {\n                      const segmentT = i / numSegments;\n                      const strengthFactor = Math.pow(segmentT, currentLineType === 'tt' ? 0.25 : 1.25);\n                      const baseStrength = THREE.MathUtils.lerp(\n                          currentLineType === 'tt' ? 0.1 : 0.01,\n                          currentLineType === 'tt' ? 0.01 : 0.1,\n                          strengthFactor\n                      );\n  \n                      let dynamicStrength = baseStrength;\n                      if (isFlowing.value) {\n                          const flowAmplitude = flowParams.wave.amplitudeFactor * baseStrength;\n                          const flowOffset = Math.sin(currentTime * flowParams.wave.frequency - segmentT * flowParams.wave.phaseFactor) * flowAmplitude;\n                          dynamicStrength += flowOffset;\n                          dynamicStrength = Math.max(dynamicStrength, 0);\n                      }\n  \n                      const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n                      const finalPos = localPos.add(centerOffset);\n                      obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, subtract);\n                  }\n              }\n  \n              obj.update();\n          },\n          \n          loadModelJson() {\n              fetch('/modelJson.json')\n                  .then(response => response.json())\n                  .then(config => {\n                      console.log(\"讀取的設定:\", config);\n  \n                      // 設置線條數據\n                      const totalLines = config.lineTypes.length;\n                      lineStartTimes = new Array(totalLines);\n                      randomDirections = new Array(totalLines);\n                      currentTargetLengths = new Array(totalLines);\n                      lineTypes = new Array(totalLines);\n                      lineFlowState = new Array(totalLines);\n                      \n                      const currentTime = clock?.getElapsedTime() ?? 0;\n  \n                      for (let i = 0; i < totalLines; i++) {\n                          lineTypes[i] = config.lineTypes[i];\n                          currentTargetLengths[i] = config.currentTargetLengths[i];\n                          if (config.randomDirections[i]) {\n                              randomDirections[i] = new THREE.Vector3(\n                                  config.randomDirections[i].x,\n                                  config.randomDirections[i].y,\n                                  config.randomDirections[i].z\n                              );\n                          } else {\n                              randomDirections[i] = null;\n                          }\n                          lineStartTimes[i] = currentTime - 1000;\n                          lineFlowState[i] = 'growing';\n                      }\n  \n                      // 應用相機旋轉\n                      if (effect && config.cameraQuaternion) {\n                          const exportCameraQuaternion = new THREE.Quaternion(\n                              config.cameraQuaternion.x,\n                              config.cameraQuaternion.y,\n                              config.cameraQuaternion.z,\n                              config.cameraQuaternion.w\n                          );\n                          \n                          effect.quaternion.set(0, 0, 0, 1);\n                          const cameraInverseQuaternion = exportCameraQuaternion.clone().invert();\n                  effect.quaternion.premultiply(cameraInverseQuaternion);\n                          effect.matrixWorldNeedsUpdate = true;\n                          effect.updateMatrixWorld(true);\n                          effect.matrixAutoUpdate = false;\n                      }\n  \n                      console.log(\"模型設定已載入完成\");\n                  })\n                  .catch(error => {\n                      console.error(\"載入模型設定失敗:\", error);\n                  });\n          }\n      },\n      \n      // 球體相關函數\n      ball: {\n          calculateCenterStrength(currentTime) {\n              if (!clock) return 0.8; // 確保初始時也返回一個有效值\n              \n              if (currentTime === undefined) {\n                  currentTime = clock.getElapsedTime();\n              }\n              \n              // 如果播放還未開始，顯示固定大小的球體\n              if (!isPlaying.value) {\n                  return 0.8; // 使用固定值而不是基於 flowParams 的值，確保可見性\n              }\n              \n              if (globalFlowState === 'shrinking') {\n                  // 在收合階段，球體隨著線條收縮而放大\n                  if (shrinkStartTime === null || shrinkEndTime === null) return 0;\n                  \n                  const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                  const timeSinceShrinking = currentTime - shrinkStartTime;\n                  \n                  // 計算線條收縮進度\n                  const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                  \n                  // 當線條完全收縮時(shrinkProgress=1)，球體達到最大尺寸\n                  return flowParams.centerBall.minStrength + shrinkProgress * (flowParams.centerBall.maxStrength - flowParams.centerBall.minStrength);\n              } else if (globalFlowState === 'pauseAtStart') {\n                  // 僅在線條完全收縮後（pauseAtStart狀態）才開始縮小球體\n                  if (centerBallFadeStartTime === null) {\n                      // 第一次進入此狀態，設置淡出開始時間為當前時間\n                      centerBallFadeStartTime = currentTime;\n                      // 返回最大尺寸\n                      return flowParams.centerBall.maxStrength;\n                  }\n                  \n                  // 計算淡出進度\n                  const fadeElapsed = currentTime - centerBallFadeStartTime;\n                  const fadeProgress = Math.min(fadeElapsed / flowParams.centerBall.fadeDuration, 1.0);\n                  \n                  // 根據設定的緩動類型應用不同的曲線函數\n                  let easedProgress;\n                  switch (flowParams.centerBall.fadeEasing.type) {\n                      case 'easeIn':\n                          // 由慢到快 (加速效果)\n                          easedProgress = Math.pow(fadeProgress, flowParams.centerBall.fadeEasing.power);\n                          break;\n                      case 'easeOut':\n                          // 由快到慢 (減速效果)\n                          easedProgress = 1 - Math.pow(1 - fadeProgress, flowParams.centerBall.fadeEasing.power);\n                          break;\n                      case 'linear':\n                      default:\n                          // 線性變化\n                          easedProgress = fadeProgress;\n                          break;\n                  }\n                  \n                  // 球體從最大強度開始收縮\n                  return flowParams.centerBall.maxStrength * (1.0 - easedProgress);\n              } else {\n                  return flowParams.centerBall.minStrength;\n              }\n          }\n      },\n      \n      // 流動控制相關函數\n      flow: {\n          calculateCurrentLength(flowState, maxLength, timeSinceStart, scaleX, lineIndex) {\n              switch (flowState) {\n              case 'growing':\n                  if (maxLength > 0.001) {\n                      const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n                      const linearDuration = maxLength / (currentGrowthSpeed / scaleX);\n                      const normalizedTime = linearDuration > 0 ? \n                                             Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                      const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                      return easedTime * maxLength;\n                  }\n                  return 0;\n                  \n              case 'pauseAtEnd':\n                  return maxLength;\n                  \n              case 'shrinking':\n                  if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                      const currentTime = clock.getElapsedTime();\n                      const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                      const timeSinceShrinking = currentTime - shrinkStartTime;\n                      const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                      const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n                      return maxLength * shrinkFactor;\n                  }\n                  return maxLength;\n                  \n              case 'pauseAtStart':\n                  return 0.001;\n                  \n              default:\n                  return 0;\n              }\n          },\n          \n          updateGlobalState(currentTime) {\n              if (!isFlowing.value || !clock) return;\n              \n              // 檢查當前時間和設定的時間節點\n              if (globalFlowState === 'growing' && growStartTime !== null) {\n                  // 計算所有線條的平均生長完成度\n                  const totalLines = lineTypes.length;\n                  let totalGrowthProgress = 0;\n                  let activeLines = 0;\n                  \n                  for (let i = 0; i < totalLines; i++) {\n                      if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n                      \n                      activeLines++;\n                      const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n                      const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n                      const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n                      const linearDuration = localMaxLength / (currentGrowthSpeed / (effect?.scale.x || 1));\n                      const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                      \n                      totalGrowthProgress += growthProgress;\n                  }\n                  \n                  const averageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n                  \n                  // 當平均生長進度達到99%以上，切換到暫停狀態\n                  if (averageProgress >= 0.99) {\n                      globalFlowState = 'pauseAtEnd';\n                      console.log(\"所有線條已生長完成，進入暫停狀態\");\n                      \n                      // 延遲一段時間後開始收合\n                      setTimeout(() => {\n                          if (isFlowing.value) {\n                              utils.flow.startShrinking();\n                          }\n                      }, 1000); // 暫停1秒後開始收合\n                  }\n              } else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n                  // 檢查是否達到收合結束時間\n                  if (currentTime >= shrinkEndTime) {\n                      globalFlowState = 'pauseAtStart';\n                      console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n                      \n                      // 延遲一段時間後開始新的生長週期\n                      setTimeout(() => {\n                          if (isFlowing.value) {\n                              utils.flow.startGrowing();\n                          }\n                      }, 1000); // 暫停1秒後開始生長\n                  }\n              }\n          },\n          \n          startShrinking() {\n              if (!clock) return;\n              const currentTime = clock.getElapsedTime();\n              \n              console.log(\"所有線條同步收合\");\n              \n              // 更新全局狀態\n              globalFlowState = 'shrinking';\n              \n              // 設置收合時間\n              shrinkStartTime = currentTime;\n              shrinkEndTime = currentTime + flowParams.timing.baseShrinkDuration * flowParams.timing.flowShrinkDurationFactor;\n              \n              // 顯示中心metaball球體\n              centerBallVisible = true;\n          },\n          \n          startGrowing() {\n              if (!clock) return;\n              const currentTime = clock.getElapsedTime();\n              const totalLines = lineTypes.length;\n              \n              console.log(\"所有線條同步生長\");\n              \n              // 更新全局狀態\n              globalFlowState = 'growing';\n              growStartTime = currentTime;\n              centerBallVisible = false;\n              centerBallFadeStartTime = null; // 重置中心球體淡出時間\n              \n              // 重置所有線條的方向和長度\n              for (let i = 0; i < totalLines; i++) {\n                  if (lineStartTimes[i] === undefined) continue;\n                  \n                  // 重新生成隨機方向\n                  if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n                  randomDirections[i]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n                  \n                  // 更新線條類型和長度\n                  const minL = 2;\n                  const maxL = 3.5;\n                  currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n                  \n                  // 更新線條狀態\n                  lineStartTimes[i] = currentTime;\n              }\n          },\n          \n          toggle() {\n              if (!clock || !effect || !camera || !controls) return;\n          \n              if (isFlowing.value) {\n                  // --- 停止流動 ---\n                  isFlowing.value = false;\n                  globalFlowState = 'idle';\n                  shrinkStartTime = null;\n                  shrinkEndTime = null;\n                  growStartTime = null;\n                  centerBallVisible = false;\n                  \n                  console.log(\"流動動畫已停止，正在恢復狀態...\");\n          \n                  if (savedLineState) {\n                      lineTypes = [...savedLineState.lineTypes];\n                      randomDirections = savedLineState.randomDirections.map((dir) => dir ? new THREE.Vector3(dir.x, dir.y, dir.z) : null);\n                      currentTargetLengths = [...savedLineState.currentTargetLengths];\n                      lineStartTimes = [...savedLineState.lineStartTimes];\n                      lineFlowState = lineTypes.map(() => 'growing');\n          \n                      console.log(\"線條狀態已恢復\");\n                      savedLineState = null;\n                  } else {\n                      console.warn(\"找不到保存的狀態來恢復。\")\n                  }\n          \n                  if (savedCameraState) {\n                      camera.position.copy(savedCameraState.position);\n                      camera.quaternion.copy(savedCameraState.quaternion);\n                      controls.update();\n                      console.log(\"相機狀態已恢復\");\n                      savedCameraState = null;\n                  } else {\n                      console.warn(\"找不到保存的相機狀態來恢復。\")\n                  }\n          \n                  effect.reset();\n              } else {\n                  // --- 開始流動 ---\n                  console.log(\"開始流動動畫，正在保存當前狀態...\");\n                  savedLineState = {\n                      lineTypes: [...lineTypes],\n                      randomDirections: randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null),\n                      currentTargetLengths: [...currentTargetLengths],\n                      lineStartTimes: [...lineStartTimes]\n                  };\n                  savedCameraState = {\n                      position: camera.position.clone(),\n                      quaternion: camera.quaternion.clone()\n                  };\n                  console.log(\"狀態已保存。\");\n          \n                  isFlowing.value = true;\n                  \n                  // 設置初始全局狀態\n                  globalFlowState = 'growing';\n                  growStartTime = clock.getElapsedTime();\n          \n                  const startTime = clock.getElapsedTime();\n                  const totalLines = lineTypes.length;\n                  lineFlowState.length = totalLines;\n          \n                  // 所有線條同時開始生長\n                  console.log(\"所有線條同時開始生長。\");\n                  for (let i = 0; i < totalLines; i++) {\n                      lineStartTimes[i] = startTime;\n                      lineFlowState[i] = 'growing';\n                  }\n          \n                  effect.reset();\n              }\n              effect.material = material;\n          },\n          \n          initializeState() {\n              if (!clock) return;\n              console.log(\"初始化流動動畫狀態...\");\n              const currentTime = clock.getElapsedTime();\n              \n              // 保存當前狀態\n              savedLineState = {\n                  lineTypes: [...lineTypes],\n                  randomDirections: randomDirections.map(\n                      dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null\n                  ),\n                  currentTargetLengths: [...currentTargetLengths],\n                  lineStartTimes: [...lineStartTimes]\n              };\n              \n              savedCameraState = {\n                  position: camera.position.clone(),\n                  quaternion: camera.quaternion.clone()\n              };\n              \n              // 設置初始全局狀態\n              globalFlowState = 'growing';\n              growStartTime = currentTime;\n              \n              // 所有線條同時開始生長\n              const totalLines = lineTypes.length;\n              lineFlowState.length = totalLines;\n              \n              for (let i = 0; i < totalLines; i++) {\n                  lineStartTimes[i] = currentTime;\n                  lineFlowState[i] = 'growing';\n              }\n              \n              effect.reset();\n              effect.material = material;\n              console.log(\"流動動畫已初始化完成\");\n          }\n      },\n      \n      // 場景相關函數\n      scene: {\n          initialize() {\n              if (!canvasContainer.value) {\n                  console.error(\"Canvas container not found!\");\n                  return null;\n              }\n              \n              const container = canvasContainer.value;\n              const width = container.clientWidth;\n              const height = container.clientHeight;\n            \n              // 場景\n              const scene = new THREE.Scene();\n              scene.background = null; // 將背景設為透明\n            \n              // Camera\n              const camera = new THREE.PerspectiveCamera(\n                  flowParams.camera.fov, \n                  width / height, \n                  flowParams.camera.near, \n                  flowParams.camera.far\n              );\n              camera.position.set(\n                  flowParams.camera.position.x,\n                  flowParams.camera.position.y,\n                  flowParams.camera.position.z\n              );\n              camera.lookAt(0, 0, 0);\n            \n              // Renderer\n              const renderer = new THREE.WebGLRenderer({\n                  antialias: flowParams.renderer.antialias,\n                  alpha: flowParams.renderer.alpha\n              });\n              renderer.setSize(width, height);\n              renderer.setPixelRatio(Math.min(window.devicePixelRatio, flowParams.renderer.pixelRatio));\n              container.appendChild(renderer.domElement);\n            \n              // Controls\n              const controls = new OrbitControls(camera, renderer.domElement);\n              controls.enableDamping = flowParams.controls.enableDamping;\n              controls.autoRotate = isAutoRotating.value;\n              controls.autoRotateSpeed = flowParams.controls.autoRotateSpeed;\n              controls.enablePan = flowParams.controls.enablePan;\n              controls.enableZoom = flowParams.controls.enableZoom;\n              controls.minPolarAngle = Math.PI / 2;\n              controls.maxPolarAngle = Math.PI / 2;\n              controls.minAzimuthAngle = -Infinity;\n              controls.maxAzimuthAngle = Infinity;\n            \n              // Lights\n              scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n              const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n              dirLight.position.set(5, 10, 7.5);\n              scene.add(dirLight);\n            \n              return { scene, camera, renderer, controls };\n          },\n          \n          toggleAutoRotate() {\n              if (!controls) return;\n              isAutoRotating.value = !isAutoRotating.value;\n              controls.autoRotate = isAutoRotating.value;\n              controls.autoRotateSpeed = flowParams.controls.autoRotateSpeed;\n              console.log(`自動旋轉狀態已切換為: ${isAutoRotating.value}`);\n          },\n          \n          handleResize() {\n              if (!camera || !renderer) return;\n              const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n              const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n            \n              camera.aspect = width / height;\n              camera.updateProjectionMatrix();\n              renderer.setSize(width, height);\n          },\n          \n          cleanup() {\n              cancelAnimationFrame(animationFrameId);\n              window.removeEventListener('resize', utils.scene.handleResize);\n            \n              if (controls) controls.dispose();\n              if (renderer) renderer.dispose();\n              if (material) {\n                  material.dispose();\n                  if (scene?.environment) scene.environment.dispose();\n              }\n              \n              if (effect) {\n                  scene?.remove(effect);\n              }\n               if (scene) {\n                    scene.traverse((object) => {\n                        if (object instanceof THREE.Mesh) {\n                            object.geometry?.dispose();\n                            const objMaterial = object.material;\n                            if (Array.isArray(objMaterial)) {\n                                objMaterial.forEach((mat) => mat.dispose());\n                            } else if (objMaterial) {\n                                objMaterial.dispose();\n                            }\n                        }\n                    });\n                }\n              if(pmremGenerator) pmremGenerator.dispose();\n            \n              if (canvasContainer.value && renderer) {\n                  canvasContainer.value.removeChild(renderer.domElement);\n              }\n            \n              console.log(\"Three.js scene cleaned up.\");\n          }\n      }\n  };\n  \n  // --- Animation Loop ---\n  function animate() {\n    animationFrameId = requestAnimationFrame(animate);\n  \n    if (!effect || !material || !camera || !renderer || !scene || !controls) return;\n  \n    utils.line.updateMetaball(effect);\n    controls.update();\n  \n    renderer.render(scene, camera);\n  }\n  \n  // 播放控制相關函數\n  function startPlay() {\n    if (!isReady.value) return;\n    \n    isPlaying.value = true;\n    isFlowing.value = true;\n    \n    // 初始化流動動畫\n    utils.flow.initializeState();\n  }\n  \n  // --- Lifecycle Hooks ---\n  onMounted(() => {\n    const { scene: newScene, camera: newCamera, renderer: newRenderer, controls: newControls } = utils.scene.initialize();\n    \n    if (!newScene) return;\n    \n    scene = newScene;\n    camera = newCamera;\n    renderer = newRenderer;\n    controls = newControls;\n  \n    // PMREMGenerator\n    pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n  \n    // 材質\n    material = utils.material.generate();\n  \n    // Marching Cubes\n    effect = new MarchingCubes(200, material, true, true, 100000);\n    effect.isolation = 300;\n    effect.scale.set(8, 8, 8);\n    effect.enableUvs = false;\n    effect.enableColors = false;\n    scene.add(effect);\n  \n    // 時鐘\n    clock = new THREE.Clock();\n  \n    // 立即顯示中心球體\n    centerBallVisible = true;\n    centerBallFadeStartTime = null;\n    globalFlowState = 'pauseAtStart';\n    \n    // 強制初始渲染一次，確保球體可見\n    utils.line.updateMetaball(effect);\n    renderer.render(scene, camera);\n  \n    // 載入環境貼圖和模型JSON\n    Promise.all([\n      new Promise((resolve) => {\n        utils.material.loadEnvironmentMap()\n          .then(() => {\n            console.log(\"環境貼圖載入完成\");\n            resolve();\n          })\n          .catch(error => {\n            console.error(\"環境貼圖載入失敗:\", error);\n            resolve(); // 即使失敗也繼續\n          });\n      }),\n      new Promise((resolve) => {\n        fetch('/modelJson.json')\n          .then(response => response.json())\n          .then(config => {\n            console.log(\"讀取的設定:\", config);\n  \n            // 設置線條數據\n            const totalLines = config.lineTypes.length;\n            lineStartTimes = new Array(totalLines);\n            randomDirections = new Array(totalLines);\n            currentTargetLengths = new Array(totalLines);\n            lineTypes = new Array(totalLines);\n            lineFlowState = new Array(totalLines);\n            \n            const currentTime = clock?.getElapsedTime() ?? 0;\n  \n            for (let i = 0; i < totalLines; i++) {\n              lineTypes[i] = config.lineTypes[i];\n              currentTargetLengths[i] = config.currentTargetLengths[i];\n              if (config.randomDirections[i]) {\n                randomDirections[i] = new THREE.Vector3(\n                  config.randomDirections[i].x,\n                  config.randomDirections[i].y,\n                  config.randomDirections[i].z\n                );\n              } else {\n                randomDirections[i] = null;\n              }\n              lineStartTimes[i] = currentTime - 1000;\n              lineFlowState[i] = 'growing';\n            }\n  \n            // 應用相機旋轉\n            if (effect && config.cameraQuaternion) {\n              const exportCameraQuaternion = new THREE.Quaternion(\n                config.cameraQuaternion.x,\n                config.cameraQuaternion.y,\n                config.cameraQuaternion.z,\n                config.cameraQuaternion.w\n              );\n              \n              effect.quaternion.set(0, 0, 0, 1);\n              const cameraInverseQuaternion = exportCameraQuaternion.clone().invert();\n              effect.quaternion.premultiply(cameraInverseQuaternion);\n              effect.matrixWorldNeedsUpdate = true;\n              effect.updateMatrixWorld(true);\n              effect.matrixAutoUpdate = false;\n            }\n  \n            console.log(\"模型設定已載入完成\");\n            resolve();\n          })\n          .catch(error => {\n            console.error(\"載入模型設定失敗:\", error);\n            resolve(); // 即使失敗也繼續\n          });\n      })\n    ]).then(() => {\n      // 所有資源載入完成，啟用播放按鈕\n      isReady.value = true;\n      console.log(\"所有資源載入完成，可以開始播放\");\n    });\n  \n    // 開始動畫循環\n    animate();\n  \n    // 添加視窗大小變化監聽\n    window.addEventListener('resize', utils.scene.handleResize);\n  });\n  \n  onUnmounted(() => {\n    utils.scene.cleanup();\n  });\n  </script>"],"names":[],"mappings":";;;;;;AAoB0B,QAAI,IAAI;AAGT,QAAI,IAAI;AACb,QAAI,KAAK;AACrB,UAAA,UAAU,IAAI,KAAK;AACnB,UAAA,YAAY,IAAI,KAAK;;;;;;;;;;;;;;;;;;"}