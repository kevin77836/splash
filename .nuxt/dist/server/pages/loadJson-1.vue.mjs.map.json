{"file":"loadJson-1.vue.mjs","mappings":";;;;;;AAa0B,QAAI,IAAI;;;;;;;;;;;;","names":[],"sources":["../../../../pages/loadJson-1.vue"],"sourcesContent":["<template>\n    <div class=\"splash-container\">\n      <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n    </div>\n  </template>\n  \n  <script setup>\n  import * as THREE from 'three';\n  import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\n  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n  import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n  \n  // --- Refs ---\n  const canvasContainer = ref(null);\n  \n  // --- 全局常量 ---\n  const NUM_SEGMENTS = 50;\n  const SUBTRACT = 20;\n  \n  // --- Three.js 核心組件 ---\n  let scene;\n  let camera;\n  let renderer;\n  let controls;\n  let effect;\n  let clock;\n  let materials;\n  let pmremGenerator;\n  let animationFrameId;\n  \n  // --- 線條數據 ---\n  let lineStartTimes = [];\n  let randomDirections = [];\n  let currentTargetLengths = [];\n  let lineTypes = [];\n  let lineFlowState = [];\n  \n  // --- 流動狀態控制 ---\n  let shrinkStartTime = null;\n  let shrinkEndTime = null;\n  let growStartTime = null;\n  let centerBallVisible = false;\n  let centerBallFadeStartTime = null;\n  let globalFlowState = 'idle';\n  \n  // --- 動畫參數配置 ---\n  const flowParams = {\n      centerBall: {\n          maxStrength: 1.0,\n          minStrength: 0.0,\n          fadeDuration: 5.0,\n          fadeEasing: {\n              type: 'easeIn',\n              power: 0.5\n          }\n      },\n      \n      timing: {\n          baseShrinkDuration: 3.0,\n          flowShrinkDurationFactor: 0.2\n      },\n      \n      growth: {\n          speed: 5.0,\n          easeOutPower: 0.15,\n          flowSpeedFactor: 0.1\n      },\n      \n      wave: {\n          frequency: 1.0,\n          amplitudeFactor: 0.3,\n          phaseFactor: Math.PI * 4\n      }\n  };\n  \n  // --- 初始化材質 ---\n  function createMaterial() {\n    return new THREE.MeshStandardMaterial({\n          color: 0xffffff,\n          metalness: 1,\n          roughness: 0,\n          transparent: true,\n          opacity: 0.25,\n          side: THREE.DoubleSide,\n          envMap: null\n    });\n  }\n  \n  // --- 載入環境貼圖 ---\n  function loadEnvironmentMap() {\n    new EXRLoader()\n        .setPath('/hdr/')\n        .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n            texture.mapping = THREE.EquirectangularReflectionMapping;\n            const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n            pmremGenerator.dispose();\n            texture.dispose();\n  \n            console.log(\"環境貼圖已載入\");\n            scene.environment = envMap;\n            if (materials && materials.liquid) {\n                materials.liquid.envMap = envMap;\n                materials.liquid.needsUpdate = true;\n            }\n        }, undefined, (error) => {\n            console.error('無法載入環境貼圖:', error);\n        });\n  }\n  \n  // --- 更新 Metaball 效果 ---\n  function updateMetaball(obj) {\n      if (!clock) return;\n    \n      obj.reset();\n      const currentTime = clock.getElapsedTime();\n      const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n      const totalLines = lineTypes.length;\n  \n    // 更新動畫狀態\n    updateAnimationState(currentTime);\n  \n    // 計算並添加中心球體\n          const centerBallStrength = calculateCenterBallStrength(currentTime);\n          if (centerBallStrength > 0.01) {\n        obj.addBall(centerOffset.x, centerOffset.y, centerOffset.z, centerBallStrength, SUBTRACT);\n        centerBallVisible = true;\n    } else {\n        centerBallVisible = false;\n          }\n\n    // 處理線條動畫\n      for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n        if (!shouldProcessLine(lineIndex, currentTime)) continue;\n        \n        const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n        const timeSinceStart = currentTime - lineStartTimes[lineIndex];\n        const localCurrentLength = calculateLineLength(localMaxLength, timeSinceStart, obj.scale.x);\n        \n        // 如果線條太短則跳過\n        if (localCurrentLength <= 0.001) continue;\n\n        const currentDirection = randomDirections[lineIndex];\n        const currentLineType = lineTypes[lineIndex];\n        if (!currentDirection || !currentLineType) continue;\n\n        // 添加線條的 metaball 點\n        addLineMetaballs(obj, localCurrentLength, currentDirection, currentLineType, centerOffset, currentTime);\n    }\n\n    obj.update();\n  }\n  \n  // --- 計算中心球體強度 ---\n  function calculateCenterBallStrength(currentTime) {\n    if (globalFlowState === 'shrinking') {\n        if (shrinkStartTime === null || shrinkEndTime === null) return 0;\n        \n        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n        const timeSinceShrinking = currentTime - shrinkStartTime;\n        const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n        \n        return flowParams.centerBall.minStrength + \n               shrinkProgress * (flowParams.centerBall.maxStrength - flowParams.centerBall.minStrength);\n    } \n    else if (globalFlowState === 'pauseAtStart') {\n        if (centerBallFadeStartTime === null) {\n            centerBallFadeStartTime = currentTime;\n            return flowParams.centerBall.maxStrength;\n        }\n        \n        const fadeElapsed = currentTime - centerBallFadeStartTime;\n        const fadeProgress = Math.min(fadeElapsed / flowParams.centerBall.fadeDuration, 1.0);\n        const easedProgress = applyEasing(fadeProgress, flowParams.centerBall.fadeEasing);\n        \n        return flowParams.centerBall.maxStrength * (1.0 - easedProgress);\n    } \n    \n    return flowParams.centerBall.minStrength;\n  }\n  \n  // --- 應用緩動效果 ---\n  function applyEasing(progress, easingConfig) {\n    switch (easingConfig.type) {\n        case 'easeIn':\n            return Math.pow(progress, easingConfig.power);\n        case 'easeOut':\n            return 1 - Math.pow(1 - progress, easingConfig.power);\n        default: // linear\n            return progress;\n    }\n  }\n  \n  // --- 判斷是否需要處理該線條 ---\n  function shouldProcessLine(lineIndex, currentTime) {\n    return lineStartTimes[lineIndex] !== undefined && \n           currentTime >= lineStartTimes[lineIndex] && \n           currentTargetLengths[lineIndex] !== undefined;\n  }\n  \n  // --- 計算線條當前長度 ---\n  function calculateLineLength(maxLength, timeSinceStart, scaleX) {\n    if (maxLength <= 0.001) return 0;\n    \n              switch (globalFlowState) {\n              case 'growing':\n                          const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n            const linearDuration = maxLength / (currentGrowthSpeed / scaleX);\n            const normalizedTime = linearDuration > 0 ? \n                                  Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                          const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n            return easedTime * maxLength;\n            \n              case 'pauseAtEnd':\n            return maxLength;\n            \n              case 'shrinking':\n                      if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                const currentTime = clock.getElapsedTime();\n                          const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                          const timeSinceShrinking = currentTime - shrinkStartTime;\n                          const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                return maxLength * (1.0 - shrinkProgress);\n                  }\n            return maxLength;\n            \n              case 'pauseAtStart':\n            return 0.001;\n            \n                  default:\n            return 0;\n    }\n              }\n              \n  // --- 添加線條的 metaball 點 ---\n  function addLineMetaballs(obj, length, direction, lineType, centerOffset, currentTime) {\n    for (let i = 0; i <= NUM_SEGMENTS; i++) {\n        const segmentT = i / NUM_SEGMENTS;\n        const strengthFactor = Math.pow(segmentT, lineType === 'tt' ? 0.25 : 1.25);\n              const baseStrength = THREE.MathUtils.lerp(\n            lineType === 'tt' ? 0.1 : 0.01,\n            lineType === 'tt' ? 0.01 : 0.1,\n                  strengthFactor\n              );\n  \n        // 計算強度和波浪效果\n        let dynamicStrength = calculateSegmentStrength(baseStrength, segmentT, currentTime);\n        \n        // 計算位置\n        const localPos = direction.clone().multiplyScalar(length * segmentT);\n              const finalPos = localPos.add(centerOffset);\n        \n        // 添加球體\n        obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, SUBTRACT);\n    }\n  }\n  \n  // --- 計算線段強度（含波浪效果）---\n  function calculateSegmentStrength(baseStrength, segmentT, currentTime) {\n    const flowAmplitude = flowParams.wave.amplitudeFactor * baseStrength;\n    const flowOffset = Math.sin(\n        currentTime * flowParams.wave.frequency - \n        segmentT * flowParams.wave.phaseFactor\n    ) * flowAmplitude;\n    \n    return Math.max(baseStrength + flowOffset, 0);\n  }\n  \n  // --- 載入模型 JSON ---\n  function loadModelJson() {\n      fetch('/modelJson.json')\n          .then(response => response.json())\n          .then(config => {\n            console.log(\"模型設定已載入\");\n            initializeLineData(config);\n            applyModelConfiguration(config);\n            startFlowAnimation();\n        })\n        .catch(error => {\n            console.error(\"載入模型設定失敗:\", error);\n        });\n  }\n  \n  // --- 初始化線條數據 ---\n  function initializeLineData(config) {\n              const totalLines = config.lineTypes.length;\n              lineStartTimes = new Array(totalLines);\n              randomDirections = new Array(totalLines);\n              currentTargetLengths = new Array(totalLines);\n              lineTypes = new Array(totalLines);\n              lineFlowState = new Array(totalLines);\n              \n              const currentTime = clock?.getElapsedTime() ?? 0;\n  \n              for (let i = 0; i < totalLines; i++) {\n                  lineTypes[i] = config.lineTypes[i];\n                  currentTargetLengths[i] = config.currentTargetLengths[i];\n        \n                  if (config.randomDirections[i]) {\n                      randomDirections[i] = new THREE.Vector3(\n                          config.randomDirections[i].x,\n                          config.randomDirections[i].y,\n                          config.randomDirections[i].z\n                      );\n                  } else {\n                      randomDirections[i] = null;\n                  }\n        \n        lineStartTimes[i] = currentTime - 1000; // 確保線條立即可見\n                  lineFlowState[i] = 'growing';\n              }\n  }\n  \n  // --- 應用模型配置 ---\n  function applyModelConfiguration(config) {\n    if (!effect || !config.cameraQuaternion) return;\n    \n                  const exportCameraQuaternion = new THREE.Quaternion(\n                      config.cameraQuaternion.x,\n                      config.cameraQuaternion.y,\n                      config.cameraQuaternion.z,\n                      config.cameraQuaternion.w\n                  );\n                  \n                  effect.quaternion.set(0, 0, 0, 1);\n                  const cameraInverseQuaternion = exportCameraQuaternion.clone().invert();\n          effect.quaternion.premultiply(cameraInverseQuaternion);\n                  effect.matrixWorldNeedsUpdate = true;\n                  effect.updateMatrixWorld(true);\n                  effect.matrixAutoUpdate = false;\n              }\n  \n  // --- 更新動畫狀態 ---\n  function updateAnimationState(currentTime) {\n    // 檢查線條生長完成情況\n    if (globalFlowState === 'growing' && growStartTime !== null) {\n        const averageProgress = calculateAverageGrowthProgress(currentTime);\n        \n        if (averageProgress >= 0.99) {\n            globalFlowState = 'pauseAtEnd';\n            console.log(\"線條生長完成，進入暫停狀態\");\n            \n            // 延遲後開始收縮\n            setTimeout(startShrinking, 1000);\n        }\n    } \n    // 檢查線條收縮完成情況\n    else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n        if (currentTime >= shrinkEndTime) {\n            globalFlowState = 'pauseAtStart';\n            console.log(\"線條收縮完成，進入起始暫停狀態\");\n            \n            // 延遲後開始生長\n            setTimeout(startGrowing, 1000);\n        }\n    }\n    \n    // 更新所有線條的流動狀態\n    for (let i = 0; i < lineFlowState.length; i++) {\n        lineFlowState[i] = globalFlowState;\n    }\n  }\n  \n  // --- 計算平均生長進度 ---\n  function calculateAverageGrowthProgress(currentTime) {\n          const totalLines = lineTypes.length;\n          let totalGrowthProgress = 0;\n          let activeLines = 0;\n          \n          for (let i = 0; i < totalLines; i++) {\n              if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n              \n              activeLines++;\n              const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n              const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n              const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n              const linearDuration = localMaxLength / (currentGrowthSpeed / (effect?.scale.x || 1));\n              const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n              \n              totalGrowthProgress += growthProgress;\n          }\n          \n    return activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n  }\n  \n  // --- 開始收縮動畫 ---\n  function startShrinking() {\n      if (!clock) return;\n      \n    console.log(\"開始收縮動畫，顯示中心球體\");\n      \n      globalFlowState = 'shrinking';\n      \n    const currentTime = clock.getElapsedTime();\n      shrinkStartTime = currentTime;\n      shrinkEndTime = currentTime + flowParams.timing.baseShrinkDuration * flowParams.timing.flowShrinkDurationFactor;\n      \n      centerBallVisible = true;\n    centerBallFadeStartTime = null;\n  }\n  \n  // --- 開始生長動畫 ---\n  function startGrowing() {\n      if (!clock) return;\n      \n    console.log(\"開始生長動畫，隱藏中心球體\");\n      \n    const currentTime = clock.getElapsedTime();\n      globalFlowState = 'growing';\n      growStartTime = currentTime;\n      centerBallVisible = false;\n    centerBallFadeStartTime = null;\n    \n    regenerateLines(currentTime);\n  }\n  \n  // --- 重新生成線條 ---\n  function regenerateLines(currentTime) {\n    const totalLines = lineTypes.length;\n    \n      for (let i = 0; i < totalLines; i++) {\n          if (lineStartTimes[i] === undefined) continue;\n          \n        // 新的隨機方向\n          if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n        randomDirections[i]?.set(\n            Math.random() * 2 - 1, \n            Math.random() * 2 - 1, \n            Math.random() * 2 - 1\n        ).normalize();\n          \n        // 新的長度和開始時間\n        const minLength = 2;\n        const maxLength = 3.5;\n        currentTargetLengths[i] = THREE.MathUtils.randFloat(minLength, maxLength);\n          lineStartTimes[i] = currentTime;\n      }\n  }\n  \n  // --- 開始流動動畫 ---\n  function startFlowAnimation() {\n    if (!clock) return;\n    \n    console.log(\"初始化流動動畫\");\n    \n    // 設置初始狀態\n    globalFlowState = 'growing';\n    growStartTime = clock.getElapsedTime();\n          \n    // 重置線條狀態\n    if (effect) effect.reset();\n  }\n  \n  // --- 動畫循環 ---\n  function animate() {\n    animationFrameId = requestAnimationFrame(animate);\n  \n    if (!effect || !materials || !camera || !renderer || !scene || !controls) return;\n  \n    updateMetaball(effect);\n    controls.update();\n  \n        renderer.render(scene, camera);\n  }\n  \n  // --- 處理視窗大小變化 ---\n  function handleResize() {\n    if (!camera || !renderer) return;\n    \n      const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n      const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n  \n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n      renderer.setSize(width, height);\n  }\n  \n  // --- 初始化場景 ---\n  function initScene() {\n    if (!canvasContainer.value) {\n      console.error(\"找不到畫布容器!\");\n      return false;\n    }\n    \n    const container = canvasContainer.value;\n    const width = container.clientWidth;\n    const height = container.clientHeight;\n  \n    // 場景設置\n    scene = new THREE.Scene();\n    scene.background = null; // 透明背景\n  \n    // 相機設置\n    camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n    camera.position.set(0, 0, 30);\n    camera.lookAt(scene.position);\n  \n    // 渲染器設置\n    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n    container.appendChild(renderer.domElement);\n  \n    // 控制設置\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.autoRotate = true; // 永遠自動旋轉\n    controls.autoRotateSpeed = 5.0;\n  \n    // 燈光設置\n    scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n    dirLight.position.set(5, 10, 7.5);\n    scene.add(dirLight);\n  \n    // 環境貼圖\n    pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n  \n    // 準備材質\n    materials = { liquid: createMaterial() };\n  \n    // Marching Cubes\n    effect = new MarchingCubes(200, materials.liquid, true, true, 100000);\n    effect.isolation = 300;\n    effect.scale.set(8, 8, 8);\n    effect.enableUvs = false;\n    effect.enableColors = false;\n    scene.add(effect);\n  \n    // 時鐘\n    clock = new THREE.Clock();\n  \n    return true;\n  }\n  \n  // --- 清理資源 ---\n  function cleanupResources() {\n    cancelAnimationFrame(animationFrameId);\n    window.removeEventListener('resize', handleResize);\n  \n    if (controls) controls.dispose();\n    if (renderer) renderer.dispose();\n    if (materials && materials.liquid) {\n        materials.liquid.dispose();\n        if (scene?.environment) scene.environment.dispose();\n    }\n    \n    if (effect) {\n        scene?.remove(effect);\n    }\n    \n     if (scene) {\n          scene.traverse((object) => {\n              if (object instanceof THREE.Mesh) {\n                  object.geometry?.dispose();\n                  const material = object.material;\n                  if (Array.isArray(material)) {\n                      material.forEach((mat) => mat.dispose());\n                  } else if (material) {\n                      material.dispose();\n                  }\n              }\n          });\n      }\n    \n    if (pmremGenerator) pmremGenerator.dispose();\n  \n    if (canvasContainer.value && renderer) {\n      canvasContainer.value.removeChild(renderer.domElement);\n    }\n  \n    console.log(\"Three.js 場景已清理\");\n  }\n  \n  // --- 生命週期掛鉤 ---\n  onMounted(() => {\n    if (!initScene()) return;\n    \n    // 載入資源\n    loadEnvironmentMap();\n    loadModelJson();\n    \n    // 啟動動畫\n    animate();\n    \n    // 處理視窗大小變化\n    window.addEventListener('resize', handleResize);\n  });\n  \n  onUnmounted(() => {\n    cleanupResources();\n  });\n  </script>"],"version":3}