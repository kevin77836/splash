{"file":"generate-1.vue.mjs","mappings":";;;;;;AA4DQ,UAAA,kBAAkB,IAAI,IAAI;;;;;;;;;;;;;;;;","names":[],"sources":["../../../../pages/generate-1.vue"],"sourcesContent":["<template>\n  <div ref=\"canvasContainer\" class=\"splash-container\"></div>\n  </template>\n  \n  <script setup>\n  import * as THREE from 'three';\n  import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\n  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n  import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// --- 配置參數 ---\nconst CONFIG = {\n  scene: {\n    scale: 8,              // 模型縮放比例\n    pixelRatio: 1.5        // 渲染像素比例\n  },\n  metaball: {\n    resolution: 200,       // Marching Cubes 解析度\n    segments: 50,          // 線條分段數量\n    subtract: 20,          // Metaball 減法參數\n    maxBalls: 100000       // 最大球體數量\n  },\n  material: {\n    color: 0xffffff,       // 材質顏色\n    metalness: 0,        // 金屬感\n    roughness: 0,          // 粗糙度\n    opacity: 0.75,          // 透明度\n    transmission: 1,\n    ior: 1.33,\n    thickness: 1.0,\n    envMapIntensity: 300.0,\n  },\n  lines: {\n    // 由粗到細線條\n    thickToThin: {\n      startStrength: 0.1,  // 起始端粗度\n      endStrength: 0.01,   // 末端粗度\n      minLength: 2.5,      // 最小長度\n      maxLength: 3.5,      // 最大長度\n      shrinkPower: 0.25,   // 收縮速率指數\n      count: 4             // 線條數量\n    },\n    // 由細到粗線條\n    thinToThick: {\n      startStrength: 0.01, // 起始端粗度\n      endStrength: 0.1,    // 末端粗度\n      minLength: 2,        // 最小長度\n      maxLength: 3,        // 最大長度\n      shrinkPower: 1.25,   // 膨脹速率指數\n      count: 3             // 線條數量\n    }\n  },\n  controls: {\n    autoRotate: true,      // 自動旋轉\n    rotateSpeed: 2.0,      // 旋轉速度\n    enableDamping: true    // 啟用阻尼效果\n  }\n};\n  \n  // --- Refs ---\n  const canvasContainer = ref(null);\n\n// --- 資源管理 ---\nconst resources = {\n  scene: null,\n  camera: null,\n  renderer: null,\n  controls: null,\n  effect: null,\n  material: null,\n  pmremGenerator: null,\n  animationId: null,\n  \n  // 線條數據\n  lines: {\n    directions: [],  // 方向向量\n    lengths: [],     // 長度\n    types: []        // 類型\n  },\n  \n  // 清理所有資源\n  dispose() {\n    cancelAnimationFrame(this.animationId);\n    \n    if (this.controls) this.controls.dispose();\n    if (this.renderer) this.renderer.dispose();\n    \n    if (this.material) {\n      this.material.dispose();\n      if (this.scene?.environment) this.scene.environment.dispose();\n    }\n    \n    if (this.effect) this.scene?.remove(this.effect);\n    \n    if (this.scene) {\n      this.scene.traverse((object) => {\n        if (object instanceof THREE.Mesh) {\n          object.geometry?.dispose();\n          \n          if (Array.isArray(object.material)) {\n            object.material.forEach(mat => mat.dispose());\n          } else if (object.material) {\n            object.material.dispose();\n          }\n        }\n      });\n    }\n    \n    if (this.pmremGenerator) this.pmremGenerator.dispose();\n    \n    if (canvasContainer.value && this.renderer) {\n      canvasContainer.value.removeChild(this.renderer.domElement);\n    }\n  }\n};\n\n// --- 創建液體材質 ---\nfunction createMaterial() {\n  return new THREE.MeshPhysicalMaterial({\n    color: CONFIG.material.color,\n    metalness: CONFIG.material.metalness,\n    roughness: CONFIG.material.roughness,\n        transparent: true,\n    opacity: CONFIG.material.opacity,\n          side: THREE.DoubleSide,\n    transmission: CONFIG.material.transmission,\n    ior: CONFIG.material.ior,\n    thickness: CONFIG.material.thickness,\n    envMapIntensity: CONFIG.material.envMapIntensity,\n  });\n}\n\n// --- 載入環境貼圖 ---\n  function loadEnvironmentMap() {\n  return new Promise((resolve, reject) => {\n    new EXRLoader()\n      .setPath('/hdr/')\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', \n        (texture) => {\n            texture.mapping = THREE.EquirectangularReflectionMapping;\n          \n          const envMap = resources.pmremGenerator.fromEquirectangular(texture).texture;\n          resources.pmremGenerator.dispose();\n            texture.dispose();\n  \n          resources.scene.environment = envMap;\n          if (resources.material) {\n            resources.material.envMap = envMap;\n            resources.material.needsUpdate = true;\n          }\n          \n          resolve(envMap);\n        },\n        undefined,\n        (error) => {\n          console.error('無法載入環境貼圖:', error);\n          reject(error);\n        }\n      );\n  });\n}\n\n// --- 生成線條 ---\nfunction generateLines() {\n  const { thickToThin, thinToThick } = CONFIG.lines;\n  const totalLines = thickToThin.count + thinToThick.count;\n  \n  // 初始化數組\n  resources.lines.directions = new Array(totalLines);\n  resources.lines.lengths = new Array(totalLines);\n  resources.lines.types = new Array(totalLines);\n  \n      let lineIndex = 0;\n  \n  // 生成線條函數\n  const createLine = (params, type) => {\n    const direction = new THREE.Vector3(\n      Math.random() * 2 - 1, \n      Math.random() * 2 - 1, \n      Math.random() * 2 - 1\n    ).normalize();\n    \n    const length = THREE.MathUtils.randFloat(\n      params.minLength,\n      params.maxLength\n    );\n    \n    resources.lines.directions[lineIndex] = direction;\n    resources.lines.lengths[lineIndex] = length;\n    resources.lines.types[lineIndex] = type;\n          lineIndex++;\n  };\n  \n  // 生成由粗到細線條\n  for (let i = 0; i < thickToThin.count; i++) {\n    createLine(thickToThin, 'tt');\n  }\n  \n  // 生成由細到粗線條\n  for (let i = 0; i < thinToThick.count; i++) {\n    createLine(thinToThick, 'th');\n  }\n  \n  // 如果效果已初始化，立即更新\n  if (resources.effect) {\n    updateMetaball();\n  }\n}\n\n// --- 更新 Metaball 效果 ---\nfunction updateMetaball() {\n  const effect = resources.effect;\n  if (!effect) return;\n  \n                  effect.reset();\n  \n  const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n  const { directions, lengths, types } = resources.lines;\n  const totalLines = types.length;\n  \n  for (let i = 0; i < totalLines; i++) {\n    if (!lengths[i]) continue;\n    \n    const localMaxLength = lengths[i] / effect.scale.x;\n    const direction = directions[i];\n    const type = types[i];\n    \n    if (!direction || !type) continue;\n    \n    // 根據線條類型選擇參數\n    const lineParams = type === 'tt' \n      ? CONFIG.lines.thickToThin \n      : CONFIG.lines.thinToThick;\n    \n    // 計算 metaball 點\n    for (let j = 0; j <= CONFIG.metaball.segments; j++) {\n      const t = j / CONFIG.metaball.segments;\n      const strengthFactor = Math.pow(t, lineParams.shrinkPower);\n      const strength = THREE.MathUtils.lerp(\n        lineParams.startStrength,\n        lineParams.endStrength,\n        strengthFactor\n      );\n      \n      // 計算位置\n      const pos = direction.clone()\n        .multiplyScalar(localMaxLength * t)\n        .add(centerOffset);\n      \n      // 添加 metaball 點\n      effect.addBall(\n        pos.x, \n        pos.y, \n        pos.z, \n        strength, \n        CONFIG.metaball.subtract\n      );\n    }\n  }\n  \n  effect.update();\n}\n\n// --- 處理視窗大小變化 ---\nfunction handleResize() {\n  if (!resources.camera || !resources.renderer) return;\n  \n      const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n      const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n  \n  resources.camera.aspect = width / height;\n  resources.camera.updateProjectionMatrix();\n  resources.renderer.setSize(width, height);\n}\n\n// --- 初始化場景 ---\nfunction initScene() {\n  if (!canvasContainer.value) {\n    console.error(\"找不到畫布容器!\");\n    return false;\n  }\n  \n    const container = canvasContainer.value;\n  const width = container.clientWidth || window.innerWidth;\n  const height = container.clientHeight || window.innerHeight;\n  \n  // 場景\n  resources.scene = new THREE.Scene();\n  resources.scene.background = null; // 透明背景\n  \n  // 相機\n  resources.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  resources.camera.position.set(0, 0, 30);\n  resources.camera.lookAt(0, 0, 0);\n  \n  // 渲染器 (添加透明支援)\n  resources.renderer = new THREE.WebGLRenderer({ \n    antialias: true,\n    alpha: true \n  });\n  resources.renderer.setSize(width, height);\n  resources.renderer.setPixelRatio(\n    Math.min(window.devicePixelRatio, CONFIG.scene.pixelRatio)\n  );\n  container.appendChild(resources.renderer.domElement);\n  \n  // 控制器\n  resources.controls = new OrbitControls(resources.camera, resources.renderer.domElement);\n  resources.controls.enableDamping = CONFIG.controls.enableDamping;\n  resources.controls.autoRotate = CONFIG.controls.autoRotate;\n  resources.controls.autoRotateSpeed = CONFIG.controls.rotateSpeed;\n  \n  // 環境貼圖處理器\n  resources.pmremGenerator = new THREE.PMREMGenerator(resources.renderer);\n  resources.pmremGenerator.compileEquirectangularShader();\n  \n  // 液體材質\n  resources.material = createMaterial();\n  \n  // Marching Cubes 效果\n  const isolation = CONFIG.metaball.resolution * 1.5;\n  resources.effect = new MarchingCubes(\n    CONFIG.metaball.resolution,\n    resources.material,\n    true, \n    true,\n    CONFIG.metaball.maxBalls\n  );\n  \n  resources.effect.isolation = isolation;\n  resources.effect.scale.set(\n    CONFIG.scene.scale, \n    CONFIG.scene.scale, \n    CONFIG.scene.scale\n  );\n  resources.effect.enableUvs = false;\n  resources.effect.enableColors = false;\n  resources.scene.add(resources.effect);\n  \n  return true;\n}\n\n// --- 渲染場景 ---\nfunction render() {\n  const { camera, renderer, scene, controls, effect } = resources;\n  if (!effect || !camera || !renderer || !scene || !controls) return;\n  \n  controls.update();\n  renderer.render(scene, camera);\n  \n  resources.animationId = requestAnimationFrame(render);\n}\n\n// --- 生命週期掛鉤 ---\nonMounted(async () => {\n  if (!initScene()) return;\n  \n  try {\n    // 載入環境貼圖\n    await loadEnvironmentMap();\n    \n    // 生成線條\n    generateLines();\n    \n    // 開始渲染\n    render();\n    \n    // 監聽視窗大小變化\n    window.addEventListener('resize', handleResize);\n  } catch (error) {\n    console.error(\"初始化失敗:\", error);\n  }\n  });\n  \n  onUnmounted(() => {\n  resources.dispose();\n    window.removeEventListener('resize', handleResize);\n});\n  </script>"],"version":3}