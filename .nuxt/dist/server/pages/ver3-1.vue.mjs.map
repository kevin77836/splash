{"version":3,"file":"ver3-1.vue.mjs","sources":["../../../../pages/ver3-1.vue"],"sourcesContent":["<template>\n    <div class=\"splash-container\">\n      <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n      <!-- <div id=\"switchPanel\" class=\"control-panel switch-panel\">\n            <div class=\"panel-title\">效果切換</div>\n          <div class=\"switch-control-group\">\n              <label class=\"switch-label\">{{ currentMaterial === 'shader' ? '描邊材質' : '液體材質' }}</label>\n              <label class=\"switch\">\n                  <input type=\"checkbox\" :checked=\"currentMaterial === 'liquid'\" @change=\"toggleMaterial\">\n                  <span class=\"slider round\"></span>\n              </label>\n          </div>\n  \n          <div class=\"switch-control-group\">\n              <label class=\"switch-label\">{{ isFlowing ? '流動中' : '靜止' }}</label>\n              <label class=\"switch\">\n                  <input type=\"checkbox\" :checked=\"isFlowing\" @change=\"toggleFlow\">\n                  <span class=\"slider round\"></span>\n              </label>\n          </div>\n  \n          <div class=\"switch-control-group\">\n              <label class=\"switch-label\">{{ isPixelated ? '像素化' : '正常' }}</label>\n              <label class=\"switch\">\n                  <input type=\"checkbox\" :checked=\"isPixelated\" @change=\"togglePixelation\">\n                  <span class=\"slider round\"></span>\n              </label>\n          </div>\n            \n            <div class=\"switch-control-group\">\n                <label class=\"switch-label\">{{ isAutoRotating ? '自動旋轉中' : '靜止' }}</label>\n                <label class=\"switch\">\n                    <input type=\"checkbox\" :checked=\"isAutoRotating\" @change=\"toggleAutoRotate\">\n                    <span class=\"slider round\"></span>\n                </label>\n            </div>\n      </div> -->\n    </div>\n  </template>\n  \n  <script setup>\n  import * as THREE from 'three';\n  import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\n  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\n  import { RenderPixelatedPass } from 'three/examples/jsm/postprocessing/RenderPixelatedPass.js';\n  import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';\n  import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n  \n  // --- Refs ---\n  const canvasContainer = ref(null);\n  \n  // --- State (Reactive Variables) ---\n  const currentMaterial = ref('liquid');\n  const isPixelated = ref(false);\n  const isAutoRotating = ref(true);\n  const isFlowing = ref(true);\n  \n  // Internal state (內部狀態變數)\n  let scene;\n  let camera;\n  let renderer;\n  let controls;\n  let effect;\n  let clock;\n  let materials;\n  let pmremGenerator;\n  let composer;\n  let pixelPass;\n  let animationFrameId;\n  \n  // Line Data (線條數據)\n  let lineStartTimes = [];\n  let randomDirections = [];\n  let currentTargetLengths = [];\n  let lineTypes = [];\n  let lineFlowState = [];     // 儲存每條線的流動狀態\n  \n  // 流動控制相關變數\n  let savedLineState = null;  // 儲存流動開始前的線條狀態，用於恢復\n  let savedCameraState = null; // 儲存流動開始前的攝影機狀態，用於恢復\n  let shrinkStartTime = null; // 收合開始時間，用於同步計算收合進度\n  let shrinkEndTime = null;   // 收合結束時間，用於同步計算收合完成度\n  let growStartTime = null;   // 生長開始時間，用於同步計算生長進度\n  let centerBallVisible = false;   // 球體可見性狀態，控制是否顯示中心球體\n  let globalFlowState = 'idle';    // 全局流動狀態，控制所有線條的統一動畫行為\n  let centerBallFadeStartTime = null; // 中心球體淡出開始時間\n  \n  // 所有控制參數整合\n  const flowParams = {\n      // 球體參數\n      centerBall: {\n          maxStrength: 1.0,         // 中心球體最大強度，控制球體最大大小\n          minStrength: 0.0,         // 中心球體最小強度，控制球體最小大小\n          fadeDuration: 5.0,        // 中心球體淡出持續時間（秒）\n          // 球體收縮曲線參數\n          fadeEasing: {\n              type: 'easeIn',       // 'easeIn' 由慢到快, 'easeOut' 由快到慢, 'linear' 線性變化\n              power: 0.5            // 曲線指數，值越大效果越明顯\n          }\n      },\n      \n      // 時間控制參數\n      timing: {\n          ballMaxReachAdvance: 1.0,    // 球體提前多少秒達到最大尺寸（秒）\n          ballShrinkStartAdvance: 1.0, // 球體提前多少秒開始收縮（秒）\n          lineShrinkDuration: 3.0,     // 線條收縮持續時間（秒）\n          baseShrinkDuration: 3.0,     // 基本收縮持續時間（秒），替代原先的BASE_SHRINK_DURATION\n          flowShrinkDurationFactor: 0.2 // 流動模式下的收縮持續時間因子，替代原先的FLOW_SHRINK_DURATION_FACTOR\n      },\n      \n      // 生長參數\n      growth: {\n          speed: 5.0,              // 線條生長速度，替代原先的growthSpeed\n          easeOutPower: 0.15,      // 生長緩動指數，控制生長速度變化曲線，替代原先的growthEaseOutPower\n          flowSpeedFactor: 0.1     // 流動模式下的生長速度因子，會使生長變慢，替代原先的FLOW_GROWTH_SPEED_FACTOR\n      },\n      \n      // 波浪效果參數\n      wave: {\n          frequency: 1.0,          // 波浪頻率，控制波浪振動的速度，替代原先的FLOW_WAVE_FREQUENCY\n          amplitudeFactor: 0.3,   // 波浪振幅因子，與基礎強度相乘得到波浪振幅，替代原先的FLOW_WAVE_AMPLITUDE_FACTOR\n          phaseFactor: Math.PI * 4 // 波浪相位因子，控制波浪的空間分佈，替代原先的FLOW_WAVE_PHASE_FACTOR\n      }\n  };\n  \n  // Constants (常數)\n  const numSegments = 50;\n  const subtract = 20;\n  \n  // --- Shaders ---\n  const vertexShader = `\n    uniform vec3 viewVector;\n    uniform vec2 uResolution;\n    uniform float uTime;\n    varying vec2 vUv;\n    varying float opacity;\n    void main() {\n      vUv = uv;\n      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);\n      gl_Position = projectionMatrix * mvPos;\n      vec3 nNormal = normalize(normalMatrix * normal);\n      vec3 nView   = normalize(viewVector - mvPos.xyz);\n      opacity = dot(nNormal, nView);\n      opacity = 1.0 - abs(opacity * 1.3);\n    }\n  `;\n  \n  const fragmentShader = `\n    uniform vec3 uColor;\n    uniform vec2 uResolution;\n    uniform float uTime;\n    varying vec2 vUv;\n    varying float opacity;\n    void main() {\n      vec2 d = gl_FragCoord.xy / uResolution;\n      vec3 fade = vec3(d.x, d.y, 1.0);\n      vec3 c = mix(vec3(0.0), fade * uColor, opacity);\n      gl_FragColor = vec4(c, 1.0);\n    }\n  `;\n  \n  // --- Functions ---\n  function generateMaterials() {\n    return {\n      shader: new THREE.ShaderMaterial({\n        uniforms: {\n          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n          uTime:       { value: 0 },\n          uColor:      { value: new THREE.Color(0x000000) },\n          viewVector:  { value: camera.position }\n        },\n        vertexShader:   vertexShader,\n        fragmentShader: fragmentShader,\n        transparent: true,\n        side: THREE.DoubleSide\n      }),\n      liquid: new THREE.MeshPhysicalMaterial({\n          color: 0xffffff,\n          metalness: 0,\n          roughness: 0,\n          transparent: true,\n          opacity: 0.75,\n          transmission: 1, // 增加透光性，模擬玻璃效果\n        //   reflectivity: 1, // 反射率\n          ior: 1.33, // 折射率 (玻璃約為1.5，水約為1.33)\n          thickness: 1.0, // 材質厚度\n        //   clearcoat: 0.5, // 清漆層強度\n        //   clearcoatRoughness: 0.1, // 清漆層粗糙度\n          envMap: null,\n          envMapIntensity: 50.0,\n          side: THREE.DoubleSide\n      })\n    };\n  }\n  \n  function loadEnvironmentMap() {\n    new EXRLoader()\n        .setPath('/hdr/')\n        .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n            texture.mapping = THREE.EquirectangularReflectionMapping;\n            const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n            pmremGenerator.dispose();\n            texture.dispose();\n  \n            console.log(\"本地 EXR 環境貼圖已載入並處理完成。\");\n            scene.environment = envMap;\n            if (materials && materials.liquid) {\n                materials.liquid.envMap = envMap;\n                materials.liquid.needsUpdate = true;\n            }\n        }, undefined, (error) => {\n            console.error('無法載入本地 EXR 環境貼圖:', error);\n        });\n  }\n  \n  function updateLineMetaball(obj) {\n      if (!clock) return;\n      obj.reset();\n      const currentTime = clock.getElapsedTime();\n      const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n      const totalLines = lineTypes.length;\n  \n      // 更新全局流動狀態\n      if (isFlowing.value) {\n          updateGlobalFlowState(currentTime);\n      }\n  \n      // 添加中心metaball球體 (如果可見)\n      if (centerBallVisible) {\n          // 計算中心球體的強度\n          const centerBallStrength = calculateCenterBallStrength(currentTime);\n          if (centerBallStrength > 0.01) {\n              // 將中心球體添加到metaball系統\n              obj.addBall(centerOffset.x, centerOffset.y, centerOffset.z, centerBallStrength, subtract);\n          }\n      }\n  \n      for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n          if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n              continue;\n          }\n  \n          if (currentTargetLengths[lineIndex] === undefined) continue;\n          \n          const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n          let localCurrentLength = 0;\n          let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n  \n          // 使用全局狀態控制所有線條\n          if (isFlowing.value) {\n              switch (globalFlowState) {\n              case 'growing':\n                  if (localMaxLength > 0.001) {\n                          const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n                      const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n                      const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                          const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                      localCurrentLength = easedTime * localMaxLength;\n                  } else {\n                      localCurrentLength = 0;\n                  }\n                  break;\n              case 'pauseAtEnd':\n                      localCurrentLength = localMaxLength;\n                  break;\n              case 'shrinking':\n                      // 計算收合進度（所有線條使用相同的開始和結束時間）\n                      if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                          const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                          const timeSinceShrinking = currentTime - shrinkStartTime;\n                          const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                          const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n                  localCurrentLength = localMaxLength * shrinkFactor;\n                      } else {\n                          localCurrentLength = localMaxLength;\n                  }\n                  break;\n              case 'pauseAtStart':\n                      localCurrentLength = 0.001;\n                  break;\n                  default:\n                      localCurrentLength = 0;\n                      break;\n              }\n              \n              // 更新單獨線條狀態以匹配全局狀態\n              lineFlowState[lineIndex] = globalFlowState;\n          } else {\n              // 非流動模式的原始邏輯\n              if (localMaxLength > 0.001) {\n                  const normalizedTime = Math.min(timeSinceStart / (localMaxLength / (flowParams.growth.speed / obj.scale.x)), 1.0);\n                  const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                      localCurrentLength = easedTime * localMaxLength;\n                  } else {\n                      localCurrentLength = 0;\n                  }\n          }\n  \n          if (localCurrentLength <= 0.001) continue;\n  \n          const currentDirection = randomDirections[lineIndex];\n          const currentLineType = lineTypes[lineIndex];\n          if (!currentDirection || !currentLineType) continue;\n  \n          // 計算Metaball強度和位置\n          for (let i = 0; i <= numSegments; i++) {\n              const segmentT = i / numSegments;\n              const strengthFactor = Math.pow(segmentT, currentLineType === 'tt' ? 0.25 : 1.25);\n              const baseStrength = THREE.MathUtils.lerp(\n                  currentLineType === 'tt' ? 0.1 : 0.01,\n                  currentLineType === 'tt' ? 0.01 : 0.1,\n                  strengthFactor\n              );\n  \n              let dynamicStrength = baseStrength;\n              if (isFlowing.value) {\n                  const flowAmplitude = flowParams.wave.amplitudeFactor * baseStrength;\n                  const flowOffset = Math.sin(currentTime * flowParams.wave.frequency - segmentT * flowParams.wave.phaseFactor) * flowAmplitude;\n                  dynamicStrength += flowOffset;\n                  dynamicStrength = Math.max(dynamicStrength, 0);\n              }\n  \n              const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n              const finalPos = localPos.add(centerOffset);\n              obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, subtract);\n          }\n      }\n  \n      obj.update();\n  }\n  \n  function loadModelJson() {\n      fetch('/modelJson.json')\n          .then(response => response.json())\n          .then(config => {\n              console.log(\"讀取的設定:\", config);\n  \n              // 設置線條數據\n              const totalLines = config.lineTypes.length;\n              lineStartTimes = new Array(totalLines);\n              randomDirections = new Array(totalLines);\n              currentTargetLengths = new Array(totalLines);\n              lineTypes = new Array(totalLines);\n              lineFlowState = new Array(totalLines);\n              \n              const currentTime = clock?.getElapsedTime() ?? 0;\n  \n              for (let i = 0; i < totalLines; i++) {\n                  lineTypes[i] = config.lineTypes[i];\n                  currentTargetLengths[i] = config.currentTargetLengths[i];\n                  if (config.randomDirections[i]) {\n                      randomDirections[i] = new THREE.Vector3(\n                          config.randomDirections[i].x,\n                          config.randomDirections[i].y,\n                          config.randomDirections[i].z\n                      );\n                  } else {\n                      randomDirections[i] = null;\n                  }\n                  lineStartTimes[i] = currentTime - 1000;\n                  lineFlowState[i] = 'growing';\n              }\n  \n              // 應用相機旋轉\n              if (effect && config.cameraQuaternion) {\n                  const exportCameraQuaternion = new THREE.Quaternion(\n                      config.cameraQuaternion.x,\n                      config.cameraQuaternion.y,\n                      config.cameraQuaternion.z,\n                      config.cameraQuaternion.w\n                  );\n                  \n                  effect.quaternion.set(0, 0, 0, 1);\n                  const cameraInverseQuaternion = exportCameraQuaternion.clone().invert();\n          effect.quaternion.premultiply(cameraInverseQuaternion);\n                  effect.matrixWorldNeedsUpdate = true;\n                  effect.updateMatrixWorld(true);\n                  effect.matrixAutoUpdate = false;\n              }\n  \n              console.log(\"模型設定已載入完成\");\n          })\n          .catch(error => {\n              console.error(\"載入模型設定失敗:\", error);\n          });\n  }\n  \n  // 恢復切換功能\n  function toggleMaterial() {\n      if (!effect || !scene) return;\n      if (currentMaterial.value === 'shader') {\n          currentMaterial.value = 'liquid';\n      } else {\n          currentMaterial.value = 'shader';\n      }\n      effect.material = materials[currentMaterial.value];\n      \n      console.log(`材質已切換為: ${currentMaterial.value}`);\n  }\n  \n  function togglePixelation() {\n      if (!effect || !scene) return;\n      isPixelated.value = !isPixelated.value;\n      console.log(`像素化狀態已切換為: ${isPixelated.value}`);\n  }\n  \n  function toggleAutoRotate() {\n      if (!controls) return;\n      isAutoRotating.value = !isAutoRotating.value;\n      controls.autoRotate = isAutoRotating.value;\n      controls.autoRotateSpeed = 5.0; // 設置旋轉速度\n      console.log(`自動旋轉狀態已切換為: ${isAutoRotating.value}`);\n  }\n  \n  function toggleFlow() {\n      if (!clock || !effect || !camera || !controls) return;\n  \n      if (isFlowing.value) {\n          // --- 停止流動 ---\n          isFlowing.value = false;\n          globalFlowState = 'idle';\n          shrinkStartTime = null;\n          shrinkEndTime = null;\n          growStartTime = null;\n          centerBallVisible = false;\n          \n          console.log(\"流動動畫已停止，正在恢復狀態...\");\n  \n          if (savedLineState) {\n              lineTypes = [...savedLineState.lineTypes];\n              randomDirections = savedLineState.randomDirections.map((dir) => dir ? new THREE.Vector3(dir.x, dir.y, dir.z) : null);\n              currentTargetLengths = [...savedLineState.currentTargetLengths];\n              lineStartTimes = [...savedLineState.lineStartTimes];\n              lineFlowState = lineTypes.map(() => 'growing');\n  \n              console.log(\"線條狀態已恢復\");\n              savedLineState = null;\n          } else {\n              console.warn(\"找不到保存的狀態來恢復。\")\n          }\n  \n          if (savedCameraState) {\n              camera.position.copy(savedCameraState.position);\n              camera.quaternion.copy(savedCameraState.quaternion);\n              controls.update();\n              console.log(\"相機狀態已恢復\");\n              savedCameraState = null;\n          } else {\n               console.warn(\"找不到保存的相機狀態來恢復。\")\n          }\n  \n          effect.reset();\n      } else {\n          // --- 開始流動 ---\n          console.log(\"開始流動動畫，正在保存當前狀態...\");\n          savedLineState = {\n              lineTypes: [...lineTypes],\n              randomDirections: randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null),\n              currentTargetLengths: [...currentTargetLengths],\n              lineStartTimes: [...lineStartTimes]\n          };\n          savedCameraState = {\n              position: camera.position.clone(),\n              quaternion: camera.quaternion.clone()\n          };\n          console.log(\"狀態已保存。\");\n  \n          isFlowing.value = true;\n          \n          // 設置初始全局狀態\n          globalFlowState = 'growing';\n          growStartTime = clock.getElapsedTime();\n  \n          const startTime = clock.getElapsedTime();\n          const totalLines = lineTypes.length;\n          lineFlowState.length = totalLines;\n  \n          // 所有線條同時開始生長\n          console.log(\"所有線條同時開始生長。\");\n              for (let i = 0; i < totalLines; i++) {\n                  lineStartTimes[i] = startTime;\n                  lineFlowState[i] = 'growing';\n          }\n  \n          effect.reset();\n      }\n      effect.material = materials[currentMaterial.value];\n  }\n  \n  // --- 全局流動狀態管理 ---\n  function updateGlobalFlowState(currentTime) {\n      if (!isFlowing.value || !clock) return;\n      \n      // 檢查當前時間和設定的時間節點\n      if (globalFlowState === 'growing' && growStartTime !== null) {\n          // 計算所有線條的平均生長完成度\n          const totalLines = lineTypes.length;\n          let totalGrowthProgress = 0;\n          let activeLines = 0;\n          \n          for (let i = 0; i < totalLines; i++) {\n              if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n              \n              activeLines++;\n              const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n              const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n              const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n              const linearDuration = localMaxLength / (currentGrowthSpeed / (effect?.scale.x || 1));\n              const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n              \n              totalGrowthProgress += growthProgress;\n          }\n          \n          const averageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n          \n          // 當平均生長進度達到99%以上，切換到暫停狀態\n          if (averageProgress >= 0.99) {\n              globalFlowState = 'pauseAtEnd';\n              console.log(\"所有線條已生長完成，進入暫停狀態\");\n              \n              // 延遲一段時間後開始收合\n              setTimeout(() => {\n                  if (isFlowing.value) {\n                      startSyncShrinking();\n                  }\n              }, 1000); // 暫停1秒後開始收合\n          }\n      } else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n          // 檢查是否達到收合結束時間\n          if (currentTime >= shrinkEndTime) {\n              globalFlowState = 'pauseAtStart';\n              console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n              \n              // 延遲一段時間後開始新的生長週期\n              setTimeout(() => {\n                  if (isFlowing.value) {\n                      startSyncGrowing();\n                  }\n              }, 1000); // 暫停1秒後開始生長\n          }\n      }\n  }\n  \n  // 開始同步收合\n  function startSyncShrinking() {\n      if (!clock) return;\n      const currentTime = clock.getElapsedTime();\n      \n      console.log(\"所有線條同步收合\");\n      \n      // 更新全局狀態\n      globalFlowState = 'shrinking';\n      \n      // 設置收合時間\n      shrinkStartTime = currentTime;\n      shrinkEndTime = currentTime + flowParams.timing.baseShrinkDuration * flowParams.timing.flowShrinkDurationFactor;\n      \n      // 顯示中心metaball球體\n      centerBallVisible = true;\n  }\n  \n  // 開始同步生長\n  function startSyncGrowing() {\n      if (!clock) return;\n      const currentTime = clock.getElapsedTime();\n      const totalLines = lineTypes.length;\n      \n      console.log(\"所有線條同步生長\");\n      \n      // 更新全局狀態\n      globalFlowState = 'growing';\n      growStartTime = currentTime;\n      centerBallVisible = false;\n      centerBallFadeStartTime = null; // 重置中心球體淡出時間\n      \n      // 重置所有線條的方向和長度\n      for (let i = 0; i < totalLines; i++) {\n          if (lineStartTimes[i] === undefined) continue;\n          \n          // 重新生成隨機方向\n          if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n          randomDirections[i]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n          \n          // 更新線條類型和長度\n          const minL = 2;\n          const maxL = 3.5;\n          currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n          \n          // 更新線條狀態\n          lineStartTimes[i] = currentTime;\n      }\n  }\n  \n  function calculateCenterBallStrength(currentTime) {\n      if (!clock) return 0;\n      \n      if (currentTime === undefined) {\n          currentTime = clock.getElapsedTime();\n      }\n      \n      if (globalFlowState === 'shrinking') {\n          // 在收合階段，球體隨著線條收縮而放大\n          if (shrinkStartTime === null || shrinkEndTime === null) return 0;\n          \n          const shrinkDuration = shrinkEndTime - shrinkStartTime;\n          const timeSinceShrinking = currentTime - shrinkStartTime;\n          \n          // 計算線條收縮進度\n          const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n          \n          // 球體隨著線條收縮進度同步放大\n          // 當線條完全收縮時(shrinkProgress=1)，球體達到最大尺寸\n          return flowParams.centerBall.minStrength + shrinkProgress * (flowParams.centerBall.maxStrength - flowParams.centerBall.minStrength);\n      } else if (globalFlowState === 'pauseAtStart') {\n          // 僅在線條完全收縮後（pauseAtStart狀態）才開始縮小球體\n          if (centerBallFadeStartTime === null) {\n              // 第一次進入此狀態，設置淡出開始時間為當前時間\n              centerBallFadeStartTime = currentTime;\n              // 返回最大尺寸\n              return flowParams.centerBall.maxStrength;\n          }\n          \n          // 計算淡出進度\n          const fadeElapsed = currentTime - centerBallFadeStartTime;\n          const fadeProgress = Math.min(fadeElapsed / flowParams.centerBall.fadeDuration, 1.0);\n          \n          // 根據設定的緩動類型應用不同的曲線函數\n          let easedProgress;\n          switch (flowParams.centerBall.fadeEasing.type) {\n              case 'easeIn':\n                  // 由慢到快 (加速效果)\n                  easedProgress = Math.pow(fadeProgress, flowParams.centerBall.fadeEasing.power);\n                  break;\n              case 'easeOut':\n                  // 由快到慢 (減速效果)\n                  easedProgress = 1 - Math.pow(1 - fadeProgress, flowParams.centerBall.fadeEasing.power);\n                  break;\n              case 'linear':\n              default:\n                  // 線性變化\n                  easedProgress = fadeProgress;\n                  break;\n          }\n          \n          // 球體從最大強度開始收縮\n          return flowParams.centerBall.maxStrength * (1.0 - easedProgress);\n      } else {\n          return flowParams.centerBall.minStrength;\n      }\n  }\n  \n  // --- Animation Loop ---\n  function animate() {\n    animationFrameId = requestAnimationFrame(animate);\n  \n    if (!effect || !materials || !camera || !renderer || !scene || !controls) return;\n  \n    updateLineMetaball(effect);\n    controls.update();\n  \n    if (currentMaterial.value === 'shader' && !isPixelated.value) {\n        const currentTime = clock.getElapsedTime();\n        materials.shader.uniforms.uTime.value = currentTime;\n        materials.shader.uniforms.viewVector.value = camera.position;\n    }\n  \n    if (isPixelated.value && composer) {\n        composer.render();\n    } else {\n        renderer.render(scene, camera);\n    }\n  }\n  \n  // --- Resize Handler ---\n  function handleResize() {\n      if (!camera || !renderer || !materials) return;\n      const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n      const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n  \n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n      renderer.setSize(width, height);\n  \n      if (composer) {\n          composer.setSize(width, height);\n      }\n  \n      if (materials.shader) {\n          materials.shader.uniforms.uResolution.value.set(width, height);\n      }\n  }\n  \n  // --- Lifecycle Hooks ---\n  onMounted(() => {\n    if (!canvasContainer.value) {\n      console.error(\"Canvas container not found!\");\n      return;\n    }\n    const container = canvasContainer.value;\n    const width = container.clientWidth;\n    const height = container.clientHeight;\n  \n    // Scene\n    scene = new THREE.Scene();\n    scene.background = null; // 將背景設為透明\n  \n    // Camera\n    camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n    camera.position.set(0, 0, 25);\n    camera.lookAt(scene.position);\n  \n    // Renderer\n    renderer = new THREE.WebGLRenderer({ \n        antialias: true,\n        alpha: true  // 啟用透明背景\n     });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n    container.appendChild(renderer.domElement);\n  \n    // Controls\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.autoRotate = isAutoRotating.value;\n    controls.autoRotateSpeed = 5.0;\n    \n    // 限制控制 - 只允許繞z軸旋轉\n    controls.enablePan = false; // 禁止平移\n    controls.enableZoom = false; // 禁止縮放\n    controls.minPolarAngle = Math.PI / 2; // 固定垂直角度\n    controls.maxPolarAngle = Math.PI / 2; // 固定垂直角度\n    controls.minAzimuthAngle = -Infinity; // 允許360度水平旋轉\n    controls.maxAzimuthAngle = Infinity;\n  \n    // Lights\n    scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n    dirLight.position.set(5, 10, 7.5);\n    scene.add(dirLight);\n  \n    // PMREMGenerator\n    pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n  \n    // Materials\n    materials = generateMaterials();\n  \n    // Marching Cubes\n    effect = new MarchingCubes(200, materials[currentMaterial.value], true, true, 100000);\n    effect.isolation = 300;\n    effect.scale.set(8, 8, 8);\n    effect.enableUvs = false;\n    effect.enableColors = false;\n    scene.add(effect);\n  \n    // Post-processing Setup\n    composer = new EffectComposer(renderer);\n    pixelPass = new RenderPixelatedPass(5, scene, camera);\n    composer.addPass(pixelPass);\n    const outputPass = new OutputPass();\n    composer.addPass(outputPass);\n  \n    // Clock\n    clock = new THREE.Clock();\n  \n    // Load Env Map\n    loadEnvironmentMap();\n  \n    // Load Model JSON\n    loadModelJson();\n  \n    // Start animation\n    animate();\n    \n    // 自動啟動流動動畫（如果預設為開啟）\n    if (isFlowing.value) {\n      // 使用短暫延遲確保場景和資料已經初始化完成\n      setTimeout(() => {\n        // 直接初始化流動狀態，而非調用toggleFlow\n        console.log(\"初始化流動動畫狀態...\");\n        const currentTime = clock.getElapsedTime();\n        \n        // 保存當前狀態\n        savedLineState = {\n          lineTypes: [...lineTypes],\n          randomDirections: randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null),\n          currentTargetLengths: [...currentTargetLengths],\n          lineStartTimes: [...lineStartTimes]\n        };\n        \n        savedCameraState = {\n          position: camera.position.clone(),\n          quaternion: camera.quaternion.clone()\n        };\n        \n        // 設置初始全局狀態\n        globalFlowState = 'growing';\n        growStartTime = currentTime;\n        \n        // 所有線條同時開始生長\n        const totalLines = lineTypes.length;\n        lineFlowState.length = totalLines;\n        \n        for (let i = 0; i < totalLines; i++) {\n          lineStartTimes[i] = currentTime;\n          lineFlowState[i] = 'growing';\n        }\n        \n        effect.reset();\n        effect.material = materials[currentMaterial.value];\n        console.log(\"流動動畫已初始化完成\");\n      }, 1000);\n    }\n  \n    // Add resize listener\n    window.addEventListener('resize', handleResize);\n  });\n  \n  onUnmounted(() => {\n    cancelAnimationFrame(animationFrameId);\n    window.removeEventListener('resize', handleResize);\n  \n    if (controls) controls.dispose();\n    if (renderer) renderer.dispose();\n    if (materials) {\n        materials.shader?.dispose();\n        materials.liquid?.dispose();\n        if (scene?.environment) scene.environment.dispose();\n    }\n    \n    if (effect) {\n        scene?.remove(effect);\n    }\n     if (scene) {\n          scene.traverse((object) => {\n              if (object instanceof THREE.Mesh) {\n                  object.geometry?.dispose();\n                  const material = object.material;\n                  if (Array.isArray(material)) {\n                      material.forEach((mat) => mat.dispose());\n                  } else if (material) {\n                      material.dispose();\n                  }\n              }\n          });\n      }\n    if(pmremGenerator) pmremGenerator.dispose();\n  \n    if (canvasContainer.value && renderer) {\n      canvasContainer.value.removeChild(renderer.domElement);\n    }\n  \n    console.log(\"Three.js scene cleaned up.\");\n  });\n  </script>"],"names":[],"mappings":";;;;;;AAkD0B,QAAI,IAAI;AAGR,QAAI,QAAQ;AAChB,QAAI,KAAK;AACN,QAAI,IAAI;AACb,QAAI,IAAI;;;;;;;;;;;;"}