{"version":3,"file":"index.vue2.mjs","sources":["../../../../pages/index.vue"],"sourcesContent":["<template>\n  <div class=\"splash-container\">\n    <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n\n    <!-- 控制面板 HTML - 由粗到細 -->\n    <div id=\"thickToThinPanel\" class=\"control-panel thick-to-thin-panel\">\n      <div class=\"panel-title\">由粗到細 線條控制</div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">最粗粗度 (強度): <span class=\"value-display\">{{ ttStartStrength.toFixed(2) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttStartStrength\" min=\"0\" max=\"0.1\" step=\"0.01\" @input=\"handleTtStartStrengthInput\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">最細粗度 (強度): <span class=\"value-display\">{{ ttEndStrength.toFixed(2) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttEndStrength\" min=\"0.0\" max=\"0.1\" step=\"0.01\" @input=\"handleTtEndStrengthInput\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">最短長度: <span class=\"value-display\">{{ ttMinWorldLength.toFixed(1) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttMinWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleTtMinLengthInput\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">最長長度: <span class=\"value-display\">{{ ttMaxWorldLength.toFixed(1) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttMaxWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleTtMaxLengthInput\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">收縮速率 (冪): <span class=\"value-display\">{{ ttShrinkPower.toFixed(2) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttShrinkPower\" min=\"0.1\" max=\"5.0\" step=\"0.05\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">線條數量: <span class=\"value-display\">{{ ttNumLines }}</span></label>\n        <input type=\"range\" v-model.number=\"ttNumLines\" min=\"0\" max=\"10\" step=\"1\" @input=\"regenerateLine\">\n      </div>\n    </div>\n\n    <!-- 控制面板 HTML - 由細到粗 -->\n    <div id=\"thinToThickPanel\" class=\"control-panel thin-to-thick-panel\">\n        <div class=\"panel-title\">由細到粗 線條控制</div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">最細粗度 (強度): <span class=\"value-display\">{{ thStartStrength.toFixed(2) }}</span></label>\n            <input type=\"range\" v-model.number=\"thStartStrength\" min=\"0.0\" max=\"0.1\" step=\"0.01\" @input=\"handleThStartStrengthInput\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">最粗粗度 (強度): <span class=\"value-display\">{{ thEndStrength.toFixed(2) }}</span></label>\n            <input type=\"range\" v-model.number=\"thEndStrength\" min=\"0\" max=\"0.1\" step=\"0.01\" @input=\"handleThEndStrengthInput\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">最短長度: <span class=\"value-display\">{{ thMinWorldLength.toFixed(1) }}</span></label>\n            <input type=\"range\" v-model.number=\"thMinWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleThMinLengthInput\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">最長長度: <span class=\"value-display\">{{ thMaxWorldLength.toFixed(1) }}</span></label>\n            <input type=\"range\" v-model.number=\"thMaxWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleThMaxLengthInput\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">膨脹速率 (冪): <span class=\"value-display\">{{ thShrinkPower.toFixed(2) }}</span></label>\n            <input type=\"range\" v-model.number=\"thShrinkPower\" min=\"0.1\" max=\"5.0\" step=\"0.05\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">線條數量: <span class=\"value-display\">{{ thNumLines }}</span></label>\n            <input type=\"range\" v-model.number=\"thNumLines\" min=\"0\" max=\"10\" step=\"1\" @input=\"regenerateLine\">\n        </div>\n    </div>\n\n    <!-- 通用控制面板 HTML -->\n    <div id=\"commonPanel\" class=\"control-panel common-panel\">\n        <div class=\"panel-title\">通用控制</div>\n         <div class=\"control-group\">\n            <label class=\"control-label\">MarchingCubes 解析度: <span class=\"value-display\">{{ resolution }}</span></label>\n            <input type=\"range\" v-model.number=\"resolution\" min=\"10\" max=\"500\" step=\"1\" @input=\"updateMarchingCubesParams\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">MarchingCubes Isolation: <span class=\"value-display\">{{ isolation }}</span></label>\n            <input type=\"range\" v-model.number=\"isolation\" min=\"10\" max=\"300\" step=\"10\" @input=\"updateMarchingCubesParams\">\n        </div>\n        <button @click=\"regenerateLine\">重新生成所有線條</button>\n        <button @click=\"exportConfiguration\" style=\"margin-top: 5px;\">匯出設定 (JSON)</button>\n        <button @click=\"triggerImport\" style=\"margin-top: 5px;\">匯入設定 (JSON)</button>\n        <input type=\"file\" ref=\"importConfigFileRef\" @change=\"importConfiguration\" accept=\".json\" style=\"display: none;\">\n        <button @click=\"exportGLB\" style=\"margin-top: 5px;\">下載目前模型 (GLB)</button>\n        <button @click=\"toggleMaterial\" style=\"margin-top: 5px;\">{{ toggleMaterialButtonText }}</button>\n        <button @click=\"toggleFlow\" style=\"margin-top: 5px;\">{{ toggleFlowButtonText }}</button>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';\n// EffectComposer and passes are not used in the original script, excluding them for now.\n// import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\n// import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\n// import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';\n// import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// --- Refs ---\nconst canvasContainer = ref<HTMLDivElement | null>(null);\nconst importConfigFileRef = ref<HTMLInputElement | null>(null);\n\n// --- State (Reactive Variables) ---\n\n// Thick-to-Thin Parameters\nconst ttStartStrength = ref(0.1);\nconst ttEndStrength = ref(0.01);\nconst ttMinWorldLength = ref(2.5);\nconst ttMaxWorldLength = ref(3.5);\nconst ttShrinkPower = ref(0.25);\nconst ttNumLines = ref(4);\n\n// Thin-to-Thick Parameters\nconst thStartStrength = ref(0.01);\nconst thEndStrength = ref(0.1);\nconst thMinWorldLength = ref(2);\nconst thMaxWorldLength = ref(3);\nconst thShrinkPower = ref(1.25);\nconst thNumLines = ref(3);\n\n// Shared Parameters\nconst resolution = ref(200);\nconst isolation = ref(300);\nconst currentMaterial = ref<'shader' | 'liquid'>('shader');\nconst isFlowing = ref(false);\n\n// Internal state (non-reactive or managed internally by Three.js objects)\nlet scene: THREE.Scene;\nlet camera: THREE.PerspectiveCamera;\nlet renderer: THREE.WebGLRenderer;\nlet controls: OrbitControls;\nlet effect: MarchingCubes;\nlet clock: THREE.Clock;\nlet materials: { shader: THREE.ShaderMaterial; liquid: THREE.MeshStandardMaterial };\nlet pmremGenerator: THREE.PMREMGenerator;\nlet animationFrameId: number;\n\n// Line Data (Using simple arrays, could be reactive if needed for UI binding beyond counts)\nlet lineStartTimes: (number | undefined)[] = [];\nlet randomDirections: (THREE.Vector3 | null)[] = [];\nlet currentTargetLengths: number[] = [];\nlet lineTypes: ('tt' | 'th')[] = [];\nlet lineFlowState: ('growing' | 'pauseAtEnd' | 'shrinking' | 'pauseAtStart')[] = [];\nlet lineShrinkStartTimes: (number | undefined)[] = [];\nlet linePauseAtEndEndTime: (number | undefined)[] = [];\nlet linePauseAtStartEndTime: (number | undefined)[] = [];\n\nlet savedLineState: any = null;\nlet savedCameraState: any = null;\nlet isFirstFlowTrigger = true;\n\n// Constants\nconst growthSpeed = 5.0;\nconst growthEaseOutPower = 0.5;\nconst numSegments = 50;\nconst subtract = 20;\nconst FLOW_GROWTH_SPEED_FACTOR = 0.2;\nconst FLOW_SHRINK_DURATION_FACTOR = 1.5;\nconst MAX_INITIAL_FLOW_DELAY = 2.5;\nconst BASE_SHRINK_DURATION = 1.0;\nconst MAX_PAUSE_AT_END_DELAY = 10.0;\nconst MAX_PAUSE_AT_START_DELAY = 1.0;\n\n// --- Computed Properties ---\nconst toggleMaterialButtonText = computed(() => {\n  return currentMaterial.value === 'shader' ? '切換為液體材質' : '切換為描邊材質';\n});\n\nconst toggleFlowButtonText = computed(() => {\n  return isFlowing.value ? '停止流動動畫' : '開始流動動畫';\n});\n\n// --- Shaders ---\nconst vertexShader = `\n  uniform vec3 viewVector;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  varying vec2 vUv;\n  varying float opacity;\n  void main() {\n    vUv = uv;\n    vec4 mvPos = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPos;\n    vec3 nNormal = normalize(normalMatrix * normal);\n    vec3 nView   = normalize(viewVector - mvPos.xyz);\n    opacity = dot(nNormal, nView);\n    opacity = 1.0 - abs(opacity * 1.3);\n  }\n`;\n\nconst fragmentShader = `\n  uniform vec3 uColor;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  varying vec2 vUv;\n  varying float opacity;\n  void main() {\n    vec2 d = gl_FragCoord.xy / uResolution;\n    vec3 fade = vec3(d.x, d.y, 1.0);\n    vec3 c = mix(vec3(0.0), fade * uColor, opacity);\n    gl_FragColor = vec4(c, 1.0);\n  }\n`;\n\n// --- Functions ---\n\nfunction generateMaterials() {\n  return {\n    shader: new THREE.ShaderMaterial({\n      uniforms: {\n        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n        uTime:       { value: 0 },\n        uColor:      { value: new THREE.Color(0x000000) },\n        viewVector:  { value: camera.position }\n      },\n      vertexShader:   vertexShader,\n      fragmentShader: fragmentShader,\n      transparent: true,\n      side: THREE.DoubleSide\n    }),\n    liquid: new THREE.MeshStandardMaterial({\n        color: 0xffffff,\n        metalness: 0.9,\n        roughness: 0,\n        transparent: true,\n        opacity: 0.25,\n        side: THREE.DoubleSide,\n        envMap: null // Will be set by loader\n    })\n  };\n}\n\nfunction loadEnvironmentMap() {\n  new EXRLoader()\n      .setPath('/hdr/') // Use path relative to public directory\n      .load('HDR_Light_Studio_Free_HDRI_Design_05.exr', (texture: THREE.Texture) => {\n          texture.mapping = THREE.EquirectangularReflectionMapping;\n          const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n          pmremGenerator.dispose();\n          texture.dispose();\n\n          console.log(\"本地 EXR 環境貼圖已載入並處理完成。\");\n          scene.environment = envMap;\n          if (materials && materials.liquid) {\n              materials.liquid.envMap = envMap;\n              materials.liquid.needsUpdate = true;\n          }\n      }, undefined, (error: Error | ProgressEvent<EventTarget>) => {\n          console.error('無法載入本地 EXR 環境貼圖:', error);\n          alert('無法載入 assets/hdr/HDR_Light_Studio_Free_HDRI_Design_05.exr，請檢查檔案是否存在或路徑是否正確。');\n      });\n}\n\nfunction regenerateLine() {\n    if (!clock || !effect) return; // Ensure initialization\n    const currentTime = clock.getElapsedTime();\n    const totalLines = ttNumLines.value + thNumLines.value;\n\n    // Adjust array sizes\n    lineStartTimes.length = totalLines;\n    randomDirections.length = totalLines;\n    currentTargetLengths.length = totalLines;\n    lineTypes.length = totalLines;\n    lineFlowState.length = totalLines;\n    lineShrinkStartTimes.length = totalLines;\n    linePauseAtEndEndTime.length = totalLines;\n    linePauseAtStartEndTime.length = totalLines;\n\n    // Note: Marching Cubes resolution/isolation update handled by watcher/direct function\n\n    let lineIndex = 0;\n\n    // Generate Thick-to-Thin lines\n    for(let i = 0; i < ttNumLines.value; i++) {\n        if (!randomDirections[lineIndex]) {\n            randomDirections[lineIndex] = new THREE.Vector3();\n        }\n        randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n        currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(ttMinWorldLength.value, ttMaxWorldLength.value);\n        lineTypes[lineIndex] = 'tt';\n        lineStartTimes[lineIndex] = currentTime;\n        lineFlowState[lineIndex] = 'growing';\n        lineShrinkStartTimes[lineIndex] = undefined;\n        linePauseAtEndEndTime[lineIndex] = undefined;\n        linePauseAtStartEndTime[lineIndex] = undefined;\n        lineIndex++;\n    }\n\n    // Generate Thin-to-Thick lines\n    for(let i = 0; i < thNumLines.value; i++) {\n         if (!randomDirections[lineIndex]) {\n            randomDirections[lineIndex] = new THREE.Vector3();\n        }\n        randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n        currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(thMinWorldLength.value, thMaxWorldLength.value);\n        lineTypes[lineIndex] = 'th';\n        lineStartTimes[lineIndex] = currentTime;\n        lineFlowState[lineIndex] = 'growing';\n        lineShrinkStartTimes[lineIndex] = undefined;\n        linePauseAtEndEndTime[lineIndex] = undefined;\n        linePauseAtStartEndTime[lineIndex] = undefined;\n        lineIndex++;\n    }\n    effect.reset();\n    isFirstFlowTrigger = true;\n}\n\nfunction updateLineMetaball(obj: MarchingCubes) {\n    if (!clock) return;\n    obj.reset();\n    const currentTime = clock.getElapsedTime();\n    const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n    const totalLines = ttNumLines.value + thNumLines.value;\n\n    for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n\n        if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]!) {\n            continue;\n        }\n\n        if (currentTargetLengths[lineIndex] === undefined) continue;\n        const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n        let localCurrentLength = 0;\n        let timeSinceStart = currentTime - lineStartTimes[lineIndex]!;\n        const currentFlowState = lineFlowState[lineIndex];\n\n        // --- Calculate length based on flow state ---\n        switch (currentFlowState) {\n            case 'growing':\n                if (localMaxLength > 0.001) {\n                    const currentGrowthSpeed = isFlowing.value ? growthSpeed * FLOW_GROWTH_SPEED_FACTOR : growthSpeed;\n                    const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n                    const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                    const easedTime = Math.pow(normalizedTime, growthEaseOutPower);\n                    localCurrentLength = easedTime * localMaxLength;\n                } else {\n                    localCurrentLength = 0;\n                }\n                if (isFlowing.value && localCurrentLength >= localMaxLength * 0.999) {\n                    lineFlowState[lineIndex] = 'pauseAtEnd';\n                    const randomDelay = Math.random() * MAX_PAUSE_AT_END_DELAY;\n                    linePauseAtEndEndTime[lineIndex] = currentTime + randomDelay;\n                    localCurrentLength = localMaxLength;\n                }\n                break;\n\n            case 'pauseAtEnd':\n                if (currentTime >= (linePauseAtEndEndTime[lineIndex] || currentTime + 1)) {\n                    lineFlowState[lineIndex] = 'shrinking';\n                    lineShrinkStartTimes[lineIndex] = currentTime;\n                    linePauseAtEndEndTime[lineIndex] = undefined;\n                    localCurrentLength = localMaxLength;\n                } else {\n                    localCurrentLength = localMaxLength;\n                }\n                break;\n\n            case 'shrinking':\n                const timeSinceShrinking = currentTime - (lineShrinkStartTimes[lineIndex] || currentTime);\n                const currentShrinkDuration = BASE_SHRINK_DURATION * FLOW_SHRINK_DURATION_FACTOR;\n                const shrinkFactor = Math.max(0, 1.0 - timeSinceShrinking / currentShrinkDuration);\n                localCurrentLength = localMaxLength * shrinkFactor;\n\n                if (shrinkFactor === 0) {\n                    if (isFlowing.value) {\n                        lineFlowState[lineIndex] = 'pauseAtStart';\n                        const randomDelay = Math.random() * MAX_PAUSE_AT_START_DELAY;\n                        linePauseAtStartEndTime[lineIndex] = currentTime + randomDelay;\n                        lineShrinkStartTimes[lineIndex] = undefined;\n                        localCurrentLength = 0.001;\n                    } else {\n                        lineFlowState[lineIndex] = 'growing'; // Or set to idle\n                        lineShrinkStartTimes[lineIndex] = undefined;\n                        lineStartTimes[lineIndex] = undefined; // Stop updating\n                        localCurrentLength = 0.001;\n                    }\n                }\n                break;\n\n            case 'pauseAtStart':\n                if (currentTime >= (linePauseAtStartEndTime[lineIndex] || currentTime + 1)) {\n                    if (!randomDirections[lineIndex]) randomDirections[lineIndex] = new THREE.Vector3();\n                    randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n                    lineTypes[lineIndex] = (lineIndex < ttNumLines.value) ? 'tt' : 'th';\n                    const minL = (lineTypes[lineIndex] === 'tt') ? ttMinWorldLength.value : thMinWorldLength.value;\n                    const maxL = (lineTypes[lineIndex] === 'tt') ? ttMaxWorldLength.value : thMaxWorldLength.value;\n                    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(minL, maxL);\n                    lineStartTimes[lineIndex] = currentTime;\n                    lineFlowState[lineIndex] = 'growing';\n                    linePauseAtStartEndTime[lineIndex] = undefined;\n                    localCurrentLength = 0.001;\n                } else {\n                     localCurrentLength = 0.001;\n                }\n                break;\n\n            default: // Includes non-flowing case\n                 if (localMaxLength > 0.001 && lineStartTimes[lineIndex] !== undefined) {\n                    const currentGrowthSpeed = growthSpeed;\n                    const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n                    const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                    const easedTime = Math.pow(normalizedTime, growthEaseOutPower);\n                    localCurrentLength = easedTime * localMaxLength;\n                } else {\n                    localCurrentLength = 0;\n                }\n                break;\n        }\n        // --- Length calculation finished ---\n\n        if (localCurrentLength <= 0.001) continue;\n\n        const currentDirection = randomDirections[lineIndex];\n        const currentLineType = lineTypes[lineIndex];\n        if (!currentDirection || !currentLineType) continue;\n\n        // Select parameters based on type\n        let lineStartStrength, lineEndStrength, lineShrinkPowerVal;\n        if (currentLineType === 'tt') {\n            lineStartStrength = ttStartStrength.value;\n            lineEndStrength = ttEndStrength.value;\n            lineShrinkPowerVal = ttShrinkPower.value;\n        } else { // 'th'\n            lineStartStrength = thStartStrength.value;\n            lineEndStrength = thEndStrength.value;\n            lineShrinkPowerVal = thShrinkPower.value;\n        }\n\n        // Calculate Metaball strength and position\n        for (let i = 0; i <= numSegments; i++) {\n            const segmentT = i / numSegments;\n            const strengthFactor = Math.pow(segmentT, lineShrinkPowerVal);\n            const baseStrength = THREE.MathUtils.lerp(lineStartStrength, lineEndStrength, strengthFactor);\n\n            let dynamicStrength = baseStrength;\n            if (isFlowing.value) {\n                const flowFrequency = 1.0;\n                const flowAmplitude = 0.15 * baseStrength;\n                const flowOffset = Math.sin(currentTime * flowFrequency - segmentT * Math.PI * 4) * flowAmplitude;\n                dynamicStrength += flowOffset;\n                dynamicStrength = Math.max(dynamicStrength, 0);\n            }\n\n            const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n            const finalPos = localPos.add(centerOffset);\n\n            obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, subtract);\n        }\n    }\n\n    obj.update();\n}\n\nfunction exportConfiguration() {\n    if (!camera) return;\n    console.log(\"開始匯出設定...\");\n    const serializableDirections = randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null);\n    const cameraPosition = { x: camera.position.x, y: camera.position.y, z: camera.position.z };\n    // Use _x, _y, etc. for quaternion serialization if needed, but check GLTFExporter compatibility\n    const cameraQuaternion = { x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z, w: camera.quaternion.w };\n\n    const config = {\n        ttStartStrength: ttStartStrength.value,\n        ttEndStrength: ttEndStrength.value,\n        ttMinWorldLength: ttMinWorldLength.value,\n        ttMaxWorldLength: ttMaxWorldLength.value,\n        ttShrinkPower: ttShrinkPower.value,\n        ttNumLines: ttNumLines.value,\n        thStartStrength: thStartStrength.value,\n        thEndStrength: thEndStrength.value,\n        thMinWorldLength: thMinWorldLength.value,\n        thMaxWorldLength: thMaxWorldLength.value,\n        thShrinkPower: thShrinkPower.value,\n        thNumLines: thNumLines.value,\n        resolution: resolution.value,\n        isolation: isolation.value,\n        currentMaterial: currentMaterial.value,\n        // growthSpeed, growthEaseOutPower, numSegments, subtract are constants, maybe don't need export?\n        lineTypes: lineTypes,\n        randomDirections: serializableDirections,\n        currentTargetLengths: currentTargetLengths,\n        cameraPosition: cameraPosition,\n        cameraQuaternion: cameraQuaternion // Be mindful of THREE.Quaternion serialization format\n    };\n\n    try {\n        const configString = JSON.stringify(config, null, 2);\n        const blob = new Blob([configString], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'metaball_config.json';\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        console.log(\"設定已匯出為 metaball_config.json\");\n    } catch (e) {\n        console.error(\"匯出設定失敗:\", e);\n        alert(\"匯出設定失敗！\");\n    }\n}\n\nfunction triggerImport() {\n    importConfigFileRef.value?.click();\n}\n\nfunction importConfiguration(event: Event) {\n    console.log(\"開始匯入設定...\");\n    const file = (event.target as HTMLInputElement)?.files?.[0];\n    if (!file) {\n        console.log(\"未選擇檔案。\");\n        return;\n    }\n\n    const reader = new FileReader();\n    reader.onload = function(e) {\n        try {\n            const config = JSON.parse(e.target?.result as string);\n            console.log(\"讀取的設定:\", config);\n\n            if (!config || typeof config !== 'object') throw new Error(\"無效的設定檔格式\");\n            const requiredKeys = ['ttStartStrength', 'thStartStrength', 'resolution', 'isolation', 'lineTypes', 'randomDirections', 'currentTargetLengths', 'cameraPosition', 'cameraQuaternion'];\n            for (const key of requiredKeys) {\n                if (!(key in config)) throw new Error(`缺少必要欄位: ${key}`);\n            }\n            // Ensure ttNumLines and thNumLines exist for validation\n            if (!('ttNumLines' in config) || !('thNumLines' in config)) {\n                 throw new Error(`缺少必要欄位: ttNumLines or thNumLines`);\n            }\n            const totalLines = config.ttNumLines + config.thNumLines;\n            if (!Array.isArray(config.lineTypes) || config.lineTypes.length !== totalLines ||\n                !Array.isArray(config.randomDirections) || config.randomDirections.length !== totalLines ||\n                !Array.isArray(config.currentTargetLengths) || config.currentTargetLengths.length !== totalLines) {\n                throw new Error(\"線條數據數量與線條總數不符\");\n            }\n\n            // Update reactive refs\n            ttStartStrength.value = config.ttStartStrength;\n            ttEndStrength.value = config.ttEndStrength;\n            ttMinWorldLength.value = config.ttMinWorldLength;\n            ttMaxWorldLength.value = config.ttMaxWorldLength;\n            ttShrinkPower.value = config.ttShrinkPower;\n            ttNumLines.value = config.ttNumLines;\n            thStartStrength.value = config.thStartStrength;\n            thEndStrength.value = config.thEndStrength;\n            thMinWorldLength.value = config.thMinWorldLength;\n            thMaxWorldLength.value = config.thMaxWorldLength;\n            thShrinkPower.value = config.thShrinkPower;\n            thNumLines.value = config.thNumLines;\n            resolution.value = config.resolution;\n            isolation.value = config.isolation;\n            currentMaterial.value = config.currentMaterial || 'shader';\n\n            // Update non-reactive Three.js state\n            if (effect) {\n                // effect.init(resolution.value); // updateMarchingCubesParams handles this via watcher\n                effect.isolation = isolation.value;\n                effect.material = materials[currentMaterial.value as keyof typeof materials];\n            }\n            if (camera && controls) {\n                 if (config.cameraPosition) {\n                    camera.position.set(config.cameraPosition.x, config.cameraPosition.y, config.cameraPosition.z);\n                }\n                if (config.cameraQuaternion) {\n                    // Ensure correct properties are used for Quaternion\n                    camera.quaternion.set(config.cameraQuaternion.x ?? config.cameraQuaternion._x,\n                                          config.cameraQuaternion.y ?? config.cameraQuaternion._y,\n                                          config.cameraQuaternion.z ?? config.cameraQuaternion._z,\n                                          config.cameraQuaternion.w ?? config.cameraQuaternion._w);\n                }\n                controls.update();\n            }\n\n\n            // Update line data arrays\n            const currentTime = clock?.getElapsedTime() ?? 0;\n            lineStartTimes.length = totalLines;\n            randomDirections.length = totalLines;\n            currentTargetLengths.length = totalLines;\n            lineTypes.length = totalLines;\n\n            for (let i = 0; i < totalLines; i++) {\n                lineTypes[i] = config.lineTypes[i];\n                currentTargetLengths[i] = config.currentTargetLengths[i];\n                if (config.randomDirections[i]) {\n                    randomDirections[i] = new THREE.Vector3(\n                        config.randomDirections[i].x,\n                        config.randomDirections[i].y,\n                        config.randomDirections[i].z\n                    );\n                } else {\n                    randomDirections[i] = null;\n                }\n                lineStartTimes[i] = currentTime; // Start growing immediately after import\n                lineFlowState[i] = 'growing'; // Reset flow state\n                lineShrinkStartTimes[i] = undefined;\n                linePauseAtEndEndTime[i] = undefined;\n                linePauseAtStartEndTime[i] = undefined;\n            }\n\n            effect?.reset();\n            console.log(\"設定已成功匯入。\");\n            alert(\"設定已載入！\");\n\n        } catch (e: any) {\n            console.error(\"匯入設定失敗:\", e);\n            alert(`匯入設定失敗！錯誤: ${e.message}`);\n        } finally {\n            if (importConfigFileRef.value) {\n                 importConfigFileRef.value.value = ''; // Reset file input\n            }\n        }\n    };\n    reader.onerror = function(e) {\n        console.error(\"讀取檔案錯誤:\", e);\n        alert(\"讀取檔案時發生錯誤。\");\n         if (importConfigFileRef.value) {\n             importConfigFileRef.value.value = ''; // Reset file input\n        }\n    };\n    reader.readAsText(file);\n}\n\nfunction exportGLB() {\n    if (!effect || !camera) return;\n    console.log(\"開始匯出 GLB (應用視角, 臨時提高解析度至 200)...\");\n    const originalResolution = resolution.value;\n    const originalEffectQuaternion = effect.quaternion.clone();\n    const exporter = new GLTFExporter();\n\n    try {\n        const exportResolution = 200; // Use fixed export resolution\n        console.log(`  - 原解析度: ${originalResolution}, 臨時設為: ${exportResolution}`);\n        // resolution.value = exportResolution; // Temporarily change - DON'T, use init directly\n        effect.init(exportResolution); // Re-init with higher resolution\n\n        console.log(\"  - 重新計算高解析度模型...\");\n        updateLineMetaball(effect); // Force recalculation at high res\n        console.log(\"  - 高解析度模型計算完成.\");\n\n        console.log(\"  - 應用反向攝影機旋轉...\");\n        const cameraInverseQuaternion = camera.quaternion.clone().invert();\n        effect.quaternion.premultiply(cameraInverseQuaternion);\n        effect.updateMatrixWorld(true); // Force update\n        console.log(\"  - 反向旋轉已應用.\");\n\n        exporter.parse(\n            effect,\n            (result: ArrayBuffer) => { // result is ArrayBuffer or JSON object based on options\n                if (result instanceof ArrayBuffer) {\n                    try {\n                        const blob = new Blob([result], { type: 'model/gltf-binary' });\n                        const url = URL.createObjectURL(blob);\n                        const a = document.createElement('a');\n                        a.href = url;\n                        a.download = `metaball_model_view_res${exportResolution}.glb`;\n                        document.body.appendChild(a);\n                        a.click();\n                        document.body.removeChild(a);\n                        URL.revokeObjectURL(url);\n                        console.log(`GLB 檔案已匯出: metaball_model_view_res${exportResolution}.glb`);\n                        alert(`高解析度 (含視角, res ${exportResolution}) GLB 模型已下載！`);\n                    } catch (e) {\n                        console.error(\"建立或下載 GLB Blob 時出錯:\", e);\n                        alert(\"下載 GLB 時發生錯誤！\");\n                    }\n                } else {\n                    console.error(\"匯出結果不是預期的 ArrayBuffer:\", result);\n                    alert(\"匯出 GLB 失敗：格式錯誤。請檢查控制台。\");\n                }\n                 // Restore original state (Success)\n                console.log(\"  - (成功) 恢復原始模型旋轉和解析度...\");\n                effect.quaternion.copy(originalEffectQuaternion);\n                effect.updateMatrixWorld(true);\n                // resolution.value = originalResolution; // Restore reactive ref\n                effect.init(originalResolution); // Re-init with original resolution\n                console.log(\"  - 模型旋轉和解析度已恢復.\");\n            },\n            (error: Error | unknown) => { // Error callback type can vary\n                console.error('匯出 GLB 時發生錯誤:', error);\n                alert(\"匯出 GLB 時發生錯誤！請檢查控制台。\");\n                // Restore original state (Error)\n                console.log(\"  - (錯誤) 恢復原始模型旋轉和解析度...\");\n                effect.quaternion.copy(originalEffectQuaternion);\n                effect.updateMatrixWorld(true);\n                // if (resolution.value !== originalResolution) {\n                //     resolution.value = originalResolution;\n                // }\n                effect.init(originalResolution); // Re-init with original resolution\n                console.log(\"  - 模型旋轉和解析度已恢復.\");\n            },\n            { binary: true }\n        );\n    } catch (e) {\n         console.error(\"準備匯出或應用旋轉時出錯:\", e);\n         alert(\"準備匯出高解析度模型時發生錯誤！\");\n         // Restore original state (Catch)\n         console.log(\"  - (Catch) 恢復原始模型旋轉和解析度...\");\n         effect.quaternion.copy(originalEffectQuaternion);\n         effect.updateMatrixWorld(true);\n         // if (resolution.value !== originalResolution) {\n         //     resolution.value = originalResolution;\n         // }\n         effect.init(originalResolution); // Re-init with original resolution\n         console.log(\"  - 模型旋轉和解析度已恢復.\");\n    }\n}\n\nfunction toggleMaterial() {\n    if (!effect || !scene) return;\n    if (currentMaterial.value === 'shader') {\n        currentMaterial.value = 'liquid';\n        if (scene.background instanceof THREE.Color) {\n             scene.background.set(0x111111); // Dark background for liquid\n        }\n    } else {\n        currentMaterial.value = 'shader';\n         if (scene.background instanceof THREE.Color) {\n             scene.background.set(0xffffff); // White background for shader\n        }\n    }\n    effect.material = materials[currentMaterial.value as keyof typeof materials];\n    console.log(`材質已切換為: ${currentMaterial.value}, 背景顏色已更新.`);\n}\n\nfunction toggleFlow() {\n    if (!clock || !effect || !camera || !controls) return;\n\n    if (isFlowing.value) {\n        // --- Stop Flow ---\n        isFlowing.value = false;\n        console.log(\"流動動畫已停止，正在恢復狀態...\");\n        // isFirstFlowTrigger = true; // Optional: Reset for next time\n\n        if (savedLineState) {\n            ttNumLines.value = savedLineState.ttNumLines;\n            thNumLines.value = savedLineState.thNumLines;\n            lineTypes = [...savedLineState.lineTypes];\n            randomDirections = savedLineState.randomDirections.map((dir: any) => dir ? new THREE.Vector3(dir.x, dir.y, dir.z) : null);\n            currentTargetLengths = [...savedLineState.currentTargetLengths];\n            lineStartTimes = [...savedLineState.lineStartTimes];\n\n            lineFlowState = lineTypes.map(() => 'growing');\n            lineShrinkStartTimes = lineTypes.map(() => undefined);\n            linePauseAtEndEndTime = lineTypes.map(() => undefined);\n            linePauseAtStartEndTime = lineTypes.map(() => undefined);\n\n            console.log(\"線條狀態已恢復\");\n            savedLineState = null;\n        } else {\n            console.warn(\"找不到保存的狀態來恢復。\")\n        }\n\n        if (savedCameraState) {\n            camera.position.copy(savedCameraState.position);\n            camera.quaternion.copy(savedCameraState.quaternion);\n            controls.update();\n            console.log(\"相機狀態已恢復\");\n            savedCameraState = null;\n        } else {\n             console.warn(\"找不到保存的相機狀態來恢復。\")\n        }\n\n        effect.reset();\n\n    } else {\n        // --- Start Flow ---\n        console.log(\"開始流動動畫，正在保存當前狀態並設置隨機延遲...\");\n        savedLineState = {\n            ttNumLines: ttNumLines.value,\n            thNumLines: thNumLines.value,\n            lineTypes: [...lineTypes],\n            randomDirections: randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null),\n            currentTargetLengths: [...currentTargetLengths],\n            lineStartTimes: [...lineStartTimes]\n        };\n        savedCameraState = {\n            position: camera.position.clone(),\n            quaternion: camera.quaternion.clone()\n        };\n        console.log(\"狀態已保存。\");\n\n        isFlowing.value = true;\n\n        const startTime = clock.getElapsedTime();\n        const totalLines = ttNumLines.value + thNumLines.value;\n        lineFlowState.length = totalLines;\n        lineShrinkStartTimes.length = totalLines;\n        linePauseAtEndEndTime.length = totalLines;\n        linePauseAtStartEndTime.length = totalLines;\n\n        if (isFirstFlowTrigger) {\n             console.log(\"首次觸發流動：所有線條同時開始。\");\n            for (let i = 0; i < totalLines; i++) {\n                lineStartTimes[i] = startTime;\n                lineFlowState[i] = 'growing';\n                lineShrinkStartTimes[i] = undefined;\n                linePauseAtEndEndTime[i] = undefined;\n                linePauseAtStartEndTime[i] = undefined;\n            }\n            isFirstFlowTrigger = false;\n        } else {\n            console.log(`非首次觸發流動：各線條將在 ${MAX_INITIAL_FLOW_DELAY.toFixed(1)} 秒內隨機開始。`);\n            for (let i = 0; i < totalLines; i++) {\n                const randomInitialDelay = Math.random() * MAX_INITIAL_FLOW_DELAY;\n                lineStartTimes[i] = startTime + randomInitialDelay;\n                lineFlowState[i] = 'growing';\n                lineShrinkStartTimes[i] = undefined;\n                linePauseAtEndEndTime[i] = undefined;\n                linePauseAtStartEndTime[i] = undefined;\n            }\n        }\n\n        effect.reset();\n    }\n}\n\n// --- Input Handlers with Validation ---\nfunction handleTtStartStrengthInput() {\n    if (ttStartStrength.value < ttEndStrength.value) {\n        ttEndStrength.value = ttStartStrength.value;\n    }\n}\nfunction handleTtEndStrengthInput() {\n    if (ttEndStrength.value > ttStartStrength.value) {\n        ttStartStrength.value = ttEndStrength.value;\n    }\n}\nfunction handleTtMinLengthInput() {\n    if (ttMinWorldLength.value > ttMaxWorldLength.value) {\n        ttMaxWorldLength.value = ttMinWorldLength.value;\n    }\n}\nfunction handleTtMaxLengthInput() {\n    if (ttMaxWorldLength.value < ttMinWorldLength.value) {\n        ttMinWorldLength.value = ttMaxWorldLength.value;\n    }\n}\nfunction handleThStartStrengthInput() {\n    if (thStartStrength.value > thEndStrength.value) {\n        thEndStrength.value = thStartStrength.value;\n    }\n}\nfunction handleThEndStrengthInput() {\n    if (thEndStrength.value < thStartStrength.value) {\n        thStartStrength.value = thEndStrength.value;\n    }\n}\nfunction handleThMinLengthInput() {\n    if (thMinWorldLength.value > thMaxWorldLength.value) {\n        thMaxWorldLength.value = thMinWorldLength.value;\n    }\n}\nfunction handleThMaxLengthInput() {\n    if (thMaxWorldLength.value < thMinWorldLength.value) {\n        thMinWorldLength.value = thMaxWorldLength.value;\n    }\n}\n\n// --- Watchers ---\nfunction updateMarchingCubesParams() {\n     if (effect) {\n        effect.init(resolution.value); // Reinitialize when resolution changes\n        effect.isolation = isolation.value;\n        console.log(`Marching Cubes params updated: resolution=${resolution.value}, isolation=${isolation.value}`);\n    }\n}\n// Watch resolution and isolation to update MarchingCubes\nwatch(resolution, updateMarchingCubesParams);\nwatch(isolation, updateMarchingCubesParams);\n\n\n// --- Animation Loop ---\nfunction animate() {\n  animationFrameId = requestAnimationFrame(animate);\n\n  if (!effect || !materials || !camera || !renderer || !scene || !controls) return; // Guard\n\n  effect.material = materials[currentMaterial.value as keyof typeof materials];\n  if (currentMaterial.value === 'shader') {\n      const currentTime = clock.getElapsedTime();\n      effect.material.uniforms.uTime.value = currentTime;\n      effect.material.uniforms.viewVector.value = camera.position;\n  }\n\n  updateLineMetaball(effect);\n\n  controls.update();\n  renderer.render(scene, camera);\n}\n\n// --- Resize Handler ---\nfunction handleResize() {\n    if (!camera || !renderer || !materials) return;\n    const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n    const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n    if (materials.shader) {\n        materials.shader.uniforms.uResolution.value.set(width, height);\n    }\n    // Consider if FXAA pass needs resize (if used)\n}\n\n// --- Lifecycle Hooks ---\nonMounted(() => {\n  if (!canvasContainer.value) {\n    console.error(\"Canvas container not found!\");\n    return;\n  }\n  const container = canvasContainer.value;\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n\n  // Scene\n  scene = new THREE.Scene();\n  scene.background = new THREE.Color(0xffffff); // Initial background color\n\n  // Camera\n  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  camera.position.set(0, 0, 30);\n  camera.lookAt(scene.position);\n\n  // Renderer\n  renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n  container.appendChild(renderer.domElement);\n\n  // Controls\n  controls = new OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n\n  // Lights\n  scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n  dirLight.position.set(5, 10, 7.5);\n  scene.add(dirLight);\n\n  // PMREMGenerator\n  pmremGenerator = new THREE.PMREMGenerator(renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  // Materials\n  materials = generateMaterials(); // Generate materials after camera is defined\n\n  // Marching Cubes\n  effect = new MarchingCubes(resolution.value, materials[currentMaterial.value as keyof typeof materials], true, true, 100000);\n  effect.isolation = isolation.value;\n  effect.scale.set(8, 8, 8);\n  effect.enableUvs = false;\n  effect.enableColors = false;\n  scene.add(effect);\n\n  // Clock\n  clock = new THREE.Clock();\n\n  // Load Env Map\n  loadEnvironmentMap();\n\n  // Initial line generation\n  regenerateLine();\n\n  // Start animation\n  animate();\n\n  // Add resize listener\n  window.addEventListener('resize', handleResize);\n});\n\nonUnmounted(() => {\n  // Stop animation\n  cancelAnimationFrame(animationFrameId);\n\n  // Remove resize listener\n  window.removeEventListener('resize', handleResize);\n\n  // Dispose Three.js objects\n  if (controls) controls.dispose();\n  if (renderer) renderer.dispose();\n  if (materials) {\n      materials.shader?.dispose();\n      materials.liquid?.dispose();\n      // Dispose envMap if loaded\n      if (scene?.environment) scene.environment.dispose();\n  }\n  if (effect) {\n      // MarchingCubes doesn't have a direct dispose method, rely on scene cleanup\n      scene?.remove(effect);\n      // Dispose geometry/material if needed, but MarchingCubes manages internal geometry\n  }\n   if (scene) {\n        // Dispose geometries, materials, textures in the scene\n        scene.traverse((object: THREE.Object3D) => {\n            if (object instanceof THREE.Mesh) {\n                object.geometry?.dispose();\n                // Check if material is an array or single\n                const material = object.material as THREE.Material | THREE.Material[];\n                if (Array.isArray(material)) {\n                    material.forEach((mat: THREE.Material) => mat.dispose());\n                } else if (material) {\n                    material.dispose();\n                }\n            }\n        });\n    }\n    if(pmremGenerator) pmremGenerator.dispose(); // Dispose PMREMGenerator\n\n  // Remove canvas\n  if (canvasContainer.value && renderer) {\n    canvasContainer.value.removeChild(renderer.domElement);\n  }\n\n  console.log(\"Three.js scene cleaned up.\");\n});\n\n</script>"],"names":[],"mappings":";;;;;;AAiGwB,QAA2B,IAAI;AAC3B,QAA6B,IAAI;AAKvD,UAAA,kBAAkB,IAAI,GAAG;AACzB,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,mBAAmB,IAAI,GAAG;AAC1B,UAAA,mBAAmB,IAAI,GAAG;AAC1B,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,aAAa,IAAI,CAAC;AAGlB,UAAA,kBAAkB,IAAI,IAAI;AAC1B,UAAA,gBAAgB,IAAI,GAAG;AACvB,UAAA,mBAAmB,IAAI,CAAC;AACxB,UAAA,mBAAmB,IAAI,CAAC;AACxB,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,aAAa,IAAI,CAAC;AAGlB,UAAA,aAAa,IAAI,GAAG;AACpB,UAAA,YAAY,IAAI,GAAG;AACnB,UAAA,kBAAkB,IAAyB,QAAQ;AACnD,UAAA,YAAY,IAAI,KAAK;AAwCrB,UAAA,2BAA2B,SAAS,MAAM;AACvC,aAAA,gBAAgB,UAAU,WAAW,YAAY;AAAA,IAAA,CACzD;AAEK,UAAA,uBAAuB,SAAS,MAAM;AACnC,aAAA,UAAU,QAAQ,WAAW;AAAA,IAAA,CACrC;AAmrBD,aAAS,4BAA4B;AAAA,IAKjC;AAGJ,UAAM,YAAY,yBAAyB;AAC3C,UAAM,WAAW,yBAAyB;;;;;;"}