{"file":"ver2.vue.mjs","mappings":";;;;;;AAkHwB,QAAI,IAAI;AACJ,QAAI,IAAI;AAK9B,UAAA,kBAAkB,IAAI,GAAG;AACzB,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,mBAAmB,IAAI,GAAG;AAC1B,UAAA,mBAAmB,IAAI,GAAG;AAC1B,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,aAAa,IAAI,CAAC;AAGlB,UAAA,kBAAkB,IAAI,IAAI;AAC1B,UAAA,gBAAgB,IAAI,GAAG;AACvB,UAAA,mBAAmB,IAAI,CAAC;AACxB,UAAA,mBAAmB,IAAI,CAAC;AACxB,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,aAAa,IAAI,CAAC;AAGlB,UAAA,aAAa,IAAI,GAAG;AACpB,UAAA,kBAAkB,IAAI,QAAQ;AAC9B,UAAA,YAAY,IAAI,KAAK;AACrB,UAAA,cAAc,IAAI,KAAK;AAyqB7B,aAAS,4BAA4B;AAAA,IAMjC;AAGJ,UAAM,YAAY,yBAAyB;;;;;;;;;;;;","names":[],"sources":["../../../../pages/ver2.vue"],"sourcesContent":["<template>\n  <div class=\"splash-container\">\n    <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n\n    <!-- 控制面板 HTML - 由粗到細 -->\n    <div id=\"thickToThinPanel\" class=\"control-panel thick-to-thin-panel\">\n      <div class=\"panel-title\">由粗到細 線條控制</div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">最粗粗度 (強度): <span class=\"value-display\">{{ ttStartStrength.toFixed(2) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttStartStrength\" min=\"0\" max=\"0.1\" step=\"0.01\" @input=\"handleTtStartStrengthInput\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">最細粗度 (強度): <span class=\"value-display\">{{ ttEndStrength.toFixed(2) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttEndStrength\" min=\"0.0\" max=\"0.1\" step=\"0.01\" @input=\"handleTtEndStrengthInput\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">最短長度: <span class=\"value-display\">{{ ttMinWorldLength.toFixed(1) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttMinWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleTtMinLengthInput\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">最長長度: <span class=\"value-display\">{{ ttMaxWorldLength.toFixed(1) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttMaxWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleTtMaxLengthInput\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">收縮速率 (冪): <span class=\"value-display\">{{ ttShrinkPower.toFixed(2) }}</span></label>\n        <input type=\"range\" v-model.number=\"ttShrinkPower\" min=\"0.1\" max=\"5.0\" step=\"0.05\">\n      </div>\n      <div class=\"control-group\">\n        <label class=\"control-label\">線條數量: <span class=\"value-display\">{{ ttNumLines }}</span></label>\n        <input type=\"range\" v-model.number=\"ttNumLines\" min=\"0\" max=\"10\" step=\"1\" @input=\"regenerateLine\">\n      </div>\n    </div>\n\n    <!-- 控制面板 HTML - 由細到粗 -->\n    <div id=\"thinToThickPanel\" class=\"control-panel thin-to-thick-panel\">\n        <div class=\"panel-title\">由細到粗 線條控制</div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">最細粗度 (強度): <span class=\"value-display\">{{ thStartStrength.toFixed(2) }}</span></label>\n            <input type=\"range\" v-model.number=\"thStartStrength\" min=\"0.0\" max=\"0.1\" step=\"0.01\" @input=\"handleThStartStrengthInput\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">最粗粗度 (強度): <span class=\"value-display\">{{ thEndStrength.toFixed(2) }}</span></label>\n            <input type=\"range\" v-model.number=\"thEndStrength\" min=\"0\" max=\"0.1\" step=\"0.01\" @input=\"handleThEndStrengthInput\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">最短長度: <span class=\"value-display\">{{ thMinWorldLength.toFixed(1) }}</span></label>\n            <input type=\"range\" v-model.number=\"thMinWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleThMinLengthInput\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">最長長度: <span class=\"value-display\">{{ thMaxWorldLength.toFixed(1) }}</span></label>\n            <input type=\"range\" v-model.number=\"thMaxWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleThMaxLengthInput\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">膨脹速率 (冪): <span class=\"value-display\">{{ thShrinkPower.toFixed(2) }}</span></label>\n            <input type=\"range\" v-model.number=\"thShrinkPower\" min=\"0.1\" max=\"5.0\" step=\"0.05\">\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\">線條數量: <span class=\"value-display\">{{ thNumLines }}</span></label>\n            <input type=\"range\" v-model.number=\"thNumLines\" min=\"0\" max=\"10\" step=\"1\" @input=\"regenerateLine\">\n        </div>\n    </div>\n\n    <!-- 通用控制面板 HTML -->\n    <div id=\"commonPanel\" class=\"control-panel common-panel\">\n        <div class=\"panel-title\">通用控制</div>\n        <button @click=\"regenerateLine\">重新生成所有線條</button>\n        <button @click=\"exportConfiguration\" style=\"margin-top: 5px;\">匯出設定 (JSON)</button>\n        <button @click=\"triggerImport\" style=\"margin-top: 5px;\">匯入設定 (JSON)</button>\n        <input type=\"file\" ref=\"importConfigFileRef\" @change=\"importConfiguration\" accept=\".json\" style=\"display: none;\">\n        <button @click=\"exportGLB\" style=\"margin-top: 5px;\">下載目前模型 (GLB)</button>\n    </div>\n\n    <!-- 新增左下角 Switch 控制面板 -->\n    <div id=\"switchPanel\" class=\"control-panel switch-panel\">\n        <div class=\"panel-title\">快速切換</div>\n        \n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ currentMaterial === 'shader' ? '描邊材質' : '液體材質' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"currentMaterial === 'liquid'\" @change=\"toggleMaterial\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n\n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ isFlowing ? '流動中' : '靜止' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"isFlowing\" @change=\"toggleFlow\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n\n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ isPixelated ? '像素化' : '正常' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"isPixelated\" @change=\"togglePixelation\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPixelatedPass } from 'three/examples/jsm/postprocessing/RenderPixelatedPass.js';\nimport { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// --- Refs ---\nconst canvasContainer = ref(null);\nconst importConfigFileRef = ref(null);\n\n// --- State (Reactive Variables) ---\n\n// Thick-to-Thin Parameters (由粗到細參數)\nconst ttStartStrength = ref(0.1);   // 線條起始端的粗度強度值，數值越大起始端越粗\nconst ttEndStrength = ref(0.01);    // 線條末端的粗度強度值，數值越小末端越細\nconst ttMinWorldLength = ref(2.5);  // 由粗到細線條的最小長度，影響隨機生成的短線條\nconst ttMaxWorldLength = ref(3.5);  // 由粗到細線條的最大長度，影響隨機生成的長線條\nconst ttShrinkPower = ref(0.25);    // 由粗到細的收縮速率指數，影響線條粗細變化的曲線形狀\nconst ttNumLines = ref(4);          // 由粗到細線條的數量\n\n// Thin-to-Thick Parameters (由細到粗參數)\nconst thStartStrength = ref(0.01);  // 線條起始端的粗度強度值，數值越小起始端越細\nconst thEndStrength = ref(0.1);     // 線條末端的粗度強度值，數值越大末端越粗\nconst thMinWorldLength = ref(2);    // 由細到粗線條的最小長度，影響隨機生成的短線條\nconst thMaxWorldLength = ref(3);    // 由細到粗線條的最大長度，影響隨機生成的長線條\nconst thShrinkPower = ref(1.25);    // 由細到粗的膨脹速率指數，影響線條粗細變化的曲線形狀\nconst thNumLines = ref(3);          // 由細到粗線條的數量\n\n// Shared Parameters (共享參數)\nconst resolution = ref(200);        // Marching Cubes 算法的解析度，影響模型細節和表面平滑度\nconst currentMaterial = ref('shader'); // 當前使用的材質類型，可選 'shader'(描邊) 或 'liquid'(液體)\nconst isFlowing = ref(false);       // 控制線條是否處於流動動畫模式\nconst isPixelated = ref(false);     // 控制是否啟用像素化效果\n\n// Internal state (內部狀態變數)\nlet scene;                  // Three.js 場景物件\nlet camera;                 // 攝影機物件\nlet renderer;               // 渲染器物件\nlet controls;               // 控制器物件，用於控制攝影機移動\nlet effect;                 // Marching Cubes 效果物件\nlet clock;                  // 時鐘物件，用於時間相關計算\nlet materials;              // 材質集合\nlet pmremGenerator;         // 預計算反射環境映射生成器\nlet composer;               // 效果合成器，用於後處理\nlet pixelPass;              // 像素化效果處理器\nlet animationFrameId;       // 動畫幀 ID，用於取消動畫\n\n// Line Data (線條數據)\nlet lineStartTimes = [];    // 儲存每條線的開始時間\nlet randomDirections = [];  // 儲存每條線的隨機方向向量\nlet currentTargetLengths = []; // 儲存每條線的目標長度\nlet lineTypes = [];         // 儲存每條線的類型 ('tt' 或 'th')\nlet lineFlowState = [];     // 儲存每條線的流動狀態\n\n// 流動控制相關變數\nlet savedLineState = null;  // 儲存流動開始前的線條狀態，用於恢復\nlet savedCameraState = null; // 儲存流動開始前的攝影機狀態，用於恢復\nlet shrinkStartTime = null; // 收合開始時間，用於同步計算收合進度\nlet shrinkEndTime = null;   // 收合結束時間，用於同步計算收合完成度\nlet growStartTime = null;   // 生長開始時間，用於同步計算生長進度\nlet maxCenterBallStrength = 2.0; // 中心球體最大強度，控制球體最大大小\nlet minCenterBallStrength = 0.0; // 中心球體最小強度，控制球體最小大小\nlet centerBallVisible = false;   // 球體可見性狀態，控制是否顯示中心球體\nlet globalFlowState = 'idle';    // 全局流動狀態，控制所有線條的統一動畫行為\n\n// Constants (常數)\nconst growthSpeed = 5.0;             // 線條生長速度\nconst growthEaseOutPower = 0.15;     // 生長緩動指數，控制生長速度變化曲線\nconst numSegments = 50;              // 每條線分段數量，影響線條平滑度和細節\nconst subtract = 20;                 // metaball 減法參數，影響形狀融合方式\nconst FLOW_GROWTH_SPEED_FACTOR = 0.1;  // 流動模式下的生長速度因子，會使生長變慢\nconst FLOW_SHRINK_DURATION_FACTOR = 0.2; // 流動模式下的收縮持續時間因子\nconst BASE_SHRINK_DURATION = 3.0;     // 基本收縮持續時間，秒數\n\n// 流體波浪效果相關參數\nconst FLOW_WAVE_FREQUENCY = 1.0;      // 波浪頻率，控制波浪振動的速度\nconst FLOW_WAVE_AMPLITUDE_FACTOR = 0.15; // 波浪振幅因子，與基礎強度相乘得到波浪振幅\nconst FLOW_WAVE_PHASE_FACTOR = Math.PI * 4; // 波浪相位因子，控制波浪的空間分佈\n\n// --- Shaders ---\nconst vertexShader = `\n  uniform vec3 viewVector;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  varying vec2 vUv;\n  varying float opacity;\n  void main() {\n    vUv = uv;\n    vec4 mvPos = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPos;\n    vec3 nNormal = normalize(normalMatrix * normal);\n    vec3 nView   = normalize(viewVector - mvPos.xyz);\n    opacity = dot(nNormal, nView);\n    opacity = 1.0 - abs(opacity * 1.3);\n  }\n`;\n\nconst fragmentShader = `\n  uniform vec3 uColor;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  varying vec2 vUv;\n  varying float opacity;\n  void main() {\n    vec2 d = gl_FragCoord.xy / uResolution;\n    vec3 fade = vec3(d.x, d.y, 1.0);\n    vec3 c = mix(vec3(0.0), fade * uColor, opacity);\n    gl_FragColor = vec4(c, 1.0);\n  }\n`;\n\n// --- Functions ---\n\nfunction generateMaterials() {\n  return {\n    shader: new THREE.ShaderMaterial({\n      uniforms: {\n        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n        uTime:       { value: 0 },\n        uColor:      { value: new THREE.Color(0x000000) },\n        viewVector:  { value: camera.position }\n      },\n      vertexShader:   vertexShader,\n      fragmentShader: fragmentShader,\n      transparent: true,\n      side: THREE.DoubleSide\n    }),\n    liquid: new THREE.MeshStandardMaterial({\n        color: 0xffffff,\n        metalness: 0.9,\n        roughness: 0,\n        transparent: true,\n        opacity: 0.25,\n        side: THREE.DoubleSide,\n        envMap: null // Will be set by loader\n    })\n  };\n}\n\nfunction loadEnvironmentMap() {\n  new EXRLoader()\n      .setPath('/hdr/') // Use path relative to public directory\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n          texture.mapping = THREE.EquirectangularReflectionMapping;\n          const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n          pmremGenerator.dispose();\n          texture.dispose();\n\n          console.log(\"本地 EXR 環境貼圖已載入並處理完成。\");\n          scene.environment = envMap;\n          if (materials && materials.liquid) {\n              materials.liquid.envMap = envMap;\n              materials.liquid.needsUpdate = true;\n          }\n      }, undefined, (error) => {\n          console.error('無法載入本地 EXR 環境貼圖:', error);\n          alert('無法載入 assets/hdr/HDR_Light_Studio_Free_HDRI_Design_05.exr，請檢查檔案是否存在或路徑是否正確。');\n      });\n}\n\nfunction regenerateLine() {\n    if (!clock || !effect) return; // Ensure initialization\n    const currentTime = clock.getElapsedTime();\n    const totalLines = ttNumLines.value + thNumLines.value;\n\n    // 調整陣列大小\n    lineStartTimes.length = totalLines;\n    randomDirections.length = totalLines;\n    currentTargetLengths.length = totalLines;\n    lineTypes.length = totalLines;\n    lineFlowState.length = totalLines;\n\n    let lineIndex = 0;\n\n    // 生成由粗到細線條\n    for(let i = 0; i < ttNumLines.value; i++) {\n        if (!randomDirections[lineIndex]) {\n            randomDirections[lineIndex] = new THREE.Vector3();\n        }\n        randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n        currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(ttMinWorldLength.value, ttMaxWorldLength.value);\n        lineTypes[lineIndex] = 'tt';\n        lineStartTimes[lineIndex] = currentTime;\n        lineFlowState[lineIndex] = 'growing';\n        lineIndex++;\n    }\n\n    // 生成由細到粗線條\n    for(let i = 0; i < thNumLines.value; i++) {\n        if (!randomDirections[lineIndex]) {\n            randomDirections[lineIndex] = new THREE.Vector3();\n        }\n        randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n        currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(thMinWorldLength.value, thMaxWorldLength.value);\n        lineTypes[lineIndex] = 'th';\n        lineStartTimes[lineIndex] = currentTime;\n        lineFlowState[lineIndex] = 'growing';\n        lineIndex++;\n    }\n    effect.reset();\n}\n\nfunction updateLineMetaball(obj) {\n    if (!clock) return;\n    obj.reset();\n    const currentTime = clock.getElapsedTime();\n    const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n    const totalLines = ttNumLines.value + thNumLines.value;\n\n    // 更新全局流動狀態\n    updateGlobalFlowState(currentTime);\n\n    // 添加中心metaball球體 (如果可見)\n    if (centerBallVisible) {\n        // 計算中心球體的強度\n        const centerBallStrength = calculateCenterBallStrength(currentTime);\n        if (centerBallStrength > 0.01) {\n            // 將中心球體添加到metaball系統\n            obj.addBall(centerOffset.x, centerOffset.y, centerOffset.z, centerBallStrength, subtract);\n        }\n    }\n\n    for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n        if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n            continue;\n        }\n\n        if (currentTargetLengths[lineIndex] === undefined) continue;\n        const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n        let localCurrentLength = 0;\n        let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n\n        // 使用全局狀態控制所有線條\n        if (isFlowing.value) {\n            switch (globalFlowState) {\n                case 'growing':\n                    if (localMaxLength > 0.001) {\n                        const currentGrowthSpeed = growthSpeed * FLOW_GROWTH_SPEED_FACTOR;\n                        const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n                        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                        const easedTime = Math.pow(normalizedTime, growthEaseOutPower);\n                        localCurrentLength = easedTime * localMaxLength;\n                    } else {\n                        localCurrentLength = 0;\n                    }\n                    break;\n                case 'pauseAtEnd':\n                    localCurrentLength = localMaxLength;\n                    break;\n                case 'shrinking':\n                    // 計算收合進度（所有線條使用相同的開始和結束時間）\n                    if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                        const timeSinceShrinking = currentTime - shrinkStartTime;\n                        const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                        const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n                        localCurrentLength = localMaxLength * shrinkFactor;\n                    } else {\n                        localCurrentLength = localMaxLength;\n                    }\n                    break;\n                case 'pauseAtStart':\n                    localCurrentLength = 0.001;\n                    break;\n                default:\n                    localCurrentLength = 0;\n                    break;\n            }\n            \n            // 更新單獨線條狀態以匹配全局狀態\n            lineFlowState[lineIndex] = globalFlowState;\n        } else {\n            // 非流動模式的原始邏輯\n            if (localMaxLength > 0.001) {\n                const normalizedTime = Math.min(timeSinceStart / (localMaxLength / (growthSpeed / obj.scale.x)), 1.0);\n                const easedTime = Math.pow(normalizedTime, growthEaseOutPower);\n                localCurrentLength = easedTime * localMaxLength;\n            } else {\n                localCurrentLength = 0;\n            }\n        }\n        \n        if (localCurrentLength <= 0.001) continue;\n\n        const currentDirection = randomDirections[lineIndex];\n        const currentLineType = lineTypes[lineIndex];\n        if (!currentDirection || !currentLineType) continue;\n\n        // 根據線條類型選擇參數\n        let lineStartStrength, lineEndStrength, lineShrinkPowerVal;\n        if (currentLineType === 'tt') {\n            lineStartStrength = ttStartStrength.value;\n            lineEndStrength = ttEndStrength.value;\n            lineShrinkPowerVal = ttShrinkPower.value;\n        } else { // 'th'\n            lineStartStrength = thStartStrength.value;\n            lineEndStrength = thEndStrength.value;\n            lineShrinkPowerVal = thShrinkPower.value;\n        }\n\n        // 計算Metaball強度和位置\n        for (let i = 0; i <= numSegments; i++) {\n            const segmentT = i / numSegments;\n            const strengthFactor = Math.pow(segmentT, lineShrinkPowerVal);\n            const baseStrength = THREE.MathUtils.lerp(lineStartStrength, lineEndStrength, strengthFactor);\n\n            let dynamicStrength = baseStrength;\n            if (isFlowing.value) {\n                const flowAmplitude = FLOW_WAVE_AMPLITUDE_FACTOR * baseStrength;\n                const flowOffset = Math.sin(currentTime * FLOW_WAVE_FREQUENCY - segmentT * FLOW_WAVE_PHASE_FACTOR) * flowAmplitude;\n                dynamicStrength += flowOffset;\n                dynamicStrength = Math.max(dynamicStrength, 0);\n            }\n\n            const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n            const finalPos = localPos.add(centerOffset);\n\n            obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, subtract);\n        }\n    }\n\n    obj.update();\n}\n\nfunction exportConfiguration() {\n    if (!camera) return;\n    console.log(\"開始匯出設定...\");\n    const serializableDirections = randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null);\n    const cameraPosition = { x: camera.position.x, y: camera.position.y, z: camera.position.z };\n    // Use _x, _y, etc. for quaternion serialization if needed, but check GLTFExporter compatibility\n    const cameraQuaternion = { x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z, w: camera.quaternion.w };\n\n    const config = {\n        ttStartStrength: ttStartStrength.value,\n        ttEndStrength: ttEndStrength.value,\n        ttMinWorldLength: ttMinWorldLength.value,\n        ttMaxWorldLength: ttMaxWorldLength.value,\n        ttShrinkPower: ttShrinkPower.value,\n        ttNumLines: ttNumLines.value,\n        thStartStrength: thStartStrength.value,\n        thEndStrength: thEndStrength.value,\n        thMinWorldLength: thMinWorldLength.value,\n        thMaxWorldLength: thMaxWorldLength.value,\n        thShrinkPower: thShrinkPower.value,\n        thNumLines: thNumLines.value,\n        resolution: resolution.value,\n        currentMaterial: currentMaterial.value,\n        // growthSpeed, growthEaseOutPower, numSegments, subtract are constants, maybe don't need export?\n        lineTypes: lineTypes,\n        randomDirections: serializableDirections,\n        currentTargetLengths: currentTargetLengths,\n        cameraPosition: cameraPosition,\n        cameraQuaternion: cameraQuaternion // Be mindful of THREE.Quaternion serialization format\n    };\n\n    try {\n        const configString = JSON.stringify(config, null, 2);\n        const blob = new Blob([configString], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'metaball_config.json';\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        console.log(\"設定已匯出為 metaball_config.json\");\n    } catch (e) {\n        console.error(\"匯出設定失敗:\", e);\n        alert(\"匯出設定失敗！\");\n    }\n}\n\nfunction triggerImport() {\n    importConfigFileRef.value?.click();\n}\n\nfunction importConfiguration(event) {\n    console.log(\"開始匯入設定...\");\n    const file = (event.target)?.files?.[0];\n    if (!file) {\n        console.log(\"未選擇檔案。\");\n        return;\n    }\n\n    const reader = new FileReader();\n    reader.onload = function(e) {\n        try {\n            const config = JSON.parse(e.target?.result);\n            console.log(\"讀取的設定:\", config);\n\n            if (!config || typeof config !== 'object') throw new Error(\"無效的設定檔格式\");\n            const requiredKeys = ['ttStartStrength', 'thStartStrength', 'resolution', 'lineTypes', 'randomDirections', 'currentTargetLengths', 'cameraPosition', 'cameraQuaternion'];\n            for (const key of requiredKeys) {\n                if (!(key in config)) throw new Error(`缺少必要欄位: ${key}`);\n            }\n            // Ensure ttNumLines and thNumLines exist for validation\n            if (!('ttNumLines' in config) || !('thNumLines' in config)) {\n                 throw new Error(`缺少必要欄位: ttNumLines or thNumLines`);\n            }\n            const totalLines = config.ttNumLines + config.thNumLines;\n            if (!Array.isArray(config.lineTypes) || config.lineTypes.length !== totalLines ||\n                !Array.isArray(config.randomDirections) || config.randomDirections.length !== totalLines ||\n                !Array.isArray(config.currentTargetLengths) || config.currentTargetLengths.length !== totalLines) {\n                throw new Error(\"線條數據數量與線條總數不符\");\n            }\n\n            // Update reactive refs\n            ttStartStrength.value = config.ttStartStrength;\n            ttEndStrength.value = config.ttEndStrength;\n            ttMinWorldLength.value = config.ttMinWorldLength;\n            ttMaxWorldLength.value = config.ttMaxWorldLength;\n            ttShrinkPower.value = config.ttShrinkPower;\n            ttNumLines.value = config.ttNumLines;\n            thStartStrength.value = config.thStartStrength;\n            thEndStrength.value = config.thEndStrength;\n            thMinWorldLength.value = config.thMinWorldLength;\n            thMaxWorldLength.value = config.thMaxWorldLength;\n            thShrinkPower.value = config.thShrinkPower;\n            thNumLines.value = config.thNumLines;\n            resolution.value = config.resolution;\n            currentMaterial.value = config.currentMaterial || 'shader';\n\n            // Update non-reactive Three.js state\n            if (effect) {\n                effect.material = materials[currentMaterial.value];\n                updateMarchingCubesParams(); // 調用此函數計算 isolation 並更新效果\n            }\n            if (camera && controls) {\n                 if (config.cameraPosition) {\n                    camera.position.set(config.cameraPosition.x, config.cameraPosition.y, config.cameraPosition.z);\n                }\n                if (config.cameraQuaternion) {\n                    // Ensure correct properties are used for Quaternion\n                    camera.quaternion.set(config.cameraQuaternion.x ?? config.cameraQuaternion._x,\n                                          config.cameraQuaternion.y ?? config.cameraQuaternion._y,\n                                          config.cameraQuaternion.z ?? config.cameraQuaternion._z,\n                                          config.cameraQuaternion.w ?? config.cameraQuaternion._w);\n                }\n                controls.update();\n            }\n\n\n            // Update line data arrays\n            const currentTime = clock?.getElapsedTime() ?? 0;\n            lineStartTimes.length = totalLines;\n            randomDirections.length = totalLines;\n            currentTargetLengths.length = totalLines;\n            lineTypes.length = totalLines;\n\n            for (let i = 0; i < totalLines; i++) {\n                lineTypes[i] = config.lineTypes[i];\n                currentTargetLengths[i] = config.currentTargetLengths[i];\n                if (config.randomDirections[i]) {\n                    randomDirections[i] = new THREE.Vector3(\n                        config.randomDirections[i].x,\n                        config.randomDirections[i].y,\n                        config.randomDirections[i].z\n                    );\n                } else {\n                    randomDirections[i] = null;\n                }\n                lineStartTimes[i] = currentTime; // Start growing immediately after import\n                lineFlowState[i] = 'growing'; // Reset flow state\n            }\n\n            effect?.reset();\n            console.log(\"設定已成功匯入。\");\n            alert(\"設定已載入！\");\n\n        } catch (e) {\n            console.error(\"匯入設定失敗:\", e);\n            alert(`匯入設定失敗！錯誤: ${e.message}`);\n        } finally {\n            if (importConfigFileRef.value) {\n                 importConfigFileRef.value.value = ''; // Reset file input\n            }\n        }\n    };\n    reader.onerror = function(e) {\n        console.error(\"讀取檔案錯誤:\", e);\n        alert(\"讀取檔案時發生錯誤。\");\n         if (importConfigFileRef.value) {\n             importConfigFileRef.value.value = ''; // Reset file input\n        }\n    };\n    reader.readAsText(file);\n}\n\nfunction exportGLB() {\n    if (!effect || !camera) return;\n    console.log(\"開始匯出 GLB (應用視角)...\");\n    const originalResolution = resolution.value;\n    const originalEffectQuaternion = effect.quaternion.clone();\n    const exporter = new GLTFExporter();\n\n    try {\n        // 直接使用原始解析度，無需臨時修改\n        console.log(`  - 使用目前解析度: ${originalResolution}`);\n        // Re-init with current resolution to ensure clean state\n        effect.init(originalResolution);\n\n        console.log(\"  - 重新計算模型...\");\n        updateLineMetaball(effect); // Force recalculation\n        console.log(\"  - 模型計算完成.\");\n\n        console.log(\"  - 應用反向攝影機旋轉...\");\n        const cameraInverseQuaternion = camera.quaternion.clone().invert();\n        effect.quaternion.premultiply(cameraInverseQuaternion);\n        effect.updateMatrixWorld(true); // Force update\n        console.log(\"  - 反向旋轉已應用.\");\n\n        exporter.parse(\n            effect,\n            (result) => { // Removed type annotation\n                if (result instanceof ArrayBuffer) {\n                    try {\n                        const blob = new Blob([result], { type: 'model/gltf-binary' });\n                        const url = URL.createObjectURL(blob);\n                        const a = document.createElement('a');\n                        a.href = url;\n                        a.download = `metaball_model_view_res${originalResolution}.glb`;\n                        document.body.appendChild(a);\n                        a.click();\n                        document.body.removeChild(a);\n                        URL.revokeObjectURL(url);\n                        console.log(`GLB 檔案已匯出: metaball_model_view_res${originalResolution}.glb`);\n                        alert(`模型 (含視角, res ${originalResolution}) GLB 已下載！`);\n                    } catch (e) {\n                        console.error(\"建立或下載 GLB Blob 時出錯:\", e);\n                        alert(\"下載 GLB 時發生錯誤！\");\n                    }\n                } else {\n                    console.error(\"匯出結果不是預期的 ArrayBuffer:\", result);\n                    alert(\"匯出 GLB 失敗：格式錯誤。請檢查控制台。\");\n                }\n                 // Restore original state (Success)\n                console.log(\"  - (成功) 恢復原始模型旋轉...\");\n                effect.quaternion.copy(originalEffectQuaternion);\n                effect.updateMatrixWorld(true);\n                // 已經使用原始解析度，無需恢復\n                console.log(\"  - 模型旋轉已恢復.\");\n            },\n            (error) => { // Removed type annotation\n                console.error('匯出 GLB 時發生錯誤:', error);\n                alert(\"匯出 GLB 時發生錯誤！請檢查控制台。\");\n                // Restore original state (Error)\n                console.log(\"  - (錯誤) 恢復原始模型旋轉...\");\n                effect.quaternion.copy(originalEffectQuaternion);\n                effect.updateMatrixWorld(true);\n                console.log(\"  - 模型旋轉已恢復.\");\n            },\n            { binary: true }\n        );\n    } catch (e) {\n         console.error(\"準備匯出或應用旋轉時出錯:\", e);\n         alert(\"準備匯出模型時發生錯誤！\");\n         // Restore original state (Catch)\n         console.log(\"  - (Catch) 恢復原始模型旋轉...\");\n         effect.quaternion.copy(originalEffectQuaternion);\n         effect.updateMatrixWorld(true);\n         console.log(\"  - 模型旋轉已恢復.\");\n    }\n}\n\nfunction toggleMaterial() {\n    if (!effect || !scene) return;\n    if (currentMaterial.value === 'shader') {\n        currentMaterial.value = 'liquid';\n        if (scene.background instanceof THREE.Color) {\n             scene.background.set(0x111111); // 暗色背景配合液體材質\n        }\n    } else {\n        currentMaterial.value = 'shader';\n         if (scene.background instanceof THREE.Color) {\n             scene.background.set(0xffffff); // 白色背景配合描邊材質\n        }\n    }\n    effect.material = materials[currentMaterial.value];\n    \n    console.log(`材質已切換為: ${currentMaterial.value}, 背景顏色已更新.`);\n}\n\nfunction toggleFlow() {\n    if (!clock || !effect || !camera || !controls) return;\n\n    if (isFlowing.value) {\n        // --- 停止流動 ---\n        isFlowing.value = false;\n        globalFlowState = 'idle';\n        shrinkStartTime = null;\n        shrinkEndTime = null;\n        growStartTime = null;\n        centerBallVisible = false;\n        \n        console.log(\"流動動畫已停止，正在恢復狀態...\");\n\n        if (savedLineState) {\n            ttNumLines.value = savedLineState.ttNumLines;\n            thNumLines.value = savedLineState.thNumLines;\n            lineTypes = [...savedLineState.lineTypes];\n            randomDirections = savedLineState.randomDirections.map((dir) => dir ? new THREE.Vector3(dir.x, dir.y, dir.z) : null);\n            currentTargetLengths = [...savedLineState.currentTargetLengths];\n            lineStartTimes = [...savedLineState.lineStartTimes];\n            lineFlowState = lineTypes.map(() => 'growing');\n\n            console.log(\"線條狀態已恢復\");\n            savedLineState = null;\n        } else {\n            console.warn(\"找不到保存的狀態來恢復。\")\n        }\n\n        if (savedCameraState) {\n            camera.position.copy(savedCameraState.position);\n            camera.quaternion.copy(savedCameraState.quaternion);\n            controls.update();\n            console.log(\"相機狀態已恢復\");\n            savedCameraState = null;\n        } else {\n            console.warn(\"找不到保存的相機狀態來恢復。\")\n        }\n\n        effect.reset();\n    } else {\n        // --- 開始流動 ---\n        console.log(\"開始流動動畫，正在保存當前狀態...\");\n        savedLineState = {\n            ttNumLines: ttNumLines.value,\n            thNumLines: thNumLines.value,\n            lineTypes: [...lineTypes],\n            randomDirections: randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null),\n            currentTargetLengths: [...currentTargetLengths],\n            lineStartTimes: [...lineStartTimes]\n        };\n        savedCameraState = {\n            position: camera.position.clone(),\n            quaternion: camera.quaternion.clone()\n        };\n        console.log(\"狀態已保存。\");\n\n        isFlowing.value = true;\n        \n        // 設置初始全局狀態\n        globalFlowState = 'growing';\n        growStartTime = clock.getElapsedTime();\n\n        const startTime = clock.getElapsedTime();\n        const totalLines = ttNumLines.value + thNumLines.value;\n        lineFlowState.length = totalLines;\n\n        // 所有線條同時開始生長\n        console.log(\"所有線條同時開始生長。\");\n        for (let i = 0; i < totalLines; i++) {\n            lineStartTimes[i] = startTime;\n            lineFlowState[i] = 'growing';\n        }\n\n        effect.reset();\n    }\n    effect.material = materials[currentMaterial.value];\n}\n\nfunction togglePixelation() {\n    if (!effect || !scene) return;\n    isPixelated.value = !isPixelated.value;\n    console.log(`像素化狀態已切換為: ${isPixelated.value}`);\n    \n    // 像素化切換不需要再額外處理，因為現在使用全局狀態控制\n}\n\n// --- Input Handlers with Validation ---\nfunction handleTtStartStrengthInput() {\n    if (ttStartStrength.value < ttEndStrength.value) {\n        ttEndStrength.value = ttStartStrength.value;\n    }\n}\nfunction handleTtEndStrengthInput() {\n    if (ttEndStrength.value > ttStartStrength.value) {\n        ttStartStrength.value = ttEndStrength.value;\n    }\n}\nfunction handleTtMinLengthInput() {\n    if (ttMinWorldLength.value > ttMaxWorldLength.value) {\n        ttMaxWorldLength.value = ttMinWorldLength.value;\n    }\n}\nfunction handleTtMaxLengthInput() {\n    if (ttMaxWorldLength.value < ttMinWorldLength.value) {\n        ttMinWorldLength.value = ttMaxWorldLength.value;\n    }\n}\nfunction handleThStartStrengthInput() {\n    if (thStartStrength.value > thEndStrength.value) {\n        thEndStrength.value = thStartStrength.value;\n    }\n}\nfunction handleThEndStrengthInput() {\n    if (thEndStrength.value < thStartStrength.value) {\n        thStartStrength.value = thEndStrength.value;\n    }\n}\nfunction handleThMinLengthInput() {\n    if (thMinWorldLength.value > thMaxWorldLength.value) {\n        thMaxWorldLength.value = thMinWorldLength.value;\n    }\n}\nfunction handleThMaxLengthInput() {\n    if (thMaxWorldLength.value < thMinWorldLength.value) {\n        thMinWorldLength.value = thMaxWorldLength.value;\n    }\n}\n\n// --- Watchers ---\nfunction updateMarchingCubesParams() {\n     if (effect) {\n        const derivedIsolation = resolution.value * 1.5;\n        effect.init(resolution.value); // Reinitialize when resolution changes\n        effect.isolation = derivedIsolation;\n        console.log(`Marching Cubes params updated: resolution=${resolution.value}, derivedIsolation=${derivedIsolation}`);\n    }\n}\n// Watch resolution to update MarchingCubes\nwatch(resolution, updateMarchingCubesParams);\n\n\n// --- Animation Loop ---\nfunction animate() {\n  animationFrameId = requestAnimationFrame(animate);\n\n  if (!effect || !materials || !camera || !renderer || !scene || !controls) return; // Guard\n\n  // Update scene logic (always happens)\n  updateLineMetaball(effect);\n  controls.update();\n  \n  // 不再需要更新獨立的中心球體\n  // updateCenterSphere();\n\n  // Update shader material uniforms if active\n  if (currentMaterial.value === 'shader' && !isPixelated.value) { // Only update if shader is active AND not pixelated (composer handles time otherwise? Check docs)\n      const currentTime = clock.getElapsedTime();\n      materials.shader.uniforms.uTime.value = currentTime;\n      materials.shader.uniforms.viewVector.value = camera.position;\n  }\n\n  // Conditional rendering: composer or direct renderer\n  if (isPixelated.value && composer) {\n      composer.render();\n  } else {\n      renderer.render(scene, camera);\n  }\n}\n\n// --- Resize Handler ---\nfunction handleResize() {\n    if (!camera || !renderer || !materials) return;\n    const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n    const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n\n    // Update composer and passes size\n    if (composer) {\n        composer.setSize(width, height);\n    }\n    // Note: RenderPixelatedPass usually adapts automatically, but check if specific update needed\n\n    if (materials.shader) {\n        materials.shader.uniforms.uResolution.value.set(width, height);\n    }\n    // Consider if FXAA pass needs resize (if used)\n}\n\n// --- Lifecycle Hooks ---\nonMounted(() => {\n  if (!canvasContainer.value) {\n    console.error(\"Canvas container not found!\");\n    return;\n  }\n  const container = canvasContainer.value;\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n\n  // Scene\n  scene = new THREE.Scene();\n  scene.background = new THREE.Color(0xffffff); // Initial background color\n\n  // Camera\n  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  camera.position.set(0, 0, 30);\n  camera.lookAt(scene.position);\n\n  // Renderer\n  renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n  container.appendChild(renderer.domElement);\n\n  // Controls\n  controls = new OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n\n  // Lights\n  scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n  dirLight.position.set(5, 10, 7.5);\n  scene.add(dirLight);\n\n  // PMREMGenerator\n  pmremGenerator = new THREE.PMREMGenerator(renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  // Materials\n  materials = generateMaterials(); // Generate materials after camera is defined\n\n  // Marching Cubes\n  const derivedIsolation = resolution.value * 1.5;\n  effect = new MarchingCubes(resolution.value, materials[currentMaterial.value], true, true, 100000);\n  effect.isolation = derivedIsolation;\n  effect.scale.set(8, 8, 8);\n  effect.enableUvs = false;\n  effect.enableColors = false;\n  scene.add(effect);\n\n  // --- Post-processing Setup ---\n  composer = new EffectComposer(renderer);\n  // RenderPixelatedPass automatically adds a RenderPass internally\n  pixelPass = new RenderPixelatedPass(10, scene, camera);\n  composer.addPass(pixelPass);\n  // OutputPass ensures correct colorspace and encoding\n  const outputPass = new OutputPass();\n  composer.addPass(outputPass);\n  // --- End Post-processing Setup ---\n\n  // Clock\n  clock = new THREE.Clock();\n\n  // Load Env Map\n  loadEnvironmentMap();\n\n  // Initial line generation\n  regenerateLine();\n\n  // Start animation\n  animate();\n\n  // Add resize listener\n  window.addEventListener('resize', handleResize);\n});\n\nonUnmounted(() => {\n  // Stop animation\n  cancelAnimationFrame(animationFrameId);\n\n  // Remove resize listener\n  window.removeEventListener('resize', handleResize);\n\n  // Dispose Three.js objects\n  if (controls) controls.dispose();\n  if (renderer) renderer.dispose();\n  if (materials) {\n      materials.shader?.dispose();\n      materials.liquid?.dispose();\n      // Dispose envMap if loaded\n      if (scene?.environment) scene.environment.dispose();\n  }\n  \n  // 不再需要清理獨立球體資源\n  \n  if (effect) {\n      // MarchingCubes doesn't have a direct dispose method, rely on scene cleanup\n      scene?.remove(effect);\n      // Dispose geometry/material if needed, but MarchingCubes manages internal geometry\n  }\n   if (scene) {\n        // Dispose geometries, materials, textures in the scene\n        scene.traverse((object) => {\n            if (object instanceof THREE.Mesh) {\n                object.geometry?.dispose();\n                // Check if material is an array or single\n                const material = object.material;\n                if (Array.isArray(material)) {\n                    material.forEach((mat) => mat.dispose());\n                } else if (material) {\n                    material.dispose();\n                }\n            }\n        });\n    }\n    if(pmremGenerator) pmremGenerator.dispose(); // Dispose PMREMGenerator\n    // Dispose composer and passes (composer itself doesn't have dispose, relies on GC? Check docs - better dispose passes)\n    if (pixelPass) {\n        // Passes usually don't have a specific dispose method, rely on GC\n    }\n    // composer = null; // Help GC\n    // pixelPass = null;\n\n  // Remove canvas\n  if (canvasContainer.value && renderer) {\n    canvasContainer.value.removeChild(renderer.domElement);\n  }\n\n  console.log(\"Three.js scene cleaned up.\");\n});\n\n// --- 全局流動狀態管理 ---\nfunction updateGlobalFlowState(currentTime) {\n    if (!isFlowing.value || !clock) return;\n    \n    // 檢查當前時間和設定的時間節點\n    if (globalFlowState === 'growing' && growStartTime !== null) {\n        // 計算所有線條的平均生長完成度\n        const totalLines = ttNumLines.value + thNumLines.value;\n        let totalGrowthProgress = 0;\n        let activeLines = 0;\n        \n        for (let i = 0; i < totalLines; i++) {\n            if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n            \n            activeLines++;\n            const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n            const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n            const currentGrowthSpeed = growthSpeed * FLOW_GROWTH_SPEED_FACTOR;\n            const linearDuration = localMaxLength / (currentGrowthSpeed / (effect?.scale.x || 1));\n            const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n            \n            totalGrowthProgress += growthProgress;\n        }\n        \n        const averageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n        \n        // 當平均生長進度達到99%以上，切換到暫停狀態\n        if (averageProgress >= 0.99) {\n            globalFlowState = 'pauseAtEnd';\n            console.log(\"所有線條已生長完成，進入暫停狀態\");\n            \n            // 延遲一段時間後開始收合\n            setTimeout(() => {\n                if (isFlowing.value) {\n                    startSyncShrinking();\n                }\n            }, 1000); // 暫停1秒後開始收合\n        }\n    } else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n        // 檢查是否達到收合結束時間\n        if (currentTime >= shrinkEndTime) {\n            globalFlowState = 'pauseAtStart';\n            console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n            \n            // 延遲一段時間後開始新的生長週期\n            setTimeout(() => {\n                if (isFlowing.value) {\n                    startSyncGrowing();\n                }\n            }, 1000); // 暫停1秒後開始生長\n        }\n    }\n}\n\n// 開始同步收合\nfunction startSyncShrinking() {\n    if (!clock) return;\n    const currentTime = clock.getElapsedTime();\n    \n    console.log(\"所有線條同步收合\");\n    \n    // 更新全局狀態\n    globalFlowState = 'shrinking';\n    \n    // 設置收合時間\n    shrinkStartTime = currentTime;\n    shrinkEndTime = currentTime + BASE_SHRINK_DURATION * FLOW_SHRINK_DURATION_FACTOR;\n    \n    // 顯示中心metaball球體\n    centerBallVisible = true;\n}\n\n// 開始同步生長\nfunction startSyncGrowing() {\n    if (!clock) return;\n    const currentTime = clock.getElapsedTime();\n    const totalLines = ttNumLines.value + thNumLines.value;\n    \n    console.log(\"所有線條同步生長\");\n    \n    // 更新全局狀態\n    globalFlowState = 'growing';\n    growStartTime = currentTime;\n    \n    // 隱藏中心球體\n    centerBallVisible = false;\n    \n    // 重置所有線條的方向和長度\n    for (let i = 0; i < totalLines; i++) {\n        if (lineStartTimes[i] === undefined) continue;\n        \n        // 重新生成隨機方向\n        if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n        randomDirections[i]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n        \n        // 更新線條類型和長度\n        lineTypes[i] = (i < ttNumLines.value) ? 'tt' : 'th';\n        const minL = (lineTypes[i] === 'tt') ? ttMinWorldLength.value : thMinWorldLength.value;\n        const maxL = (lineTypes[i] === 'tt') ? ttMaxWorldLength.value : thMaxWorldLength.value;\n        currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n        \n        // 更新線條狀態\n        lineStartTimes[i] = currentTime;\n    }\n}\n\n// 計算中心球體的強度\nfunction calculateCenterBallStrength(currentTime) {\n    if (!clock || shrinkStartTime === null || shrinkEndTime === null) return 0;\n    \n    if (currentTime === undefined) {\n        currentTime = clock.getElapsedTime();\n    }\n    \n    if (globalFlowState === 'shrinking') {\n        // 在收合階段，球體強度隨收合進度增加\n        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n        const timeSinceShrinking = currentTime - shrinkStartTime;\n        const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n        return minCenterBallStrength + shrinkProgress * (maxCenterBallStrength - minCenterBallStrength);\n    } else if (globalFlowState === 'pauseAtStart') {\n        // 在收合完成階段，球體保持最大強度\n        return maxCenterBallStrength;\n    } else {\n        // 其他狀態下球體強度最小\n        return minCenterBallStrength;\n    }\n}\n\n</script>"],"version":3}