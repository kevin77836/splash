{"version":3,"file":"generate-2.vue.mjs","sources":["../../../../pages/generate-2.vue"],"sourcesContent":["<template>\n  <div class=\"splash-container\">\n    <div ref=\"canvasContainer\" class=\"splash-canvas\"></div>\n    <button \n      ref=\"controlButton\" \n      class=\"control-button\" \n      :disabled=\"isLoading\" \n      @click=\"toggleAnimation\">\n      {{ buttonText }}\n    </button>\n  </div>\n</template>\n\n<script setup>\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// --- 狀態管理 ---\nconst isLoading = ref(true);\nconst buttonText = ref('Play');\nconst animationState = ref('stopped'); // 'stopped', 'playing', 'returning'\n\n// --- 配置參數 ---\nconst CONFIG = {\n  scene: {\n    scale: 8,              // 模型縮放比例\n    pixelRatio: 1.5        // 渲染像素比例\n  },\n  metaball: {\n    resolution: 200,       // Marching Cubes 解析度\n    segments: 50,          // 線條分段數量\n    subtract: 20,          // Metaball 減法參數\n    maxBalls: 100000       // 最大球體數量\n  },\n  material: {\n    color: 0xffffff,       // 材質顏色\n    metalness: 0,        // 金屬感\n    roughness: 0,          // 粗糙度\n    opacity: 0.75,          // 透明度\n    transmission: 1,\n    ior: 1.33,\n    thickness: 1.0,\n    envMapIntensity: 300.0,\n  },\n  lines: {\n    // 由粗到細線條\n    thickToThin: {\n      startStrength: 0.1,  // 起始端粗度\n      endStrength: 0.01,   // 末端粗度\n      minLength: 2.5,      // 最小長度\n      maxLength: 3.5,      // 最大長度\n      shrinkPower: 0.25,   // 收縮速率指數\n      count: 4             // 線條數量\n    },\n    // 由細到粗線條\n    thinToThick: {\n      startStrength: 0.01, // 起始端粗度\n      endStrength: 0.1,    // 末端粗度\n      minLength: 2,        // 最小長度\n      maxLength: 3,        // 最大長度\n      shrinkPower: 1.25,   // 膨脹速率指數\n      count: 3             // 線條數量\n    }\n  },\n  controls: {\n    autoRotate: true,      // 自動旋轉\n    rotateSpeed: 2.0,      // 旋轉速度\n    enableDamping: true    // 啟用阻尼效果\n  },\n  animation: {\n    enabled: true,         // 是否啟用動畫\n    growthSpeed: 5.0,      // 生長速度\n    growthEaseOutPower: 50, // 緩動指數\n    autoPlay: false        // 是否自動播放\n  }\n};\n\n// --- Refs ---\nconst canvasContainer = ref(null);\nconst controlButton = ref(null);\n\n// --- 資源管理 ---\nconst resources = {\n  scene: null,\n  camera: null,\n  renderer: null,\n  controls: null,\n  effect: null,\n  material: null,\n  pmremGenerator: null,\n  animationId: null,\n  clock: null,\n  \n  // 線條數據\n  lines: {\n    directions: [],    // 方向向量\n    lengths: [],       // 長度\n    types: [],         // 類型\n    startTimes: [],    // 動畫開始時間\n    targetProgress: [], // 目標進度 (0-1)\n    currentProgress: [] // 當前進度 (0-1)\n  },\n  \n  // 清理所有資源\n  dispose() {\n    cancelAnimationFrame(this.animationId);\n    \n    if (this.controls) this.controls.dispose();\n    if (this.renderer) this.renderer.dispose();\n    \n    if (this.material) {\n      this.material.dispose();\n      if (this.scene?.environment) this.scene.environment.dispose();\n    }\n    \n    if (this.effect) this.scene?.remove(this.effect);\n    \n    if (this.scene) {\n      this.scene.traverse((object) => {\n        if (object instanceof THREE.Mesh) {\n          object.geometry?.dispose();\n          \n          if (Array.isArray(object.material)) {\n            object.material.forEach(mat => mat.dispose());\n          } else if (object.material) {\n            object.material.dispose();\n          }\n        }\n      });\n    }\n    \n    if (this.pmremGenerator) this.pmremGenerator.dispose();\n    \n    if (canvasContainer.value && this.renderer) {\n      canvasContainer.value.removeChild(this.renderer.domElement);\n    }\n  }\n};\n\n// --- 動畫控制函數 ---\nfunction toggleAnimation() {\n  if (animationState.value === 'stopped' || animationState.value === 'returning') {\n    // 切換到播放狀態\n    animationState.value = 'playing';\n    buttonText.value = 'Return';\n    \n    // 設置所有線條的目標進度為 1 (完全延伸)\n    setAllLinesTargetProgress(1);\n  } else {\n    // 切換到返回狀態\n    animationState.value = 'returning';\n    buttonText.value = 'Play';\n    \n    // 設置所有線條的目標進度為 0 (完全收回)\n    setAllLinesTargetProgress(0);\n  }\n  \n  // 記錄每條線的當前進度作為動畫起點\n  captureCurrentProgress();\n  \n  // 重置動畫開始時間\n  resetAnimationStartTimes();\n}\n\n// --- 設置所有線條的目標進度 ---\nfunction setAllLinesTargetProgress(targetValue) {\n  const { targetProgress } = resources.lines;\n  const totalLines = targetProgress.length;\n  \n  for (let i = 0; i < totalLines; i++) {\n    targetProgress[i] = targetValue;\n  }\n}\n\n// --- 捕獲所有線條的當前進度 ---\nfunction captureCurrentProgress() {\n  if (!resources.clock) return;\n  \n  const { currentProgress } = resources.lines;\n  const totalLines = currentProgress.length;\n  \n  // 確保我們保存的是當前的實際進度值\n  for (let i = 0; i < totalLines; i++) {\n    // 已經設置，不需要更改\n  }\n}\n\n// --- 重置動畫開始時間 ---\nfunction resetAnimationStartTimes() {\n  if (!resources.clock) return;\n  \n  const currentTime = resources.clock.getElapsedTime();\n  const { startTimes } = resources.lines;\n  const totalLines = startTimes.length;\n  \n  for (let i = 0; i < totalLines; i++) {\n    startTimes[i] = currentTime;\n  }\n}\n\n// --- 創建液體材質 ---\nfunction createMaterial() {\n  return new THREE.MeshPhysicalMaterial({\n    color: CONFIG.material.color,\n    metalness: CONFIG.material.metalness,\n    roughness: CONFIG.material.roughness,\n    transparent: true,\n    opacity: CONFIG.material.opacity,\n    side: THREE.DoubleSide,\n    transmission: CONFIG.material.transmission,\n    ior: CONFIG.material.ior,\n    thickness: CONFIG.material.thickness,\n    envMapIntensity: CONFIG.material.envMapIntensity,\n  });\n}\n\n// --- 載入環境貼圖 ---\nfunction loadEnvironmentMap() {\n  return new Promise((resolve, reject) => {\n    new EXRLoader()\n      .setPath('/hdr/')\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', \n        (texture) => {\n          texture.mapping = THREE.EquirectangularReflectionMapping;\n          \n          const envMap = resources.pmremGenerator.fromEquirectangular(texture).texture;\n          resources.pmremGenerator.dispose();\n          texture.dispose();\n  \n          resources.scene.environment = envMap;\n          if (resources.material) {\n            resources.material.envMap = envMap;\n            resources.material.needsUpdate = true;\n          }\n          \n          resolve(envMap);\n        },\n        undefined,\n        (error) => {\n          console.error('無法載入環境貼圖:', error);\n          reject(error);\n        }\n      );\n  });\n}\n\n// --- 生成線條 ---\nfunction generateLines() {\n  const { thickToThin, thinToThick } = CONFIG.lines;\n  const totalLines = thickToThin.count + thinToThick.count;\n  const currentTime = resources.clock.getElapsedTime();\n  \n  // 初始化數組\n  resources.lines.directions = new Array(totalLines);\n  resources.lines.lengths = new Array(totalLines);\n  resources.lines.types = new Array(totalLines);\n  resources.lines.startTimes = new Array(totalLines).fill(currentTime);\n  resources.lines.targetProgress = new Array(totalLines).fill(CONFIG.animation.autoPlay ? 1 : 0);\n  resources.lines.currentProgress = new Array(totalLines).fill(0);\n  \n  let lineIndex = 0;\n  \n  // 生成線條函數\n  const createLine = (params, type) => {\n    const direction = new THREE.Vector3(\n      Math.random() * 2 - 1, \n      Math.random() * 2 - 1, \n      Math.random() * 2 - 1\n    ).normalize();\n    \n    const length = THREE.MathUtils.randFloat(\n      params.minLength,\n      params.maxLength\n    );\n    \n    resources.lines.directions[lineIndex] = direction;\n    resources.lines.lengths[lineIndex] = length;\n    resources.lines.types[lineIndex] = type;\n    lineIndex++;\n  };\n  \n  // 生成由粗到細線條\n  for (let i = 0; i < thickToThin.count; i++) {\n    createLine(thickToThin, 'tt');\n  }\n  \n  // 生成由細到粗線條\n  for (let i = 0; i < thinToThick.count; i++) {\n    createLine(thinToThick, 'th');\n  }\n  \n  // 如果效果已初始化，立即更新\n  if (resources.effect) {\n    updateMetaball();\n  }\n  \n  // 初始設置動畫狀態\n  if (CONFIG.animation.autoPlay) {\n    animationState.value = 'playing';\n    buttonText.value = 'Return';\n  } else {\n    animationState.value = 'stopped';\n    buttonText.value = 'Play';\n  }\n}\n\n// --- 更新線條動畫進度 ---\nfunction updateLineAnimation() {\n  if (!CONFIG.animation.enabled || !resources.clock) return false;\n  \n  // 如果不在任何動畫中，跳過更新\n  if (animationState.value === 'stopped') return false;\n  \n  const currentTime = resources.clock.getElapsedTime();\n  let anyProgressChanged = false;\n  \n  const { startTimes, lengths, targetProgress, currentProgress } = resources.lines;\n  const totalLines = startTimes.length;\n  \n  for (let i = 0; i < totalLines; i++) {\n    // 計算線條應該移動的方向\n    const isGrowing = targetProgress[i] > currentProgress[i];\n    const isShrinking = targetProgress[i] < currentProgress[i];\n    \n    // 如果已經達到目標進度，跳過\n    if ((!isGrowing && !isShrinking) || \n        (isGrowing && currentProgress[i] >= targetProgress[i]) || \n        (isShrinking && currentProgress[i] <= targetProgress[i])) {\n      continue;\n    }\n    \n    // 計算時間進度\n    const timeSinceStart = currentTime - startTimes[i];\n    const localMaxLength = lengths[i];\n    \n    if (localMaxLength > 0.001) {\n      // 計算單位時間內的進度變化\n      const growthSpeed = CONFIG.animation.growthSpeed;\n      const progressPerSecond = growthSpeed / localMaxLength;\n      const progressDelta = progressPerSecond * timeSinceStart;\n      \n      // 保存舊進度以檢測變化\n      const oldProgress = currentProgress[i];\n      \n      if (isGrowing) {\n        // 向目標進度漸進\n        currentProgress[i] = Math.min(\n          currentProgress[i] + progressDelta, \n          targetProgress[i]\n        );\n      } else if (isShrinking) {\n        // 向目標進度漸退\n        currentProgress[i] = Math.max(\n          currentProgress[i] - progressDelta, \n          targetProgress[i]\n        );\n      }\n      \n      // 應用緩動效果（可選）\n      // currentProgress[i] = applyEasing(currentProgress[i]);\n      \n      // 檢測是否有顯著變化\n      if (Math.abs(currentProgress[i] - oldProgress) > 0.001) {\n        anyProgressChanged = true;\n        \n        // 重置起始時間以保持連續動畫\n        startTimes[i] = currentTime;\n      }\n    }\n  }\n  \n  // 檢查所有線條是否都達到目標，決定是否改變動畫狀態\n  checkAnimationCompletion();\n  \n  return anyProgressChanged;\n}\n\n// --- 檢查動畫是否完成 ---\nfunction checkAnimationCompletion() {\n  const { targetProgress, currentProgress } = resources.lines;\n  const totalLines = currentProgress.length;\n  \n  // 檢查所有線條是否都達到目標\n  let allReachedTarget = true;\n  \n  for (let i = 0; i < totalLines; i++) {\n    // 檢查每條線的進度是否接近目標進度\n    if (Math.abs(currentProgress[i] - targetProgress[i]) > 0.01) {\n      allReachedTarget = false;\n      break;\n    }\n  }\n  \n  // 如果所有線條都達到目標\n  if (allReachedTarget) {\n    // 如果是返回動畫完成，轉為停止狀態\n    if (animationState.value === 'returning') {\n      animationState.value = 'stopped';\n    }\n  }\n}\n\n// --- 應用緩動效果（可根據需要調整） ---\nfunction applyEasing(value) {\n  // 二次方緩動效果\n  return Math.pow(value, CONFIG.animation.growthEaseOutPower);\n}\n\n// --- 更新 Metaball 效果 ---\nfunction updateMetaball() {\n  const effect = resources.effect;\n  if (!effect) return;\n  \n  effect.reset();\n  \n  const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n  const { directions, lengths, types, currentProgress } = resources.lines;\n  const totalLines = types.length;\n  \n  for (let i = 0; i < totalLines; i++) {\n    if (!lengths[i]) continue;\n    \n    // 計算當前線條長度 (基於動畫進度)\n    const localMaxLength = lengths[i] / effect.scale.x;\n    const currentLength = localMaxLength * currentProgress[i];\n    \n    // 如果線條還沒有開始延伸，跳過\n    if (currentLength <= 0.001) continue;\n    \n    const direction = directions[i];\n    const type = types[i];\n    \n    if (!direction || !type) continue;\n    \n    // 根據線條類型選擇參數\n    const lineParams = type === 'tt' \n      ? CONFIG.lines.thickToThin \n      : CONFIG.lines.thinToThick;\n    \n    // 計算 metaball 點\n    for (let j = 0; j <= CONFIG.metaball.segments; j++) {\n      const t = j / CONFIG.metaball.segments;\n      \n      // 如果超出當前延伸長度，跳過\n      if (t * localMaxLength > currentLength) continue;\n      \n      // 調整 t 值以適應當前長度\n      const adjustedT = currentLength > 0 ? (t * localMaxLength) / currentLength : 0;\n      \n      const strengthFactor = Math.pow(adjustedT, lineParams.shrinkPower);\n      const strength = THREE.MathUtils.lerp(\n        lineParams.startStrength,\n        lineParams.endStrength,\n        strengthFactor\n      );\n      \n      // 計算位置\n      const pos = direction.clone()\n        .multiplyScalar(currentLength * adjustedT)\n        .add(centerOffset);\n      \n      // 添加 metaball 點\n      effect.addBall(\n        pos.x, \n        pos.y, \n        pos.z, \n        strength, \n        CONFIG.metaball.subtract\n      );\n    }\n  }\n  \n  effect.update();\n}\n\n// --- 處理視窗大小變化 ---\nfunction handleResize() {\n  if (!resources.camera || !resources.renderer) return;\n  \n  const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n  const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n  \n  resources.camera.aspect = width / height;\n  resources.camera.updateProjectionMatrix();\n  resources.renderer.setSize(width, height);\n}\n\n// --- 初始化場景 ---\nfunction initScene() {\n  if (!canvasContainer.value) {\n    console.error(\"找不到畫布容器!\");\n    return false;\n  }\n  \n  const container = canvasContainer.value;\n  const width = container.clientWidth || window.innerWidth;\n  const height = container.clientHeight || window.innerHeight;\n  \n  // 創建時鐘\n  resources.clock = new THREE.Clock();\n  \n  // 場景\n  resources.scene = new THREE.Scene();\n  resources.scene.background = null; // 透明背景\n  \n  // 相機\n  resources.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  resources.camera.position.set(0, 0, 30);\n  resources.camera.lookAt(0, 0, 0);\n  \n  // 渲染器 (添加透明支援)\n  resources.renderer = new THREE.WebGLRenderer({ \n    antialias: true,\n    alpha: true \n  });\n  resources.renderer.setSize(width, height);\n  resources.renderer.setPixelRatio(\n    Math.min(window.devicePixelRatio, CONFIG.scene.pixelRatio)\n  );\n  container.appendChild(resources.renderer.domElement);\n  \n  // 控制器\n  resources.controls = new OrbitControls(resources.camera, resources.renderer.domElement);\n  resources.controls.enableDamping = CONFIG.controls.enableDamping;\n  resources.controls.autoRotate = CONFIG.controls.autoRotate;\n  resources.controls.autoRotateSpeed = CONFIG.controls.rotateSpeed;\n  \n  // 環境貼圖處理器\n  resources.pmremGenerator = new THREE.PMREMGenerator(resources.renderer);\n  resources.pmremGenerator.compileEquirectangularShader();\n  \n  // 液體材質\n  resources.material = createMaterial();\n  \n  // Marching Cubes 效果\n  const isolation = CONFIG.metaball.resolution * 1.5;\n  resources.effect = new MarchingCubes(\n    CONFIG.metaball.resolution,\n    resources.material,\n    true, \n    true,\n    CONFIG.metaball.maxBalls\n  );\n  \n  resources.effect.isolation = isolation;\n  resources.effect.scale.set(\n    CONFIG.scene.scale, \n    CONFIG.scene.scale, \n    CONFIG.scene.scale\n  );\n  resources.effect.enableUvs = false;\n  resources.effect.enableColors = false;\n  resources.scene.add(resources.effect);\n  \n  return true;\n}\n\n// --- 渲染場景 ---\nfunction render() {\n  const { camera, renderer, scene, controls, effect } = resources;\n  if (!effect || !camera || !renderer || !scene || !controls) return;\n  \n  // 更新控制器\n  controls.update();\n  \n  // 更新線條動畫\n  const animationUpdated = updateLineAnimation();\n  \n  // 如果線條動畫有更新，則更新 metaball\n  if (animationUpdated) {\n    updateMetaball();\n  }\n  \n  renderer.render(scene, camera);\n  \n  resources.animationId = requestAnimationFrame(render);\n}\n\n// --- 生命週期掛鉤 ---\nonMounted(async () => {\n  if (!initScene()) return;\n  \n  try {\n    isLoading.value = true;\n    \n    // 載入環境貼圖\n    await loadEnvironmentMap();\n    \n    // 生成線條\n    generateLines();\n    \n    // 開始渲染\n    render();\n    \n    // 監聽視窗大小變化\n    window.addEventListener('resize', handleResize);\n    \n    // 載入完成，啟用按鈕\n    isLoading.value = false;\n  } catch (error) {\n    console.error(\"初始化失敗:\", error);\n    isLoading.value = false;\n  }\n});\n\nonUnmounted(() => {\n  resources.dispose();\n  window.removeEventListener('resize', handleResize);\n});\n</script>"],"names":[],"mappings":";;;;;;AAoBM,UAAA,YAAY,IAAI,IAAI;AACpB,UAAA,aAAa,IAAI,MAAM;AACN,QAAI,SAAS;AA0DZ,QAAI,IAAI;AACV,QAAI,IAAI;;;;;;;;;;;;"}