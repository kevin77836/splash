{"file":"generate.vue.mjs","mappings":";;;;;;AAkH0B,QAAI,IAAI;AACJ,QAAI,IAAI;AAK9B,UAAA,kBAAkB,IAAI,GAAG;AACzB,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,mBAAmB,IAAI,GAAG;AAC1B,UAAA,mBAAmB,IAAI,GAAG;AAC1B,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,aAAa,IAAI,CAAC;AAGlB,UAAA,kBAAkB,IAAI,IAAI;AAC1B,UAAA,gBAAgB,IAAI,GAAG;AACvB,UAAA,mBAAmB,IAAI,CAAC;AACxB,UAAA,mBAAmB,IAAI,CAAC;AACxB,UAAA,gBAAgB,IAAI,IAAI;AACxB,UAAA,aAAa,IAAI,CAAC;AAGlB,UAAA,aAAa,IAAI,GAAG;AACpB,UAAA,kBAAkB,IAAI,QAAQ;AAC9B,UAAA,cAAc,IAAI,KAAK;AACvB,UAAA,iBAAiB,IAAI,KAAK;AAkjBhC,aAAS,4BAA4B;AAAA,IAMjC;AAGJ,UAAM,YAAY,yBAAyB;;;;;;;;;;;;","names":[],"sources":["../../../../pages/generate.vue"],"sourcesContent":["<template>\n    <div class=\"splash-container\">\n      <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n  \n      <!-- 控制面板 HTML - 由粗到細 -->\n      <div id=\"thickToThinPanel\" class=\"control-panel thick-to-thin-panel\">\n        <div class=\"panel-title\">由粗到細 線條控制</div>\n        <div class=\"control-group\">\n          <label class=\"control-label\">最粗粗度 (強度): <span class=\"value-display\">{{ ttStartStrength.toFixed(2) }}</span></label>\n          <input type=\"range\" v-model.number=\"ttStartStrength\" min=\"0\" max=\"0.1\" step=\"0.01\" @input=\"handleTtStartStrengthInput\">\n        </div>\n        <div class=\"control-group\">\n          <label class=\"control-label\">最細粗度 (強度): <span class=\"value-display\">{{ ttEndStrength.toFixed(2) }}</span></label>\n          <input type=\"range\" v-model.number=\"ttEndStrength\" min=\"0.0\" max=\"0.1\" step=\"0.01\" @input=\"handleTtEndStrengthInput\">\n        </div>\n        <div class=\"control-group\">\n          <label class=\"control-label\">最短長度: <span class=\"value-display\">{{ ttMinWorldLength.toFixed(1) }}</span></label>\n          <input type=\"range\" v-model.number=\"ttMinWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleTtMinLengthInput\">\n        </div>\n        <div class=\"control-group\">\n          <label class=\"control-label\">最長長度: <span class=\"value-display\">{{ ttMaxWorldLength.toFixed(1) }}</span></label>\n          <input type=\"range\" v-model.number=\"ttMaxWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleTtMaxLengthInput\">\n        </div>\n        <div class=\"control-group\">\n          <label class=\"control-label\">收縮速率 (冪): <span class=\"value-display\">{{ ttShrinkPower.toFixed(2) }}</span></label>\n          <input type=\"range\" v-model.number=\"ttShrinkPower\" min=\"0.1\" max=\"5.0\" step=\"0.05\">\n        </div>\n        <div class=\"control-group\">\n          <label class=\"control-label\">線條數量: <span class=\"value-display\">{{ ttNumLines }}</span></label>\n          <input type=\"range\" v-model.number=\"ttNumLines\" min=\"0\" max=\"10\" step=\"1\" @input=\"regenerateLine\">\n        </div>\n      </div>\n  \n      <!-- 控制面板 HTML - 由細到粗 -->\n      <div id=\"thinToThickPanel\" class=\"control-panel thin-to-thick-panel\">\n          <div class=\"panel-title\">由細到粗 線條控制</div>\n          <div class=\"control-group\">\n              <label class=\"control-label\">最細粗度 (強度): <span class=\"value-display\">{{ thStartStrength.toFixed(2) }}</span></label>\n              <input type=\"range\" v-model.number=\"thStartStrength\" min=\"0.0\" max=\"0.1\" step=\"0.01\" @input=\"handleThStartStrengthInput\">\n          </div>\n          <div class=\"control-group\">\n              <label class=\"control-label\">最粗粗度 (強度): <span class=\"value-display\">{{ thEndStrength.toFixed(2) }}</span></label>\n              <input type=\"range\" v-model.number=\"thEndStrength\" min=\"0\" max=\"0.1\" step=\"0.01\" @input=\"handleThEndStrengthInput\">\n          </div>\n          <div class=\"control-group\">\n              <label class=\"control-label\">最短長度: <span class=\"value-display\">{{ thMinWorldLength.toFixed(1) }}</span></label>\n              <input type=\"range\" v-model.number=\"thMinWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleThMinLengthInput\">\n          </div>\n          <div class=\"control-group\">\n              <label class=\"control-label\">最長長度: <span class=\"value-display\">{{ thMaxWorldLength.toFixed(1) }}</span></label>\n              <input type=\"range\" v-model.number=\"thMaxWorldLength\" min=\"0.5\" max=\"5.0\" step=\"0.1\" @input=\"handleThMaxLengthInput\">\n          </div>\n          <div class=\"control-group\">\n              <label class=\"control-label\">膨脹速率 (冪): <span class=\"value-display\">{{ thShrinkPower.toFixed(2) }}</span></label>\n              <input type=\"range\" v-model.number=\"thShrinkPower\" min=\"0.1\" max=\"5.0\" step=\"0.05\">\n          </div>\n          <div class=\"control-group\">\n              <label class=\"control-label\">線條數量: <span class=\"value-display\">{{ thNumLines }}</span></label>\n              <input type=\"range\" v-model.number=\"thNumLines\" min=\"0\" max=\"10\" step=\"1\" @input=\"regenerateLine\">\n          </div>\n      </div>\n  \n      <!-- 通用控制面板 HTML -->\n      <div id=\"commonPanel\" class=\"control-panel common-panel\">\n          <div class=\"panel-title\">通用控制</div>\n          <button @click=\"regenerateLine\">重新生成所有線條</button>\n          <button @click=\"exportConfiguration\" style=\"margin-top: 5px;\">匯出設定 (JSON)</button>\n          <button @click=\"triggerImport\" style=\"margin-top: 5px;\">匯入設定 (JSON)</button>\n          <input type=\"file\" ref=\"importConfigFileRef\" @change=\"importConfiguration\" accept=\".json\" style=\"display: none;\">\n          <button @click=\"exportGLB\" style=\"margin-top: 5px;\">下載目前模型 (GLB)</button>\n      </div>\n  \n      <!-- 新增左下角 Switch 控制面板 -->\n      <div id=\"switchPanel\" class=\"control-panel switch-panel\">\n          <div class=\"panel-title\">快速切換</div>\n          \n          <div class=\"switch-control-group\">\n              <label class=\"switch-label\">{{ currentMaterial === 'shader' ? '描邊材質' : '液體材質' }}</label>\n              <label class=\"switch\">\n                  <input type=\"checkbox\" :checked=\"currentMaterial === 'liquid'\" @change=\"toggleMaterial\">\n                  <span class=\"slider round\"></span>\n              </label>\n          </div>\n  \n          <div class=\"switch-control-group\">\n              <label class=\"switch-label\">{{ isPixelated ? '像素化' : '正常' }}</label>\n              <label class=\"switch\">\n                  <input type=\"checkbox\" :checked=\"isPixelated\" @change=\"togglePixelation\">\n                  <span class=\"slider round\"></span>\n              </label>\n          </div>\n          \n          <div class=\"switch-control-group\">\n              <label class=\"switch-label\">{{ isAutoRotating ? '自動旋轉中' : '靜止' }}</label>\n              <label class=\"switch\">\n                  <input type=\"checkbox\" :checked=\"isAutoRotating\" @change=\"toggleAutoRotate\">\n                  <span class=\"slider round\"></span>\n              </label>\n          </div>\n      </div>\n    </div>\n  </template>\n  \n  <script setup>\n  import * as THREE from 'three';\n  import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\n  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n  import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';\n  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\n  import { RenderPixelatedPass } from 'three/examples/jsm/postprocessing/RenderPixelatedPass.js';\n  import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';\n  import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n  \n  // --- Refs ---\n  const canvasContainer = ref(null);\n  const importConfigFileRef = ref(null);\n  \n  // --- State (Reactive Variables) ---\n  \n  // Thick-to-Thin Parameters (由粗到細參數)\n  const ttStartStrength = ref(0.1);   // 線條起始端的粗度強度值，數值越大起始端越粗\n  const ttEndStrength = ref(0.01);    // 線條末端的粗度強度值，數值越小末端越細\n  const ttMinWorldLength = ref(2.5);  // 由粗到細線條的最小長度，影響隨機生成的短線條\n  const ttMaxWorldLength = ref(3.5);  // 由粗到細線條的最大長度，影響隨機生成的長線條\n  const ttShrinkPower = ref(0.25);    // 由粗到細的收縮速率指數，影響線條粗細變化的曲線形狀\n  const ttNumLines = ref(4);          // 由粗到細線條的數量\n  \n  // Thin-to-Thick Parameters (由細到粗參數)\n  const thStartStrength = ref(0.01);  // 線條起始端的粗度強度值，數值越小起始端越細\n  const thEndStrength = ref(0.1);     // 線條末端的粗度強度值，數值越大末端越粗\n  const thMinWorldLength = ref(2);    // 由細到粗線條的最小長度，影響隨機生成的短線條\n  const thMaxWorldLength = ref(3);    // 由細到粗線條的最大長度，影響隨機生成的長線條\n  const thShrinkPower = ref(1.25);    // 由細到粗的膨脹速率指數，影響線條粗細變化的曲線形狀\n  const thNumLines = ref(3);          // 由細到粗線條的數量\n  \n  // Shared Parameters (共享參數)\n  const resolution = ref(200);        // Marching Cubes 算法的解析度，影響模型細節和表面平滑度\n  const currentMaterial = ref('shader'); // 當前使用的材質類型，可選 'shader'(描邊) 或 'liquid'(液體)\n  const isPixelated = ref(false);     // 控制是否啟用像素化效果\n  const isAutoRotating = ref(false);  // 控制是否啟用自動旋轉\n  \n  // Internal state (內部狀態變數)\n  let scene;                  // Three.js 場景物件\n  let camera;                 // 攝影機物件\n  let renderer;               // 渲染器物件\n  let controls;               // 控制器物件，用於控制攝影機移動\n  let effect;                 // Marching Cubes 效果物件\n  let clock;                  // 時鐘物件，用於時間相關計算\n  let materials;              // 材質集合\n  let pmremGenerator;         // 預計算反射環境映射生成器\n  let composer;               // 效果合成器，用於後處理\n  let pixelPass;              // 像素化效果處理器\n  let animationFrameId;       // 動畫幀 ID，用於取消動畫\n  \n  // Line Data (線條數據)\n  let lineStartTimes = [];    // 儲存每條線的開始時間\n  let randomDirections = [];  // 儲存每條線的隨機方向向量\n  let currentTargetLengths = []; // 儲存每條線的目標長度\n  let lineTypes = [];         // 儲存每條線的類型 ('tt' 或 'th')\n  \n  // Constants (常數)\n  const numSegments = 50;              // 每條線分段數量，影響線條平滑度和細節\n  const subtract = 20;                 // metaball 減法參數，影響形狀融合方式\n  \n  // --- Shaders ---\n  const vertexShader = `\n    uniform vec3 viewVector;\n    uniform vec2 uResolution;\n    uniform float uTime;\n    varying vec2 vUv;\n    varying float opacity;\n    void main() {\n      vUv = uv;\n      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);\n      gl_Position = projectionMatrix * mvPos;\n      vec3 nNormal = normalize(normalMatrix * normal);\n      vec3 nView   = normalize(viewVector - mvPos.xyz);\n      opacity = dot(nNormal, nView);\n      opacity = 1.0 - abs(opacity * 1.3);\n    }\n  `;\n  \n  const fragmentShader = `\n    uniform vec3 uColor;\n    uniform vec2 uResolution;\n    uniform float uTime;\n    varying vec2 vUv;\n    varying float opacity;\n    void main() {\n      vec2 d = gl_FragCoord.xy / uResolution;\n      vec3 fade = vec3(d.x, d.y, 1.0);\n      vec3 c = mix(vec3(0.0), fade * uColor, opacity);\n      gl_FragColor = vec4(c, 1.0);\n    }\n  `;\n  \n  // --- Functions ---\n  \n  function generateMaterials() {\n    return {\n      shader: new THREE.ShaderMaterial({\n        uniforms: {\n          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n          uTime:       { value: 0 },\n          uColor:      { value: new THREE.Color(0x000000) },\n          viewVector:  { value: camera.position }\n        },\n        vertexShader:   vertexShader,\n        fragmentShader: fragmentShader,\n        transparent: true,\n        side: THREE.DoubleSide\n      }),\n      liquid: new THREE.MeshStandardMaterial({\n          color: 0xffffff,\n          metalness: 0.9,\n          roughness: 0,\n          transparent: true,\n          opacity: 0.25,\n          side: THREE.DoubleSide,\n          envMap: null // Will be set by loader\n      })\n    };\n  }\n  \n  function loadEnvironmentMap() {\n    new EXRLoader()\n        .setPath('/hdr/') // Use path relative to public directory\n        .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n            texture.mapping = THREE.EquirectangularReflectionMapping;\n            const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n            pmremGenerator.dispose();\n            texture.dispose();\n  \n            console.log(\"本地 EXR 環境貼圖已載入並處理完成。\");\n            scene.environment = envMap;\n            if (materials && materials.liquid) {\n                materials.liquid.envMap = envMap;\n                materials.liquid.needsUpdate = true;\n            }\n        }, undefined, (error) => {\n            console.error('無法載入本地 EXR 環境貼圖:', error);\n            alert('無法載入 assets/hdr/HDR_Light_Studio_Free_HDRI_Design_05.exr，請檢查檔案是否存在或路徑是否正確。');\n        });\n  }\n  \n  function regenerateLine() {\n      if (!clock || !effect) return; // Ensure initialization\n      const currentTime = clock.getElapsedTime();\n      const totalLines = ttNumLines.value + thNumLines.value;\n  \n      // 調整陣列大小\n      lineStartTimes.length = totalLines;\n      randomDirections.length = totalLines;\n      currentTargetLengths.length = totalLines;\n      lineTypes.length = totalLines;\n  \n      let lineIndex = 0;\n  \n      // 生成由粗到細線條\n      for(let i = 0; i < ttNumLines.value; i++) {\n          if (!randomDirections[lineIndex]) {\n              randomDirections[lineIndex] = new THREE.Vector3();\n          }\n          randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n          currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(ttMinWorldLength.value, ttMaxWorldLength.value);\n          lineTypes[lineIndex] = 'tt';\n          lineStartTimes[lineIndex] = currentTime;\n          lineIndex++;\n      }\n  \n      // 生成由細到粗線條\n      for(let i = 0; i < thNumLines.value; i++) {\n          if (!randomDirections[lineIndex]) {\n              randomDirections[lineIndex] = new THREE.Vector3();\n          }\n          randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n          currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(thMinWorldLength.value, thMaxWorldLength.value);\n          lineTypes[lineIndex] = 'th';\n          lineStartTimes[lineIndex] = currentTime;\n          lineIndex++;\n      }\n      effect.reset();\n  }\n  \n  function updateLineMetaball(obj) {\n      if (!clock) return;\n      obj.reset();\n      const currentTime = clock.getElapsedTime();\n      const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n      const totalLines = ttNumLines.value + thNumLines.value;\n  \n      for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n          if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n              continue;\n          }\n  \n          if (currentTargetLengths[lineIndex] === undefined) continue;\n          const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n          // 使用完整長度\n          let localCurrentLength = localMaxLength;\n          \n          if (localCurrentLength <= 0.001) continue;\n  \n          const currentDirection = randomDirections[lineIndex];\n          const currentLineType = lineTypes[lineIndex];\n          if (!currentDirection || !currentLineType) continue;\n  \n          // 根據線條類型選擇參數\n          let lineStartStrength, lineEndStrength, lineShrinkPowerVal;\n          if (currentLineType === 'tt') {\n              lineStartStrength = ttStartStrength.value;\n              lineEndStrength = ttEndStrength.value;\n              lineShrinkPowerVal = ttShrinkPower.value;\n          } else { // 'th'\n              lineStartStrength = thStartStrength.value;\n              lineEndStrength = thEndStrength.value;\n              lineShrinkPowerVal = thShrinkPower.value;\n          }\n  \n          // 計算Metaball強度和位置\n          for (let i = 0; i <= numSegments; i++) {\n              const segmentT = i / numSegments;\n              const strengthFactor = Math.pow(segmentT, lineShrinkPowerVal);\n              const baseStrength = THREE.MathUtils.lerp(lineStartStrength, lineEndStrength, strengthFactor);\n              \n              const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n              const finalPos = localPos.add(centerOffset);\n  \n              obj.addBall(finalPos.x, finalPos.y, finalPos.z, baseStrength, subtract);\n          }\n      }\n  \n      obj.update();\n  }\n  \n  function exportConfiguration() {\n      if (!camera) return;\n      console.log(\"開始匯出設定...\");\n      const serializableDirections = randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null);\n      const cameraPosition = { x: camera.position.x, y: camera.position.y, z: camera.position.z };\n      // Use _x, _y, etc. for quaternion serialization if needed, but check GLTFExporter compatibility\n      const cameraQuaternion = { x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z, w: camera.quaternion.w };\n  \n      const config = {\n          ttStartStrength: ttStartStrength.value,\n          ttEndStrength: ttEndStrength.value,\n          ttMinWorldLength: ttMinWorldLength.value,\n          ttMaxWorldLength: ttMaxWorldLength.value,\n          ttShrinkPower: ttShrinkPower.value,\n          ttNumLines: ttNumLines.value,\n          thStartStrength: thStartStrength.value,\n          thEndStrength: thEndStrength.value,\n          thMinWorldLength: thMinWorldLength.value,\n          thMaxWorldLength: thMaxWorldLength.value,\n          thShrinkPower: thShrinkPower.value,\n          thNumLines: thNumLines.value,\n          resolution: resolution.value,\n          lineTypes: lineTypes,\n          randomDirections: serializableDirections,\n          currentTargetLengths: currentTargetLengths,\n          cameraPosition: cameraPosition,\n          cameraQuaternion: cameraQuaternion\n      };\n  \n      try {\n          const configString = JSON.stringify(config, null, 2);\n          const blob = new Blob([configString], { type: 'application/json' });\n          const url = URL.createObjectURL(blob);\n          const a = document.createElement('a');\n          a.href = url;\n          a.download = 'metaball_config.json';\n          document.body.appendChild(a);\n          a.click();\n          document.body.removeChild(a);\n          URL.revokeObjectURL(url);\n          console.log(\"設定已匯出為 metaball_config.json\");\n      } catch (e) {\n          console.error(\"匯出設定失敗:\", e);\n          alert(\"匯出設定失敗！\");\n      }\n  }\n  \n  function triggerImport() {\n      importConfigFileRef.value?.click();\n  }\n  \n  function importConfiguration(event) {\n      console.log(\"開始匯入設定...\");\n      const file = (event.target)?.files?.[0];\n      if (!file) {\n          console.log(\"未選擇檔案。\");\n          return;\n      }\n  \n      const reader = new FileReader();\n      reader.onload = function(e) {\n          try {\n              const config = JSON.parse(e.target?.result);\n              console.log(\"讀取的設定:\", config);\n  \n              if (!config || typeof config !== 'object') throw new Error(\"無效的設定檔格式\");\n              const requiredKeys = ['ttStartStrength', 'thStartStrength', 'resolution', 'lineTypes', 'randomDirections', 'currentTargetLengths', 'cameraPosition', 'cameraQuaternion'];\n              for (const key of requiredKeys) {\n                  if (!(key in config)) throw new Error(`缺少必要欄位: ${key}`);\n              }\n              // Ensure ttNumLines and thNumLines exist for validation\n              if (!('ttNumLines' in config) || !('thNumLines' in config)) {\n                   throw new Error(`缺少必要欄位: ttNumLines or thNumLines`);\n              }\n              const totalLines = config.ttNumLines + config.thNumLines;\n              if (!Array.isArray(config.lineTypes) || config.lineTypes.length !== totalLines ||\n                  !Array.isArray(config.randomDirections) || config.randomDirections.length !== totalLines ||\n                  !Array.isArray(config.currentTargetLengths) || config.currentTargetLengths.length !== totalLines) {\n                  throw new Error(\"線條數據數量與線條總數不符\");\n              }\n  \n              // Update reactive refs\n              ttStartStrength.value = config.ttStartStrength;\n              ttEndStrength.value = config.ttEndStrength;\n              ttMinWorldLength.value = config.ttMinWorldLength;\n              ttMaxWorldLength.value = config.ttMaxWorldLength;\n              ttShrinkPower.value = config.ttShrinkPower;\n              ttNumLines.value = config.ttNumLines;\n              thStartStrength.value = config.thStartStrength;\n              thEndStrength.value = config.thEndStrength;\n              thMinWorldLength.value = config.thMinWorldLength;\n              thMaxWorldLength.value = config.thMaxWorldLength;\n              thShrinkPower.value = config.thShrinkPower;\n              thNumLines.value = config.thNumLines;\n              resolution.value = config.resolution;\n              // 不再從JSON恢復UI控制狀態\n              // currentMaterial、isPixelated、isAutoRotating 保持當前值\n  \n              // Update non-reactive Three.js state\n              if (effect) {\n                  effect.material = materials[currentMaterial.value];\n                  updateMarchingCubesParams(); // 調用此函數計算 isolation 並更新效果\n              }\n\n              // 徹底重新實現匯入流程，確保在頁面重新整理後結果也一致\n              if (effect && scene && camera && controls && config.cameraQuaternion) {\n                  console.log(\"開始匯入並應用模型變換...\");\n                  \n                  // 1. 重置相機到統一初始狀態\n                  camera.position.set(0, 0, 30);\n                  camera.up.set(0, 1, 0);\n                  camera.quaternion.set(0, 0, 0, 1);\n                  camera.lookAt(0, 0, 0);\n                  controls.target.set(0, 0, 0);\n                  \n                  // 保留當前的自動旋轉設置\n                  const wasAutoRotating = controls.autoRotate;\n                  controls.update();\n                  controls.autoRotate = wasAutoRotating;\n                  \n                  camera.updateMatrixWorld(true);\n                  \n                  // 2. 從場景中移除現有模型\n                  scene.remove(effect);\n                  \n                  // 3. 重新創建 MarchingCubes 效果，確保與匯出時相同參數\n                  effect = new MarchingCubes(resolution.value, materials[currentMaterial.value], true, true, 100000);\n                  effect.isolation = resolution.value * 1.5; // 使用相同的derivedIsolation計算方式\n                  effect.scale.set(8, 8, 8);\n                  effect.position.set(0, 0, 0); // 確保位置重置\n                  effect.quaternion.set(0, 0, 0, 1); // 確保旋轉重置\n                  effect.enableUvs = false;\n                  effect.enableColors = false;\n                  scene.add(effect);\n                  console.log(\"  - 模型已用標準參數重新創建\");\n                  \n                  // 4. 直接設置線條數據，使用精確來自JSON的值\n                  const totalLines = config.ttNumLines + config.thNumLines;\n                  lineStartTimes = new Array(totalLines);\n                  randomDirections = new Array(totalLines);\n                  currentTargetLengths = new Array(totalLines);\n                  lineTypes = new Array(totalLines);\n                  \n                  const currentTime = clock?.getElapsedTime() ?? 0;\n                  \n                  for (let i = 0; i < totalLines; i++) {\n                      lineTypes[i] = config.lineTypes[i];\n                      currentTargetLengths[i] = config.currentTargetLengths[i];\n                      if (config.randomDirections[i]) {\n                          randomDirections[i] = new THREE.Vector3(\n                              config.randomDirections[i].x,\n                              config.randomDirections[i].y,\n                              config.randomDirections[i].z\n                          );\n                      } else {\n                          randomDirections[i] = null;\n                      }\n                      lineStartTimes[i] = currentTime - 1000; // 確保線條已完全形成，遠早於當前時間\n                  }\n                  console.log(\"  - 線條數據已從JSON精確設置\");\n                  \n                  // 5. 計算模型\n                  effect.reset();\n                  updateLineMetaball(effect);\n                  console.log(\"  - 模型已使用JSON中的線條數據計算完成\");\n                  \n                  // 6. 精確獲取匯出時的相機四元數並應用\n                  const exportCameraQuaternion = new THREE.Quaternion(\n                      config.cameraQuaternion.x ?? config.cameraQuaternion._x,\n                      config.cameraQuaternion.y ?? config.cameraQuaternion._y,\n                      config.cameraQuaternion.z ?? config.cameraQuaternion._z,\n                      config.cameraQuaternion.w ?? config.cameraQuaternion._w\n                  );\n                  \n                  // 7. 確保每次應用方式都一致 - 先重置，再應用逆旋轉\n                  effect.quaternion.set(0, 0, 0, 1); // 完全重置旋轉\n                  const cameraInverseQuaternion = exportCameraQuaternion.clone().invert();\n                  effect.quaternion.premultiply(cameraInverseQuaternion);\n                  effect.matrixWorldNeedsUpdate = true;\n                  effect.updateMatrixWorld(true);\n                  console.log(\"  - 模型旋轉已應用\");\n                  \n                  // 8. 禁用自動更新，避免動畫影響\n                  effect.matrixAutoUpdate = false;\n                  \n                  console.log(\"匯入完成！從初始相機位置看的效果應與匯出時完全相同\");\n              }\n\n              console.log(\"設定已成功匯入。\");\n              alert(\"設定已載入！\");\n  \n          } catch (e) {\n              console.error(\"匯入設定失敗:\", e);\n              alert(`匯入設定失敗！錯誤: ${e.message}`);\n          } finally {\n              if (importConfigFileRef.value) {\n                   importConfigFileRef.value.value = ''; // Reset file input\n              }\n          }\n      };\n      reader.onerror = function(e) {\n          console.error(\"讀取檔案錯誤:\", e);\n          alert(\"讀取檔案時發生錯誤。\");\n           if (importConfigFileRef.value) {\n               importConfigFileRef.value.value = ''; // Reset file input\n          }\n      };\n      reader.readAsText(file);\n  }\n  \n  function exportGLB() {\n      if (!effect || !camera) return;\n      console.log(\"開始匯出 GLB (應用視角)...\");\n      const originalResolution = resolution.value;\n      const originalEffectQuaternion = effect.quaternion.clone();\n      const originalIsolation = effect.isolation; // 保存原始的isolation值\n      const exporter = new GLTFExporter();\n  \n      try {\n          // 直接使用原始解析度，無需臨時修改\n          console.log(`  - 使用目前解析度: ${originalResolution}`);\n          // Re-init with current resolution to ensure clean state\n          effect.init(originalResolution);\n          \n          // 確保保留原始的isolation值，避免模型變粗\n          effect.isolation = originalIsolation;\n          console.log(`  - 設置相同的isolation值: ${originalIsolation}`);\n\n          console.log(\"  - 重新計算模型...\");\n          updateLineMetaball(effect); // Force recalculation\n          console.log(\"  - 模型計算完成.\");\n\n          console.log(\"  - 應用反向攝影機旋轉...\");\n          const cameraInverseQuaternion = camera.quaternion.clone().invert();\n          effect.quaternion.premultiply(cameraInverseQuaternion);\n          effect.updateMatrixWorld(true); // Force update\n          console.log(\"  - 反向旋轉已應用.\");\n\n          exporter.parse(\n              effect,\n              (result) => { // Removed type annotation\n                  if (result instanceof ArrayBuffer) {\n                      try {\n                          const blob = new Blob([result], { type: 'model/gltf-binary' });\n                          const url = URL.createObjectURL(blob);\n                          const a = document.createElement('a');\n                          a.href = url;\n                          a.download = `metaball_model_view_res${originalResolution}.glb`;\n                          document.body.appendChild(a);\n                          a.click();\n                          document.body.removeChild(a);\n                          URL.revokeObjectURL(url);\n                          console.log(`GLB 檔案已匯出: metaball_model_view_res${originalResolution}.glb`);\n                          alert(`模型 (含視角, res ${originalResolution}) GLB 已下載！`);\n                      } catch (e) {\n                          console.error(\"建立或下載 GLB Blob 時出錯:\", e);\n                          alert(\"下載 GLB 時發生錯誤！\");\n                      }\n                  } else {\n                      console.error(\"匯出結果不是預期的 ArrayBuffer:\", result);\n                      alert(\"匯出 GLB 失敗：格式錯誤。請檢查控制台。\");\n                  }\n                   // Restore original state (Success)\n                  console.log(\"  - (成功) 恢復原始模型旋轉...\");\n                  effect.quaternion.copy(originalEffectQuaternion);\n                  effect.updateMatrixWorld(true);\n                  // 已經使用原始解析度，無需恢復\n                  console.log(\"  - 模型旋轉已恢復.\");\n              },\n              (error) => { // Removed type annotation\n                  console.error('匯出 GLB 時發生錯誤:', error);\n                  alert(\"匯出 GLB 時發生錯誤！請檢查控制台。\");\n                  // Restore original state (Error)\n                  console.log(\"  - (錯誤) 恢復原始模型旋轉...\");\n                  effect.quaternion.copy(originalEffectQuaternion);\n                  effect.updateMatrixWorld(true);\n                  console.log(\"  - 模型旋轉已恢復.\");\n              },\n              { binary: true }\n          );\n      } catch (e) {\n           console.error(\"準備匯出或應用旋轉時出錯:\", e);\n           alert(\"準備匯出模型時發生錯誤！\");\n           // Restore original state (Catch)\n           console.log(\"  - (Catch) 恢復原始模型旋轉...\");\n           effect.quaternion.copy(originalEffectQuaternion);\n           effect.updateMatrixWorld(true);\n           console.log(\"  - 模型旋轉已恢復.\");\n      }\n  }\n  \n  function toggleMaterial() {\n      if (!effect || !scene) return;\n      if (currentMaterial.value === 'shader') {\n          currentMaterial.value = 'liquid';\n          if (scene.background instanceof THREE.Color) {\n               scene.background.set(0x111111); // 暗色背景配合液體材質\n          }\n      } else {\n          currentMaterial.value = 'shader';\n           if (scene.background instanceof THREE.Color) {\n               scene.background.set(0xffffff); // 白色背景配合描邊材質\n          }\n      }\n      effect.material = materials[currentMaterial.value];\n      \n      console.log(`材質已切換為: ${currentMaterial.value}, 背景顏色已更新.`);\n  }\n  \n  function togglePixelation() {\n      if (!effect || !scene) return;\n      isPixelated.value = !isPixelated.value;\n      console.log(`像素化狀態已切換為: ${isPixelated.value}`);\n  }\n  \n  function toggleAutoRotate() {\n      if (!controls) return;\n      isAutoRotating.value = !isAutoRotating.value;\n      controls.autoRotate = isAutoRotating.value;\n      controls.autoRotateSpeed = 2.0; // 設置旋轉速度\n      console.log(`自動旋轉狀態已切換為: ${isAutoRotating.value}`);\n  }\n  \n  // --- Input Handlers with Validation ---\n  function handleTtStartStrengthInput() {\n      if (ttStartStrength.value < ttEndStrength.value) {\n          ttEndStrength.value = ttStartStrength.value;\n      }\n  }\n  function handleTtEndStrengthInput() {\n      if (ttEndStrength.value > ttStartStrength.value) {\n          ttStartStrength.value = ttEndStrength.value;\n      }\n  }\n  function handleTtMinLengthInput() {\n      if (ttMinWorldLength.value > ttMaxWorldLength.value) {\n          ttMaxWorldLength.value = ttMinWorldLength.value;\n      }\n  }\n  function handleTtMaxLengthInput() {\n      if (ttMaxWorldLength.value < ttMinWorldLength.value) {\n          ttMinWorldLength.value = ttMaxWorldLength.value;\n      }\n  }\n  function handleThStartStrengthInput() {\n      if (thStartStrength.value > thEndStrength.value) {\n          thEndStrength.value = thStartStrength.value;\n      }\n  }\n  function handleThEndStrengthInput() {\n      if (thEndStrength.value < thStartStrength.value) {\n          thStartStrength.value = thEndStrength.value;\n      }\n  }\n  function handleThMinLengthInput() {\n      if (thMinWorldLength.value > thMaxWorldLength.value) {\n          thMaxWorldLength.value = thMinWorldLength.value;\n      }\n  }\n  function handleThMaxLengthInput() {\n      if (thMaxWorldLength.value < thMinWorldLength.value) {\n          thMinWorldLength.value = thMaxWorldLength.value;\n      }\n  }\n  \n  // --- Watchers ---\n  function updateMarchingCubesParams() {\n       if (effect) {\n          const derivedIsolation = resolution.value * 1.5;\n          effect.init(resolution.value); // Reinitialize when resolution changes\n          effect.isolation = derivedIsolation;\n          console.log(`Marching Cubes params updated: resolution=${resolution.value}, derivedIsolation=${derivedIsolation}`);\n      }\n  }\n  // Watch resolution to update MarchingCubes\n  watch(resolution, updateMarchingCubesParams);\n  \n  \n  // --- Animation Loop ---\n  function animate() {\n    animationFrameId = requestAnimationFrame(animate);\n  \n    if (!effect || !materials || !camera || !renderer || !scene || !controls) return; // Guard\n  \n    // Update scene logic\n    updateLineMetaball(effect);\n    controls.update();\n  \n    // Update shader material uniforms if active\n    if (currentMaterial.value === 'shader' && !isPixelated.value) {\n        const currentTime = clock.getElapsedTime();\n        materials.shader.uniforms.uTime.value = currentTime;\n        materials.shader.uniforms.viewVector.value = camera.position;\n    }\n  \n    // Conditional rendering: composer or direct renderer\n    if (isPixelated.value && composer) {\n        composer.render();\n    } else {\n        renderer.render(scene, camera);\n    }\n  }\n  \n  // --- Resize Handler ---\n  function handleResize() {\n      if (!camera || !renderer || !materials) return;\n      const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n      const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n  \n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n      renderer.setSize(width, height);\n  \n      // Update composer and passes size\n      if (composer) {\n          composer.setSize(width, height);\n      }\n  \n      if (materials.shader) {\n          materials.shader.uniforms.uResolution.value.set(width, height);\n      }\n  }\n  \n  // --- Lifecycle Hooks ---\n  onMounted(() => {\n    if (!canvasContainer.value) {\n      console.error(\"Canvas container not found!\");\n      return;\n    }\n    const container = canvasContainer.value;\n    const width = container.clientWidth;\n    const height = container.clientHeight;\n  \n    // Scene\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color(0xffffff); // Initial background color\n  \n    // Camera\n    camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n    camera.position.set(0, 0, 30);\n    camera.lookAt(scene.position);\n  \n    // Renderer\n    renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n    container.appendChild(renderer.domElement);\n  \n    // Controls\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.autoRotate = isAutoRotating.value;\n    controls.autoRotateSpeed = 2.0;\n  \n    // Lights\n    scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n    dirLight.position.set(5, 10, 7.5);\n    scene.add(dirLight);\n  \n    // PMREMGenerator\n    pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n  \n    // Materials\n    materials = generateMaterials(); // Generate materials after camera is defined\n  \n    // Marching Cubes\n    const derivedIsolation = resolution.value * 1.5;\n    effect = new MarchingCubes(resolution.value, materials[currentMaterial.value], true, true, 100000);\n    effect.isolation = derivedIsolation;\n    effect.scale.set(8, 8, 8);\n    effect.enableUvs = false;\n    effect.enableColors = false;\n    scene.add(effect);\n  \n    // --- Post-processing Setup ---\n    composer = new EffectComposer(renderer);\n    // RenderPixelatedPass automatically adds a RenderPass internally\n    pixelPass = new RenderPixelatedPass(10, scene, camera);\n    composer.addPass(pixelPass);\n    // OutputPass ensures correct colorspace and encoding\n    const outputPass = new OutputPass();\n    composer.addPass(outputPass);\n    // --- End Post-processing Setup ---\n  \n    // Clock\n    clock = new THREE.Clock();\n  \n    // Load Env Map\n    loadEnvironmentMap();\n  \n    // Initial line generation\n    regenerateLine();\n  \n    // Start animation\n    animate();\n  \n    // Add resize listener\n    window.addEventListener('resize', handleResize);\n  });\n  \n  onUnmounted(() => {\n    // Stop animation\n    cancelAnimationFrame(animationFrameId);\n  \n    // Remove resize listener\n    window.removeEventListener('resize', handleResize);\n  \n    // Dispose Three.js objects\n    if (controls) controls.dispose();\n    if (renderer) renderer.dispose();\n    if (materials) {\n        materials.shader?.dispose();\n        materials.liquid?.dispose();\n        // Dispose envMap if loaded\n        if (scene?.environment) scene.environment.dispose();\n    }\n    \n    if (effect) {\n        // MarchingCubes doesn't have a direct dispose method, rely on scene cleanup\n        scene?.remove(effect);\n        // Dispose geometry/material if needed, but MarchingCubes manages internal geometry\n    }\n    if (scene) {\n        // Dispose geometries, materials, textures in the scene\n        scene.traverse((object) => {\n            if (object instanceof THREE.Mesh) {\n                object.geometry?.dispose();\n                // Check if material is an array or single\n                const material = object.material;\n                if (Array.isArray(material)) {\n                    material.forEach((mat) => mat.dispose());\n                } else if (material) {\n                    material.dispose();\n                }\n            }\n        });\n    }\n    if(pmremGenerator) pmremGenerator.dispose(); // Dispose PMREMGenerator\n    if (pixelPass) {\n        // Passes usually don't have a specific dispose method, rely on GC\n    }\n  \n    // Remove canvas\n    if (canvasContainer.value && renderer) {\n      canvasContainer.value.removeChild(renderer.domElement);\n    }\n  \n    console.log(\"Three.js scene cleaned up.\");\n  });\n  \n  </script>"],"version":3}