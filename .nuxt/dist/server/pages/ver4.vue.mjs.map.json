{"file":"ver4.vue.mjs","mappings":";;;;;AA4DwB,QAAI,IAAI;AAGN,QAAI,QAAQ;AAChB,QAAI,KAAK;AACN,QAAI,IAAI;AACb,QAAI,IAAI;;;;;;;;;;;;","names":[],"sources":["../../../../pages/ver4.vue"],"sourcesContent":["<template>\n    <div class=\"main-container\">\n        <h1 class=\"company-name\">\n            <div class=\"front-name\">\n                Splash\n      </div>\n            <div class=\"back-name\">\n                DigiLab\n      </div>\n        </h1>\n      </div>\n    <div class=\"splash-container\">\n      <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n      <!-- <div id=\"switchPanel\" class=\"control-panel switch-panel\">\n            <div class=\"panel-title\">效果切換</div>\n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ currentMaterial === 'shader' ? '描邊材質' : '液體材質' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"currentMaterial === 'liquid'\" @change=\"toggleMaterial\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n\n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ isFlowing ? '流動中' : '靜止' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"isFlowing\" @change=\"toggleFlow\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n\n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ isPixelated ? '像素化' : '正常' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"isPixelated\" @change=\"togglePixelation\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n            \n            <div class=\"switch-control-group\">\n                <label class=\"switch-label\">{{ isAutoRotating ? '自動旋轉中' : '靜止' }}</label>\n                <label class=\"switch\">\n                    <input type=\"checkbox\" :checked=\"isAutoRotating\" @change=\"toggleAutoRotate\">\n                    <span class=\"slider round\"></span>\n                </label>\n    </div>\n      </div> -->\n  </div>\n</template>\n\n<script setup>\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPixelatedPass } from 'three/examples/jsm/postprocessing/RenderPixelatedPass.js';\nimport { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// --- Refs ---\nconst canvasContainer = ref(null);\n\n// --- State (Reactive Variables) ---\n  const currentMaterial = ref('liquid');\n  const isPixelated = ref(false);\n  const isAutoRotating = ref(true);\n  const isFlowing = ref(true);\n  \n  // Internal state (內部狀態變數)\nlet scene;\nlet camera;\nlet renderer;\nlet controls;\nlet effect;\nlet clock;\nlet materials;\nlet pmremGenerator;\n  let composer;\n  let pixelPass;\nlet animationFrameId;\n  let spheres = []; // 儲存噴射球體\n\n  // Line Data (線條數據)\nlet lineStartTimes = [];\nlet randomDirections = [];\nlet currentTargetLengths = [];\nlet lineTypes = [];\n  let lineFlowState = [];     // 儲存每條線的流動狀態\n  \n  // 流動控制相關變數\n  let savedLineState = null;  // 儲存流動開始前的線條狀態，用於恢復\n  let savedCameraState = null; // 儲存流動開始前的攝影機狀態，用於恢復\n  let shrinkStartTime = null; // 收合開始時間，用於同步計算收合進度\n  let shrinkEndTime = null;   // 收合結束時間，用於同步計算收合完成度\n  let growStartTime = null;   // 生長開始時間，用於同步計算生長進度\n  let centerBallVisible = false;   // 球體可見性狀態，控制是否顯示中心球體\n  let globalFlowState = 'idle';    // 全局流動狀態，控制所有線條的統一動畫行為\n  let centerBallFadeStartTime = null; // 中心球體淡出開始時間\n  \n  // 材質基本設定\n  const materialBaseConfig = {\n      color: 0xffffff,\n      metalness: 0,\n      roughness: 0,\n      transparent: true,\n      opacity: 0.75,\n      transmission: 1,\n      ior: 1.33,\n      thickness: 1.0,\n      envMapIntensity: 50.0,\n      side: THREE.DoubleSide\n  };\n  \n  // 所有控制參數整合\n  const flowParams = {\n      // 球體參數\n      centerBall: {\n          maxStrength: 1.0,         // 中心球體最大強度，控制球體最大大小\n          minStrength: 0.0,         // 中心球體最小強度，控制球體最小大小\n          fadeDuration: 5.0,        // 中心球體淡出持續時間（秒）\n          // 球體收縮曲線參數\n          fadeEasing: {\n              type: 'easeIn',       // 'easeIn' 由慢到快, 'easeOut' 由快到慢, 'linear' 線性變化\n              power: 0.5            // 曲線指數，值越大效果越明顯\n          }\n      },\n      \n      // 噴射球體參數\n      shootingSpheres: {\n          count: 12,               // 噴射球體數量\n          radius: 0.15,           // 球體半徑\n          speed: 3.0,             // 基礎速度\n          maxDistance: 8.0,       // 最大飛行距離\n          geometry: {\n              segments: 16,        // 球體分段數\n              rings: 16           // 球體環數\n          }\n      },\n      \n      // 時間控制參數\n      timing: {\n          ballMaxReachAdvance: 1.0,    // 球體提前多少秒達到最大尺寸（秒）\n          ballShrinkStartAdvance: 1.0, // 球體提前多少秒開始收縮（秒）\n          lineShrinkDuration: 3.0,     // 線條收縮持續時間（秒）\n          baseShrinkDuration: 3.0,     // 基本收縮持續時間（秒）\n          flowShrinkDurationFactor: 0.2, // 流動模式下的收縮持續時間因子\n          pauseDuration: 1000,         // 暫停持續時間（毫秒）\n      },\n      \n      // 生長參數\n      growth: {\n          speed: 5.0,              // 線條生長速度\n          easeOutPower: 0.15,      // 生長緩動指數，控制生長速度變化曲線\n          flowSpeedFactor: 0.1     // 流動模式下的生長速度因子，會使生長變慢\n      },\n      \n      // 波浪效果參數\n      wave: {\n          frequency: 1.0,          // 波浪頻率，控制波浪振動的速度\n          amplitudeFactor: 0.3,    // 波浪振幅因子，與基礎強度相乘得到波浪振幅\n          phaseFactor: Math.PI * 4 // 波浪相位因子，控制波浪的空間分佈\n      },\n\n      // 渲染器設定\n      renderer: {\n          pixelRatio: 1.5,         // 最大像素比\n          antialias: true,         // 抗鋸齒\n          alpha: true              // 透明背景\n      },\n\n      // 相機設定\n      camera: {\n          fov: 45,                // 視野角度\n          near: 0.1,              // 近裁剪面\n          far: 1000,              // 遠裁剪面\n          position: {             // 相機位置\n              x: 0,\n              y: 0,\n              z: 25\n          }\n      },\n\n      // 控制器設定\n      controls: {\n          enableDamping: true,     // 啟用阻尼\n          autoRotateSpeed: 5.0,    // 自動旋轉速度\n          enablePan: false,        // 禁止平移\n          enableZoom: false,       // 禁止縮放\n          polarAngle: Math.PI / 2  // 垂直角度\n      }\n  };\n  \n  // Constants (常數)\nconst numSegments = 50;\nconst subtract = 20;\n\n// --- Shaders ---\nconst vertexShader = `\n  uniform vec3 viewVector;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  varying vec2 vUv;\n  varying float opacity;\n  void main() {\n    vUv = uv;\n    vec4 mvPos = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPos;\n    vec3 nNormal = normalize(normalMatrix * normal);\n    vec3 nView   = normalize(viewVector - mvPos.xyz);\n    opacity = dot(nNormal, nView);\n    opacity = 1.0 - abs(opacity * 1.3);\n  }\n`;\n\nconst fragmentShader = `\n  uniform vec3 uColor;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  varying vec2 vUv;\n  varying float opacity;\n  void main() {\n    vec2 d = gl_FragCoord.xy / uResolution;\n    vec3 fade = vec3(d.x, d.y, 1.0);\n    vec3 c = mix(vec3(0.0), fade * uColor, opacity);\n    gl_FragColor = vec4(c, 1.0);\n  }\n`;\n\n// --- Functions ---\nfunction generateMaterials() {\n  return {\n    shader: new THREE.ShaderMaterial({\n      uniforms: {\n        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n        uTime:       { value: 0 },\n        uColor:      { value: new THREE.Color(0x000000) },\n        viewVector:  { value: camera.position }\n      },\n      vertexShader:   vertexShader,\n      fragmentShader: fragmentShader,\n      transparent: true,\n      side: THREE.DoubleSide\n    }),\n      liquid: new THREE.MeshPhysicalMaterial({\n        color: 0xffffff,\n          metalness: 0,\n        roughness: 0,\n        transparent: true,\n          opacity: 0.75,\n          transmission: 1, // 增加透光性，模擬玻璃效果\n        //   reflectivity: 1, // 反射率\n          ior: 1.33, // 折射率 (玻璃約為1.5，水約為1.33)\n          thickness: 1.0, // 材質厚度\n        //   clearcoat: 0.5, // 清漆層強度\n        //   clearcoatRoughness: 0.1, // 清漆層粗糙度\n          envMap: null,\n          envMapIntensity: 50.0,\n          side: THREE.DoubleSide\n    })\n  };\n}\n\nfunction loadEnvironmentMap() {\n  new EXRLoader()\n        .setPath('/hdr/')\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n          texture.mapping = THREE.EquirectangularReflectionMapping;\n          const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n          pmremGenerator.dispose();\n          texture.dispose();\n\n          console.log(\"本地 EXR 環境貼圖已載入並處理完成。\");\n          scene.environment = envMap;\n          if (materials && materials.liquid) {\n              materials.liquid.envMap = envMap;\n              materials.liquid.needsUpdate = true;\n          }\n      }, undefined, (error) => {\n          console.error('無法載入本地 EXR 環境貼圖:', error);\n      });\n}\n\n  function updateLineMetaball(obj) {\n      if (!clock) return;\n      obj.reset();\n    const currentTime = clock.getElapsedTime();\n      const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n      const totalLines = lineTypes.length;\n  \n      // 更新全局流動狀態\n      if (isFlowing.value) {\n          updateGlobalFlowState(currentTime);\n      }\n  \n      // 添加中心metaball球體 (如果可見)\n      if (centerBallVisible) {\n          // 計算中心球體的強度\n          const centerBallStrength = calculateCenterBallStrength(currentTime);\n          if (centerBallStrength > 0.01) {\n              // 將中心球體添加到metaball系統\n              obj.addBall(centerOffset.x, centerOffset.y, centerOffset.z, centerBallStrength, subtract);\n          }\n      }\n\n    for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n        if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n            continue;\n        }\n\n        if (currentTargetLengths[lineIndex] === undefined) continue;\n          \n        const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n        let localCurrentLength = 0;\n        let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n\n          // 使用全局狀態控制所有線條\n          if (isFlowing.value) {\n              switch (globalFlowState) {\n            case 'growing':\n                if (localMaxLength > 0.001) {\n                          const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n                    const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n                    const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                          const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                    localCurrentLength = easedTime * localMaxLength;\n                } else {\n                    localCurrentLength = 0;\n                }\n                break;\n            case 'pauseAtEnd':\n                    localCurrentLength = localMaxLength;\n                break;\n            case 'shrinking':\n                      // 計算收合進度（所有線條使用相同的開始和結束時間）\n                      if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                          const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                          const timeSinceShrinking = currentTime - shrinkStartTime;\n                          const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                          const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n                localCurrentLength = localMaxLength * shrinkFactor;\n                    } else {\n                          localCurrentLength = localMaxLength;\n                }\n                break;\n            case 'pauseAtStart':\n                    localCurrentLength = 0.001;\n                break;\n                  default:\n                      localCurrentLength = 0;\n                      break;\n              }\n              \n              // 更新單獨線條狀態以匹配全局狀態\n              lineFlowState[lineIndex] = globalFlowState;\n          } else {\n              // 非流動模式的原始邏輯\n              if (localMaxLength > 0.001) {\n                  const normalizedTime = Math.min(timeSinceStart / (localMaxLength / (flowParams.growth.speed / obj.scale.x)), 1.0);\n                  const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                    localCurrentLength = easedTime * localMaxLength;\n                } else {\n                    localCurrentLength = 0;\n                }\n        }\n\n        if (localCurrentLength <= 0.001) continue;\n\n        const currentDirection = randomDirections[lineIndex];\n        const currentLineType = lineTypes[lineIndex];\n        if (!currentDirection || !currentLineType) continue;\n\n          // 計算Metaball強度和位置\n        for (let i = 0; i <= numSegments; i++) {\n            const segmentT = i / numSegments;\n              const strengthFactor = Math.pow(segmentT, currentLineType === 'tt' ? 0.25 : 1.25);\n              const baseStrength = THREE.MathUtils.lerp(\n                  currentLineType === 'tt' ? 0.1 : 0.01,\n                  currentLineType === 'tt' ? 0.01 : 0.1,\n                  strengthFactor\n              );\n\n            let dynamicStrength = baseStrength;\n            if (isFlowing.value) {\n                  const flowAmplitude = flowParams.wave.amplitudeFactor * baseStrength;\n                  const flowOffset = Math.sin(currentTime * flowParams.wave.frequency - segmentT * flowParams.wave.phaseFactor) * flowAmplitude;\n                dynamicStrength += flowOffset;\n                dynamicStrength = Math.max(dynamicStrength, 0);\n            }\n\n            const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n            const finalPos = localPos.add(centerOffset);\n            obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, subtract);\n        }\n    }\n\n    obj.update();\n}\n\n  function loadModelJson() {\n      fetch('/modelJson.json')\n          .then(response => response.json())\n          .then(config => {\n            console.log(\"讀取的設定:\", config);\n\n              // 設置線條數據\n              const totalLines = config.lineTypes.length;\n              lineStartTimes = new Array(totalLines);\n              randomDirections = new Array(totalLines);\n              currentTargetLengths = new Array(totalLines);\n              lineTypes = new Array(totalLines);\n              lineFlowState = new Array(totalLines);\n              \n            const currentTime = clock?.getElapsedTime() ?? 0;\n\n            for (let i = 0; i < totalLines; i++) {\n                lineTypes[i] = config.lineTypes[i];\n                currentTargetLengths[i] = config.currentTargetLengths[i];\n                if (config.randomDirections[i]) {\n                    randomDirections[i] = new THREE.Vector3(\n                        config.randomDirections[i].x,\n                        config.randomDirections[i].y,\n                        config.randomDirections[i].z\n                    );\n                } else {\n                    randomDirections[i] = null;\n                }\n                  lineStartTimes[i] = currentTime - 1000;\n                  lineFlowState[i] = 'growing';\n              }\n  \n              // 應用相機旋轉\n              if (effect && config.cameraQuaternion) {\n                  const exportCameraQuaternion = new THREE.Quaternion(\n                      config.cameraQuaternion.x,\n                      config.cameraQuaternion.y,\n                      config.cameraQuaternion.z,\n                      config.cameraQuaternion.w\n                  );\n                  \n                  effect.quaternion.set(0, 0, 0, 1);\n                  const cameraInverseQuaternion = exportCameraQuaternion.clone().invert();\n        effect.quaternion.premultiply(cameraInverseQuaternion);\n                  effect.matrixWorldNeedsUpdate = true;\n                effect.updateMatrixWorld(true);\n                  effect.matrixAutoUpdate = false;\n              }\n  \n              console.log(\"模型設定已載入完成\");\n          })\n          .catch(error => {\n              console.error(\"載入模型設定失敗:\", error);\n          });\n  }\n  \n  // 恢復切換功能\nfunction toggleMaterial() {\n    if (!effect || !scene) return;\n    if (currentMaterial.value === 'shader') {\n        currentMaterial.value = 'liquid';\n    } else {\n        currentMaterial.value = 'shader';\n    }\n    effect.material = materials[currentMaterial.value];\n      \n      console.log(`材質已切換為: ${currentMaterial.value}`);\n  }\n  \n  function togglePixelation() {\n      if (!effect || !scene) return;\n      isPixelated.value = !isPixelated.value;\n      console.log(`像素化狀態已切換為: ${isPixelated.value}`);\n  }\n  \n  function toggleAutoRotate() {\n      if (!controls) return;\n      isAutoRotating.value = !isAutoRotating.value;\n      controls.autoRotate = isAutoRotating.value;\n      controls.autoRotateSpeed = 5.0; // 設置旋轉速度\n      console.log(`自動旋轉狀態已切換為: ${isAutoRotating.value}`);\n}\n\nfunction toggleFlow() {\n    if (!clock || !effect || !camera || !controls) return;\n\n    if (isFlowing.value) {\n          // --- 停止流動 ---\n        isFlowing.value = false;\n          globalFlowState = 'idle';\n          shrinkStartTime = null;\n          shrinkEndTime = null;\n          growStartTime = null;\n          centerBallVisible = false;\n          \n        console.log(\"流動動畫已停止，正在恢復狀態...\");\n\n        if (savedLineState) {\n            lineTypes = [...savedLineState.lineTypes];\n            randomDirections = savedLineState.randomDirections.map((dir) => dir ? new THREE.Vector3(dir.x, dir.y, dir.z) : null);\n            currentTargetLengths = [...savedLineState.currentTargetLengths];\n            lineStartTimes = [...savedLineState.lineStartTimes];\n            lineFlowState = lineTypes.map(() => 'growing');\n\n            console.log(\"線條狀態已恢復\");\n            savedLineState = null;\n        } else {\n            console.warn(\"找不到保存的狀態來恢復。\")\n        }\n\n        if (savedCameraState) {\n            camera.position.copy(savedCameraState.position);\n            camera.quaternion.copy(savedCameraState.quaternion);\n            controls.update();\n            console.log(\"相機狀態已恢復\");\n            savedCameraState = null;\n        } else {\n             console.warn(\"找不到保存的相機狀態來恢復。\")\n        }\n\n        effect.reset();\n    } else {\n          // --- 開始流動 ---\n          console.log(\"開始流動動畫，正在保存當前狀態...\");\n        savedLineState = {\n            lineTypes: [...lineTypes],\n            randomDirections: randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null),\n            currentTargetLengths: [...currentTargetLengths],\n            lineStartTimes: [...lineStartTimes]\n        };\n        savedCameraState = {\n            position: camera.position.clone(),\n            quaternion: camera.quaternion.clone()\n        };\n        console.log(\"狀態已保存。\");\n\n        isFlowing.value = true;\n          \n          // 設置初始全局狀態\n          globalFlowState = 'growing';\n          growStartTime = clock.getElapsedTime();\n\n        const startTime = clock.getElapsedTime();\n          const totalLines = lineTypes.length;\n        lineFlowState.length = totalLines;\n\n          // 所有線條同時開始生長\n          console.log(\"所有線條同時開始生長。\");\n            for (let i = 0; i < totalLines; i++) {\n                lineStartTimes[i] = startTime;\n                lineFlowState[i] = 'growing';\n        }\n\n        effect.reset();\n    }\n    effect.material = materials[currentMaterial.value];\n}\n\n  // --- 全局流動狀態管理 ---\n  function updateGlobalFlowState(currentTime) {\n      if (!isFlowing.value || !clock) return;\n      \n      // 檢查當前時間和設定的時間節點\n      if (globalFlowState === 'growing' && growStartTime !== null) {\n          // 計算所有線條的平均生長完成度\n          const totalLines = lineTypes.length;\n          let totalGrowthProgress = 0;\n          let activeLines = 0;\n          \n          for (let i = 0; i < totalLines; i++) {\n              if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n              \n              activeLines++;\n              const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n              const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n              const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n              const linearDuration = localMaxLength / (currentGrowthSpeed / (effect?.scale.x || 1));\n              const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n              \n              totalGrowthProgress += growthProgress;\n          }\n          \n          const averageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n          \n          // 當平均生長進度達到99%以上，切換到暫停狀態\n          if (averageProgress >= 0.99) {\n              globalFlowState = 'pauseAtEnd';\n              console.log(\"所有線條已生長完成，進入暫停狀態\");\n              \n              // 延遲一段時間後開始收合\n              setTimeout(() => {\n                  if (isFlowing.value) {\n                      startSyncShrinking();\n                  }\n              }, 1000); // 暫停1秒後開始收合\n          }\n      } else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n          // 檢查是否達到收合結束時間\n          if (currentTime >= shrinkEndTime) {\n              globalFlowState = 'pauseAtStart';\n              console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n              \n              // 延遲一段時間後開始新的生長週期\n              setTimeout(() => {\n                  if (isFlowing.value) {\n                      startSyncGrowing();\n                  }\n              }, 1000); // 暫停1秒後開始生長\n          }\n      }\n  }\n  \n  // 開始同步收合\n  function startSyncShrinking() {\n      if (!clock) return;\n      const currentTime = clock.getElapsedTime();\n      \n      console.log(\"所有線條同步收合\");\n      \n      // 更新全局狀態\n      globalFlowState = 'shrinking';\n      \n      // 設置收合時間\n      shrinkStartTime = currentTime;\n      shrinkEndTime = currentTime + flowParams.timing.baseShrinkDuration * flowParams.timing.flowShrinkDurationFactor;\n      \n      // 顯示中心metaball球體\n      centerBallVisible = true;\n  }\n  \n  // 開始同步生長\n  function startSyncGrowing() {\n      if (!clock) return;\n      const currentTime = clock.getElapsedTime();\n      const totalLines = lineTypes.length;\n      \n      console.log(\"所有線條同步生長\");\n      \n      // 更新全局狀態\n      globalFlowState = 'growing';\n      growStartTime = currentTime;\n      centerBallVisible = false;\n      centerBallFadeStartTime = null;\n      \n      // 重置並啟動所有球體\n      spheres.forEach(sphere => {\n          sphere.startTime = currentTime;\n          sphere.active = true;\n          sphere.mesh.position.set(0, 0, 0);\n          \n          // 重新生成隨機方向\n          sphere.direction.set(\n              Math.random() * 2 - 1,\n              Math.random() * 2 - 1,\n              Math.random() * 2 - 1\n          ).normalize();\n      });\n\n      // 重置所有線條的方向和長度\n      for (let i = 0; i < totalLines; i++) {\n          if (lineStartTimes[i] === undefined) continue;\n          \n          // 重新生成隨機方向\n          if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n          randomDirections[i]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n          \n          // 更新線條類型和長度\n          const minL = 2;\n          const maxL = 3.5;\n          currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n          \n          // 更新線條狀態\n          lineStartTimes[i] = currentTime;\n      }\n  }\n  \n  function calculateCenterBallStrength(currentTime) {\n      if (!clock) return 0;\n      \n      if (currentTime === undefined) {\n          currentTime = clock.getElapsedTime();\n      }\n      \n      if (globalFlowState === 'shrinking') {\n          // 在收合階段，球體隨著線條收縮而放大\n          if (shrinkStartTime === null || shrinkEndTime === null) return 0;\n          \n          const shrinkDuration = shrinkEndTime - shrinkStartTime;\n          const timeSinceShrinking = currentTime - shrinkStartTime;\n          \n          // 計算線條收縮進度\n          const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n          \n          // 球體隨著線條收縮進度同步放大\n          // 當線條完全收縮時(shrinkProgress=1)，球體達到最大尺寸\n          return flowParams.centerBall.minStrength + shrinkProgress * (flowParams.centerBall.maxStrength - flowParams.centerBall.minStrength);\n      } else if (globalFlowState === 'pauseAtStart') {\n          // 僅在線條完全收縮後（pauseAtStart狀態）才開始縮小球體\n          if (centerBallFadeStartTime === null) {\n              // 第一次進入此狀態，設置淡出開始時間為當前時間\n              centerBallFadeStartTime = currentTime;\n              // 返回最大尺寸\n              return flowParams.centerBall.maxStrength;\n          }\n          \n          // 計算淡出進度\n          const fadeElapsed = currentTime - centerBallFadeStartTime;\n          const fadeProgress = Math.min(fadeElapsed / flowParams.centerBall.fadeDuration, 1.0);\n          \n          // 根據設定的緩動類型應用不同的曲線函數\n          let easedProgress;\n          switch (flowParams.centerBall.fadeEasing.type) {\n              case 'easeIn':\n                  // 由慢到快 (加速效果)\n                  easedProgress = Math.pow(fadeProgress, flowParams.centerBall.fadeEasing.power);\n                  break;\n              case 'easeOut':\n                  // 由快到慢 (減速效果)\n                  easedProgress = 1 - Math.pow(1 - fadeProgress, flowParams.centerBall.fadeEasing.power);\n                  break;\n              case 'linear':\n              default:\n                  // 線性變化\n                  easedProgress = fadeProgress;\n                  break;\n          }\n          \n          // 球體從最大強度開始收縮\n          return flowParams.centerBall.maxStrength * (1.0 - easedProgress);\n      } else {\n          return flowParams.centerBall.minStrength;\n      }\n  }\n  \n  // 創建噴射球體\n  function createSpheres() {\n      // 清除現有的球體\n      cleanupSpheres();\n\n      const geometry = new THREE.SphereGeometry(\n          flowParams.shootingSpheres.radius,\n          flowParams.shootingSpheres.geometry.segments,\n          flowParams.shootingSpheres.geometry.rings\n      );\n      \n      // 使用基本材質設定\n      const material = new THREE.MeshPhysicalMaterial({\n          ...materialBaseConfig,\n          envMap: scene.environment\n      });\n\n      for (let i = 0; i < flowParams.shootingSpheres.count; i++) {\n          const mesh = new THREE.Mesh(geometry, material);\n          mesh.position.set(0, 0, 0);\n          \n          spheres.push({\n              mesh,\n              direction: generateRandomDirection(),\n              startTime: null,\n              active: false\n          });\n\n          scene.add(mesh);\n      }\n  }\n\n  // 生成隨機方向\n  function generateRandomDirection() {\n      return new THREE.Vector3(\n          Math.random() * 2 - 1,\n          Math.random() * 2 - 1,\n          Math.random() * 2 - 1\n      ).normalize();\n  }\n\n  // 清理球體\n  function cleanupSpheres() {\n      spheres.forEach(sphere => {\n          if (sphere.mesh) {\n              scene.remove(sphere.mesh);\n              sphere.mesh.geometry.dispose();\n              sphere.mesh.material.dispose();\n          }\n      });\n      spheres = [];\n  }\n\n  // 更新球體位置\n  function updateSpheres(currentTime) {\n      if (!isFlowing.value || !clock) return;\n\n      spheres.forEach(sphere => {\n          if (!sphere.active) return;\n\n          const progress = calculateSphereProgress(sphere, currentTime);\n          updateSpherePosition(sphere, progress);\n      });\n  }\n\n  // 計算球體進度\n  function calculateSphereProgress(sphere, currentTime) {\n      const timeSinceStart = currentTime - sphere.startTime;\n      \n      switch (globalFlowState) {\n          case 'growing':\n              const normalizedTime = Math.min(\n                  timeSinceStart / (flowParams.shootingSpheres.maxDistance / flowParams.shootingSpheres.speed),\n                  1.0\n              );\n              return Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n          \n          case 'shrinking':\n              if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                  const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                  const timeSinceShrinking = currentTime - shrinkStartTime;\n                  const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                  return 1.0 - shrinkProgress;\n              }\n              return 1.0;\n          \n          case 'pauseAtEnd':\n              return 1.0;\n          \n          case 'pauseAtStart':\n          default:\n              return 0;\n      }\n  }\n\n  // 更新球體位置\n  function updateSpherePosition(sphere, progress) {\n      sphere.mesh.position.copy(\n          sphere.direction.clone().multiplyScalar(flowParams.shootingSpheres.maxDistance * progress)\n      );\n  }\n\n  // 初始化球體狀態\n  function initializeSpheres(currentTime) {\n      spheres.forEach(sphere => {\n          sphere.startTime = currentTime;\n          sphere.active = true;\n          sphere.mesh.position.set(0, 0, 0);\n          sphere.direction = generateRandomDirection();\n      });\n  }\n\n// --- Animation Loop ---\nfunction animate() {\n  animationFrameId = requestAnimationFrame(animate);\n\n    if (!effect || !materials || !camera || !renderer || !scene || !controls) return;\n\n    const currentTime = clock.getElapsedTime();\n    \n  updateLineMetaball(effect);\n    updateSpheres(currentTime);\n  controls.update();\n\n    if (currentMaterial.value === 'shader' && !isPixelated.value) {\n      materials.shader.uniforms.uTime.value = currentTime;\n      materials.shader.uniforms.viewVector.value = camera.position;\n  }\n\n  if (isPixelated.value && composer) {\n      composer.render();\n  } else {\n      renderer.render(scene, camera);\n  }\n}\n\n// --- Resize Handler ---\nfunction handleResize() {\n    if (!camera || !renderer || !materials) return;\n    const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n    const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n\n    if (composer) {\n        composer.setSize(width, height);\n    }\n\n    if (materials.shader) {\n        materials.shader.uniforms.uResolution.value.set(width, height);\n    }\n}\n\n// --- Lifecycle Hooks ---\nonMounted(() => {\n  if (!canvasContainer.value) {\n    console.error(\"Canvas container not found!\");\n    return;\n  }\n  const container = canvasContainer.value;\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n\n  // Scene\n  scene = new THREE.Scene();\n    scene.background = null;\n\n  // Camera\n  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n    camera.position.set(0, 0, 25);\n  camera.lookAt(scene.position);\n\n  // Renderer\n    renderer = new THREE.WebGLRenderer({ \n        antialias: true,\n        alpha: true\n    });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n  container.appendChild(renderer.domElement);\n\n  // Controls\n  controls = new OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n    controls.autoRotate = isAutoRotating.value;\n    controls.autoRotateSpeed = 5.0;\n    \n    controls.enablePan = false;\n    controls.enableZoom = false;\n    controls.minPolarAngle = Math.PI / 2;\n    controls.maxPolarAngle = Math.PI / 2;\n    controls.minAzimuthAngle = -Infinity;\n    controls.maxAzimuthAngle = Infinity;\n\n  // Lights\n  scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n  dirLight.position.set(5, 10, 7.5);\n  scene.add(dirLight);\n\n  // PMREMGenerator\n  pmremGenerator = new THREE.PMREMGenerator(renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  // Materials\n    materials = generateMaterials();\n\n  // Marching Cubes\n    effect = new MarchingCubes(200, materials[currentMaterial.value], true, true, 100000);\n    effect.isolation = 300;\n  effect.scale.set(8, 8, 8);\n  effect.enableUvs = false;\n  effect.enableColors = false;\n  scene.add(effect);\n\n    // Post-processing Setup\n  composer = new EffectComposer(renderer);\n    pixelPass = new RenderPixelatedPass(5, scene, camera);\n  composer.addPass(pixelPass);\n  const outputPass = new OutputPass();\n  composer.addPass(outputPass);\n\n  // Clock\n  clock = new THREE.Clock();\n\n  // Load Env Map\n  loadEnvironmentMap();\n\n    // 在場景初始化後創建球體\n    createSpheres();\n\n  // Start animation\n  animate();\n    \n    // 自動啟動流動動畫（如果預設為開啟）\n    if (isFlowing.value) {\n        // 立即初始化流動狀態\n        console.log(\"初始化流動動畫狀態...\");\n        const currentTime = clock.getElapsedTime();\n        \n        // 保存當前狀態\n        savedLineState = {\n            lineTypes: [],\n            randomDirections: [],\n            currentTargetLengths: [],\n            lineStartTimes: []\n        };\n        \n        savedCameraState = {\n            position: camera.position.clone(),\n            quaternion: camera.quaternion.clone()\n        };\n        \n        // 設置初始全局狀態\n        globalFlowState = 'growing';\n        growStartTime = currentTime;\n        \n        // 初始化球體\n        spheres.forEach(sphere => {\n            sphere.startTime = currentTime;\n            sphere.active = true;\n            sphere.mesh.position.set(0, 0, 0);\n            sphere.direction.set(\n                Math.random() * 2 - 1,\n                Math.random() * 2 - 1,\n                Math.random() * 2 - 1\n            ).normalize();\n        });\n\n        // Load Model JSON 並在加載完成後開始動畫\n        loadModelJson();\n    }\n\n  // Add resize listener\n  window.addEventListener('resize', handleResize);\n});\n\nonUnmounted(() => {\n  cancelAnimationFrame(animationFrameId);\n  window.removeEventListener('resize', handleResize);\n\n  if (controls) controls.dispose();\n  if (renderer) renderer.dispose();\n  if (materials) {\n      materials.shader?.dispose();\n      materials.liquid?.dispose();\n      if (scene?.environment) scene.environment.dispose();\n  }\n    \n  if (effect) {\n      scene?.remove(effect);\n  }\n   if (scene) {\n        scene.traverse((object) => {\n            if (object instanceof THREE.Mesh) {\n                object.geometry?.dispose();\n                const material = object.material;\n                if (Array.isArray(material)) {\n                    material.forEach((mat) => mat.dispose());\n                } else if (material) {\n                    material.dispose();\n                }\n            }\n        });\n    }\n    if(pmremGenerator) pmremGenerator.dispose();\n  \n  if (canvasContainer.value && renderer) {\n    canvasContainer.value.removeChild(renderer.domElement);\n  }\n\n  console.log(\"Three.js scene cleaned up.\");\n});\n</script>"],"version":3}