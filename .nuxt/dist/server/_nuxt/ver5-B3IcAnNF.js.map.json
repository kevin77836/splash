{"file":"ver5-B3IcAnNF.js","mappings":";;;;;AA4DwB,QAAI,IAAI;AAGR,QAAI,QAAQ;AAChB,QAAI,KAAK;AACN,QAAI,IAAI;AACb,QAAI,IAAI;;;;;;;;;;;;","names":[],"sources":["../../../../pages/ver5.vue"],"sourcesContent":["<template>\n    <div class=\"main-container\">\n        <h1 class=\"company-name\">\n            <div class=\"front-name\">\n                Splash\n      </div>\n            <div class=\"back-name\">\n                DigiLab\n      </div>\n        </h1>\n      </div>\n    <div class=\"splash-container\">\n      <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n      <!-- <div id=\"switchPanel\" class=\"control-panel switch-panel\">\n            <div class=\"panel-title\">效果切換</div>\n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ currentMaterial === 'shader' ? '描邊材質' : '液體材質' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"currentMaterial === 'liquid'\" @change=\"toggleMaterial\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n\n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ isFlowing ? '流動中' : '靜止' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"isFlowing\" @change=\"toggleFlow\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n\n        <div class=\"switch-control-group\">\n            <label class=\"switch-label\">{{ isPixelated ? '像素化' : '正常' }}</label>\n            <label class=\"switch\">\n                <input type=\"checkbox\" :checked=\"isPixelated\" @change=\"togglePixelation\">\n                <span class=\"slider round\"></span>\n            </label>\n        </div>\n            \n            <div class=\"switch-control-group\">\n                <label class=\"switch-label\">{{ isAutoRotating ? '自動旋轉中' : '靜止' }}</label>\n                <label class=\"switch\">\n                    <input type=\"checkbox\" :checked=\"isAutoRotating\" @change=\"toggleAutoRotate\">\n                    <span class=\"slider round\"></span>\n                </label>\n    </div>\n      </div> -->\n  </div>\n</template>\n\n<script setup>\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPixelatedPass } from 'three/examples/jsm/postprocessing/RenderPixelatedPass.js';\nimport { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// --- Refs ---\nconst canvasContainer = ref(null);\n\n// --- State (Reactive Variables) ---\nconst currentMaterial = ref('liquid');\nconst isPixelated = ref(false);\nconst isAutoRotating = ref(true);\nconst isFlowing = ref(true);\n  \n// Internal state (內部狀態變數)\nlet scene;\nlet camera;\nlet renderer;\nlet controls;\nlet effect;\nlet clock;\nlet materials;\nlet pmremGenerator;\nlet composer;\nlet pixelPass;\nlet animationFrameId;\nlet spheres = []; // 儲存噴射球體\n\n// Line Data (線條數據)\nlet lineStartTimes = [];\nlet randomDirections = [];\nlet currentTargetLengths = [];\nlet lineTypes = [];\nlet lineFlowState = [];     // 儲存每條線的流動狀態\n  \n// 流動控制相關變數\nlet savedLineState = null;  // 儲存流動開始前的線條狀態，用於恢復\nlet savedCameraState = null; // 儲存流動開始前的攝影機狀態，用於恢復\nlet shrinkStartTime = null; // 收合開始時間，用於同步計算收合進度\nlet shrinkEndTime = null;   // 收合結束時間，用於同步計算收合完成度\nlet growStartTime = null;   // 生長開始時間，用於同步計算生長進度\nlet centerBallVisible = false;   // 球體可見性狀態，控制是否顯示中心球體\nlet globalFlowState = 'idle';    // 全局流動狀態，控制所有線條的統一動畫行為\nlet centerBallFadeStartTime = null; // 中心球體淡出開始時間\n\n// 所有控制參數整合\nconst flowParams = {\n    // 球體參數\n    centerBall: {\n        maxStrength: 1.0,         // 中心球體最大強度，控制球體最大大小\n        minStrength: 0.0,         // 中心球體最小強度，控制球體最小大小\n        fadeDuration: 5.0,        // 中心球體淡出持續時間（秒）\n        // 球體收縮曲線參數\n        fadeEasing: {\n            type: 'easeIn',       // 'easeIn' 由慢到快, 'easeOut' 由快到慢, 'linear' 線性變化\n            power: 0.5            // 曲線指數，值越大效果越明顯\n        }\n    },\n    \n    // 噴射球體參數\n    shootingSpheres: {\n        count: 12,               // 噴射球體數量\n        size: {\n            min: 0.1,            // 最小半徑\n            max: 0.2,            // 最大半徑\n            variation: 0.05      // 大小變化量（用於動態調整）\n        },\n        speed: {\n            base: 3.0,           // 基礎速度\n            variation: 0.5       // 速度變化量\n        },\n        distance: {\n            min: 6.0,            // 最小飛行距離\n            max: 10.0,           // 最大飛行距離\n            variation: 1.0       // 距離變化量\n        },\n        geometry: {\n            segments: 16,        // 球體分段數\n            rings: 16           // 球體環數\n        },\n        spawnArea: {            // 生成區域範圍\n            radius: 0.5,        // 以原點為中心的生成半徑\n            height: 0.5         // 高度範圍\n        }\n    },\n    \n    // 時間控制參數\n    timing: {\n        ballMaxReachAdvance: 1.0,    // 球體提前多少秒達到最大尺寸（秒）\n        ballShrinkStartAdvance: 1.0, // 球體提前多少秒開始收縮（秒）\n        lineShrinkDuration: 3.0,     // 線條收縮持續時間（秒）\n        baseShrinkDuration: 3.0,     // 基本收縮持續時間（秒）\n        flowShrinkDurationFactor: 0.2, // 流動模式下的收縮持續時間因子\n        pauseDuration: 1000,         // 暫停持續時間（毫秒）\n    },\n    \n    // 生長參數\n    growth: {\n        speed: 5.0,              // 線條生長速度\n        easeOutPower: 0.15,      // 生長緩動指數，控制生長速度變化曲線\n        flowSpeedFactor: 0.1     // 流動模式下的生長速度因子，會使生長變慢\n    },\n    \n    // 波浪效果參數\n    wave: {\n        frequency: 1.0,          // 波浪頻率，控制波浪振動的速度\n        amplitudeFactor: 0.3,    // 波浪振幅因子，與基礎強度相乘得到波浪振幅\n        phaseFactor: Math.PI * 4 // 波浪相位因子，控制波浪的空間分佈\n    },\n\n    // 渲染器設定\n    renderer: {\n        pixelRatio: 1.5,         // 最大像素比\n        antialias: true,         // 抗鋸齒\n        alpha: true              // 透明背景\n    },\n\n    // 相機設定\n    camera: {\n        fov: 45,                // 視野角度\n        near: 0.1,              // 近裁剪面\n        far: 1000,              // 遠裁剪面\n        position: {             // 相機位置\n            x: 0,\n            y: 0,\n            z: 25\n        }\n    },\n\n    // 控制器設定\n    controls: {\n        enableDamping: true,     // 啟用阻尼\n        autoRotateSpeed: 5.0,    // 自動旋轉速度\n        enablePan: false,        // 禁止平移\n        enableZoom: false,       // 禁止縮放\n        polarAngle: Math.PI / 2  // 垂直角度\n    }\n};\n  \n// Constants (常數)\nconst numSegments = 50;\nconst subtract = 20;\n\n// --- Shaders ---\nconst vertexShader = `\n  uniform vec3 viewVector;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  varying vec2 vUv;\n  varying float opacity;\n  void main() {\n    vUv = uv;\n    vec4 mvPos = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPos;\n    vec3 nNormal = normalize(normalMatrix * normal);\n    vec3 nView   = normalize(viewVector - mvPos.xyz);\n    opacity = dot(nNormal, nView);\n    opacity = 1.0 - abs(opacity * 1.3);\n  }\n`;\n\nconst fragmentShader = `\n  uniform vec3 uColor;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  varying vec2 vUv;\n  varying float opacity;\n  void main() {\n    vec2 d = gl_FragCoord.xy / uResolution;\n    vec3 fade = vec3(d.x, d.y, 1.0);\n    vec3 c = mix(vec3(0.0), fade * uColor, opacity);\n    gl_FragColor = vec4(c, 1.0);\n  }\n`;\n\nfunction loadEnvironmentMap() {\n  new EXRLoader()\n        .setPath('/hdr/')\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n          texture.mapping = THREE.EquirectangularReflectionMapping;\n          const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n          pmremGenerator.dispose();\n          texture.dispose();\n\n          console.log(\"本地 EXR 環境貼圖已載入並處理完成。\");\n          scene.environment = envMap;\n          if (materials && materials.liquid) {\n              materials.liquid.envMap = envMap;\n              materials.liquid.needsUpdate = true;\n          }\n      }, undefined, (error) => {\n          console.error('無法載入本地 EXR 環境貼圖:', error);\n      });\n}\n\nfunction loadModelJson() {\n    fetch('/modelJson.json')\n        .then(response => response.json())\n        .then(config => {\n            console.log(\"讀取的設定:\", config);\n\n            // 設置線條數據\n            const totalLines = config.lineTypes.length;\n            lineStartTimes = new Array(totalLines);\n            randomDirections = new Array(totalLines);\n            currentTargetLengths = new Array(totalLines);\n            lineTypes = new Array(totalLines);\n            lineFlowState = new Array(totalLines);\n            \n            const currentTime = clock?.getElapsedTime() ?? 0;\n\n            for (let i = 0; i < totalLines; i++) {\n                lineTypes[i] = config.lineTypes[i];\n                currentTargetLengths[i] = config.currentTargetLengths[i];\n                if (config.randomDirections[i]) {\n                    randomDirections[i] = new THREE.Vector3(\n                        config.randomDirections[i].x,\n                        config.randomDirections[i].y,\n                        config.randomDirections[i].z\n                    );\n                } else {\n                    randomDirections[i] = null;\n                }\n                lineStartTimes[i] = currentTime - 1000;\n                lineFlowState[i] = 'growing';\n            }\n\n            // 應用相機旋轉\n            if (effect && config.cameraQuaternion) {\n                const exportCameraQuaternion = new THREE.Quaternion(\n                    config.cameraQuaternion.x,\n                    config.cameraQuaternion.y,\n                    config.cameraQuaternion.z,\n                    config.cameraQuaternion.w\n                );\n                \n                effect.quaternion.set(0, 0, 0, 1);\n                const cameraInverseQuaternion = exportCameraQuaternion.clone().invert();\n                effect.quaternion.premultiply(cameraInverseQuaternion);\n                effect.matrixWorldNeedsUpdate = true;\n                effect.updateMatrixWorld(true);\n                effect.matrixAutoUpdate = false;\n            }\n\n            console.log(\"模型設定已載入完成\");\n        })\n        .catch(error => {\n            console.error(\"載入模型設定失敗:\", error);\n        });\n}\n  \n// 恢復切換功能\nfunction toggleMaterial() {\n    if (!effect || !scene) return;\n    if (currentMaterial.value === 'shader') {\n        currentMaterial.value = 'liquid';\n    } else {\n        currentMaterial.value = 'shader';\n    }\n    effect.material = materials[currentMaterial.value];\n      \n      console.log(`材質已切換為: ${currentMaterial.value}`);\n}\n  \nfunction togglePixelation() {\n    if (!effect || !scene) return;\n    isPixelated.value = !isPixelated.value;\n    console.log(`像素化狀態已切換為: ${isPixelated.value}`);\n}\n  \nfunction toggleAutoRotate() {\n    if (!controls) return;\n    isAutoRotating.value = !isAutoRotating.value;\n    controls.autoRotate = isAutoRotating.value;\n    controls.autoRotateSpeed = 5.0; // 設置旋轉速度\n    console.log(`自動旋轉狀態已切換為: ${isAutoRotating.value}`);\n}\n\nfunction toggleFlow() {\n    if (!clock || !effect || !camera || !controls) return;\n\n    if (isFlowing.value) {\n          // --- 停止流動 ---\n        isFlowing.value = false;\n          globalFlowState = 'idle';\n          shrinkStartTime = null;\n          shrinkEndTime = null;\n          growStartTime = null;\n          centerBallVisible = false;\n          \n        console.log(\"流動動畫已停止，正在恢復狀態...\");\n\n        if (savedLineState) {\n            lineTypes = [...savedLineState.lineTypes];\n            randomDirections = savedLineState.randomDirections.map((dir) => dir ? new THREE.Vector3(dir.x, dir.y, dir.z) : null);\n            currentTargetLengths = [...savedLineState.currentTargetLengths];\n            lineStartTimes = [...savedLineState.lineStartTimes];\n            lineFlowState = lineTypes.map(() => 'growing');\n\n            console.log(\"線條狀態已恢復\");\n            savedLineState = null;\n        } else {\n            console.warn(\"找不到保存的狀態來恢復。\")\n        }\n\n        if (savedCameraState) {\n            camera.position.copy(savedCameraState.position);\n            camera.quaternion.copy(savedCameraState.quaternion);\n            controls.update();\n            console.log(\"相機狀態已恢復\");\n            savedCameraState = null;\n        } else {\n             console.warn(\"找不到保存的相機狀態來恢復。\")\n        }\n\n        effect.reset();\n    } else {\n          // --- 開始流動 ---\n          console.log(\"開始流動動畫，正在保存當前狀態...\");\n        savedLineState = {\n            lineTypes: [...lineTypes],\n            randomDirections: randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null),\n            currentTargetLengths: [...currentTargetLengths],\n            lineStartTimes: [...lineStartTimes]\n        };\n        savedCameraState = {\n            position: camera.position.clone(),\n            quaternion: camera.quaternion.clone()\n        };\n        console.log(\"狀態已保存。\");\n\n        isFlowing.value = true;\n          \n          // 設置初始全局狀態\n          globalFlowState = 'growing';\n          growStartTime = clock.getElapsedTime();\n\n        const startTime = clock.getElapsedTime();\n          const totalLines = lineTypes.length;\n        lineFlowState.length = totalLines;\n\n          // 所有線條同時開始生長\n          console.log(\"所有線條同時開始生長。\");\n            for (let i = 0; i < totalLines; i++) {\n                lineStartTimes[i] = startTime;\n                lineFlowState[i] = 'growing';\n        }\n\n        effect.reset();\n    }\n    effect.material = materials[currentMaterial.value];\n}\n\n// --- 全局流動狀態管理 ---\nfunction updateGlobalFlowState(currentTime) {\n    if (!isFlowing.value || !clock) return;\n    \n    // 檢查當前時間和設定的時間節點\n    if (globalFlowState === 'growing' && growStartTime !== null) {\n        // 計算所有線條的平均生長完成度\n        const totalLines = lineTypes.length;\n        let totalGrowthProgress = 0;\n        let activeLines = 0;\n        \n        for (let i = 0; i < totalLines; i++) {\n            if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n            \n            activeLines++;\n            const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n            const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n            const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n            const linearDuration = localMaxLength / (currentGrowthSpeed / (effect?.scale.x || 1));\n            const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n            \n            totalGrowthProgress += growthProgress;\n        }\n        \n        const averageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n        \n        // 當平均生長進度達到99%以上，切換到暫停狀態\n        if (averageProgress >= 0.99) {\n            globalFlowState = 'pauseAtEnd';\n            console.log(\"所有線條已生長完成，進入暫停狀態\");\n            \n            // 延遲一段時間後開始收合\n            setTimeout(() => {\n                if (isFlowing.value) {\n                    startSyncShrinking();\n                }\n            }, 1000); // 暫停1秒後開始收合\n        }\n    } else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n        // 檢查是否達到收合結束時間\n        if (currentTime >= shrinkEndTime) {\n            globalFlowState = 'pauseAtStart';\n            console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n            \n            // 延遲一段時間後開始新的生長週期\n            setTimeout(() => {\n                if (isFlowing.value) {\n                    startSyncGrowing();\n                }\n            }, 1000); // 暫停1秒後開始生長\n        }\n    }\n}\n\nfunction updateLineMetaball(obj) {\n    if (!clock) return;\n    obj.reset();\n    const currentTime = clock.getElapsedTime();\n    const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n    const totalLines = lineTypes.length;\n  \n    // 更新全局流動狀態\n    if (isFlowing.value) {\n        updateGlobalFlowState(currentTime);\n    }\n\n    // 添加中心metaball球體 (如果可見)\n    if (centerBallVisible) {\n        // 計算中心球體的強度\n        const centerBallStrength = calculateCenterBallStrength(currentTime);\n        if (centerBallStrength > 0.01) {\n            // 將中心球體添加到metaball系統\n            obj.addBall(centerOffset.x, centerOffset.y, centerOffset.z, centerBallStrength, subtract);\n        }\n    }\n\n    for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n        if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n            continue;\n        }\n\n        if (currentTargetLengths[lineIndex] === undefined) continue;\n          \n        const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n        let localCurrentLength = 0;\n        let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n\n        // 使用全局狀態控制所有線條\n        if (isFlowing.value) {\n            switch (globalFlowState) {\n                case 'growing':\n                    if (localMaxLength > 0.001) {\n                                const currentGrowthSpeed = flowParams.growth.speed * flowParams.growth.flowSpeedFactor;\n                        const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n                        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n                                const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                        localCurrentLength = easedTime * localMaxLength;\n                    } else {\n                        localCurrentLength = 0;\n                    }\n                    break;\n                case 'pauseAtEnd':\n                        localCurrentLength = localMaxLength;\n                    break;\n                case 'shrinking':\n                    // 計算收合進度（所有線條使用相同的開始和結束時間）\n                    if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                        const timeSinceShrinking = currentTime - shrinkStartTime;\n                        const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                        const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n                        localCurrentLength = localMaxLength * shrinkFactor;\n                    } else {\n                        localCurrentLength = localMaxLength;\n                    }\n                    break;\n                case 'pauseAtStart':\n                    localCurrentLength = 0.001;\n                    break;\n                default:\n                    localCurrentLength = 0;\n                    break;\n            }\n            \n            // 更新單獨線條狀態以匹配全局狀態\n            lineFlowState[lineIndex] = globalFlowState;\n        } else {\n            // 非流動模式的原始邏輯\n            if (localMaxLength > 0.001) {\n                const normalizedTime = Math.min(timeSinceStart / (localMaxLength / (flowParams.growth.speed / obj.scale.x)), 1.0);\n                const easedTime = Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n                localCurrentLength = easedTime * localMaxLength;\n            } else {\n                localCurrentLength = 0;\n            }\n        }\n\n        if (localCurrentLength <= 0.001) continue;\n\n        const currentDirection = randomDirections[lineIndex];\n        const currentLineType = lineTypes[lineIndex];\n        if (!currentDirection || !currentLineType) continue;\n\n          // 計算Metaball強度和位置\n        for (let i = 0; i <= numSegments; i++) {\n            const segmentT = i / numSegments;\n            const strengthFactor = Math.pow(segmentT, currentLineType === 'tt' ? 0.25 : 1.25);\n            const baseStrength = THREE.MathUtils.lerp(\n                currentLineType === 'tt' ? 0.1 : 0.01,\n                currentLineType === 'tt' ? 0.01 : 0.1,\n                strengthFactor\n            );\n\n            let dynamicStrength = baseStrength;\n            if (isFlowing.value) {\n                  const flowAmplitude = flowParams.wave.amplitudeFactor * baseStrength;\n                  const flowOffset = Math.sin(currentTime * flowParams.wave.frequency - segmentT * flowParams.wave.phaseFactor) * flowAmplitude;\n                dynamicStrength += flowOffset;\n                dynamicStrength = Math.max(dynamicStrength, 0);\n            }\n\n            const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n            const finalPos = localPos.add(centerOffset);\n            obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, subtract);\n        }\n    }\n\n    obj.update();\n}\n\n// 開始同步生長\nfunction startSyncGrowing() {\n    if (!clock) return;\n    const currentTime = clock.getElapsedTime();\n    const totalLines = lineTypes.length;\n    \n    console.log(\"所有線條同步生長\");\n    \n    // 更新全局狀態\n    globalFlowState = 'growing';\n    growStartTime = currentTime;\n    centerBallVisible = false;\n    centerBallFadeStartTime = null;\n    \n    // 重置並啟動所有球體\n    spheres.forEach(sphere => {\n        sphere.startTime = currentTime;\n        sphere.active = true;\n        sphere.mesh.position.set(0, 0, 0);\n        \n        // 使用 utils.random.direction\n        sphere.direction = utils.random.direction();\n    });\n\n    // 重置所有線條的方向和長度\n    for (let i = 0; i < totalLines; i++) {\n        if (lineStartTimes[i] === undefined) continue;\n        \n        // 使用 utils.random.direction\n        if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n        randomDirections[i]?.copy(utils.random.direction());\n        \n        // 更新線條類型和長度\n        const minL = 2;\n        const maxL = 3.5;\n        currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n        \n        // 更新線條狀態\n        lineStartTimes[i] = currentTime;\n    }\n}  \n  \n// 開始同步收合\nfunction startSyncShrinking() {\n    if (!clock) return;\n    const currentTime = clock.getElapsedTime();\n    \n    console.log(\"所有線條同步收合\");\n    \n    // 更新全局狀態\n    globalFlowState = 'shrinking';\n    \n    // 設置收合時間\n    shrinkStartTime = currentTime;\n    shrinkEndTime = currentTime + flowParams.timing.baseShrinkDuration * flowParams.timing.flowShrinkDurationFactor;\n    \n    // 顯示中心metaball球體\n    centerBallVisible = true;\n}\n  \n\nfunction calculateCenterBallStrength(currentTime) {\n    if (!clock) return 0;\n    \n    if (currentTime === undefined) {\n        currentTime = clock.getElapsedTime();\n    }\n    \n    if (globalFlowState === 'shrinking') {\n        // 在收合階段，球體隨著線條收縮而放大\n        if (shrinkStartTime === null || shrinkEndTime === null) return 0;\n        \n        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n        const timeSinceShrinking = currentTime - shrinkStartTime;\n        \n        // 計算線條收縮進度\n        const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n        \n        // 球體隨著線條收縮進度同步放大\n        // 當線條完全收縮時(shrinkProgress=1)，球體達到最大尺寸\n        return flowParams.centerBall.minStrength + shrinkProgress * (flowParams.centerBall.maxStrength - flowParams.centerBall.minStrength);\n    } else if (globalFlowState === 'pauseAtStart') {\n        // 僅在線條完全收縮後（pauseAtStart狀態）才開始縮小球體\n        if (centerBallFadeStartTime === null) {\n            // 第一次進入此狀態，設置淡出開始時間為當前時間\n            centerBallFadeStartTime = currentTime;\n            // 返回最大尺寸\n            return flowParams.centerBall.maxStrength;\n        }\n        \n        // 計算淡出進度\n        const fadeElapsed = currentTime - centerBallFadeStartTime;\n        const fadeProgress = Math.min(fadeElapsed / flowParams.centerBall.fadeDuration, 1.0);\n        \n        // 根據設定的緩動類型應用不同的曲線函數\n        let easedProgress;\n        switch (flowParams.centerBall.fadeEasing.type) {\n            case 'easeIn':\n                // 由慢到快 (加速效果)\n                easedProgress = Math.pow(fadeProgress, flowParams.centerBall.fadeEasing.power);\n                break;\n            case 'easeOut':\n                // 由快到慢 (減速效果)\n                easedProgress = 1 - Math.pow(1 - fadeProgress, flowParams.centerBall.fadeEasing.power);\n                break;\n            case 'linear':\n            default:\n                // 線性變化\n                easedProgress = fadeProgress;\n                break;\n        }\n        \n        // 球體從最大強度開始收縮\n        return flowParams.centerBall.maxStrength * (1.0 - easedProgress);\n    } else {\n        return flowParams.centerBall.minStrength;\n    }\n}\n  \n// 工具函數\nconst utils = {\n    // 在指定範圍內生成隨機數\n    random: {\n        float: (min, max) => Math.random() * (max - min) + min,\n        vector: (radius) => new THREE.Vector3(\n            (Math.random() - 0.5) * 2 * radius,\n            (Math.random() - 0.5) * 2 * radius,\n            (Math.random() - 0.5) * 2 * radius\n        ),\n        direction: () => utils.random.vector(1).normalize()\n    },\n    \n    // 材質相關功能\n    material: {\n        // 生成基礎材質設定\n        getBaseConfig: () => ({\n            color: 0xffffff,\n            metalness: 0,\n            roughness: 0,\n            transparent: true,\n            opacity: 0.75,\n            transmission: 1,\n            ior: 1.33,\n            thickness: 1.0,\n            envMapIntensity: 50.0,\n            side: THREE.DoubleSide\n        }),\n        \n        // 生成所有材質\n        generateMaterials: (camera, scene) => ({\n            shader: new THREE.ShaderMaterial({\n                uniforms: {\n                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },\n                    uTime: { value: 0 },\n                    uColor: { value: new THREE.Color(0x000000) },\n                    viewVector: { value: camera.position }\n                },\n                vertexShader,\n                fragmentShader,\n                transparent: true,\n                side: THREE.DoubleSide\n            }),\n            liquid: new THREE.MeshPhysicalMaterial({\n                ...utils.material.getBaseConfig(),\n                envMap: scene?.environment || null\n            })\n        })\n    },\n    \n    // 球體相關功能\n    sphere: {\n        generateProperties: () => ({\n            radius: utils.random.float(\n                flowParams.shootingSpheres.size.min,\n                flowParams.shootingSpheres.size.max\n            ),\n            speed: utils.random.float(\n                flowParams.shootingSpheres.speed.base - flowParams.shootingSpheres.speed.variation,\n                flowParams.shootingSpheres.speed.base + flowParams.shootingSpheres.speed.variation\n            ),\n            maxDistance: utils.random.float(\n                flowParams.shootingSpheres.distance.min,\n                flowParams.shootingSpheres.distance.max\n            )\n        })\n    },\n    \n    // 場景相關功能\n    scene: {\n        // 初始化場景\n        initialize: (container) => {\n            const width = container.clientWidth;\n            const height = container.clientHeight;\n            \n            // Scene\n            const scene = new THREE.Scene();\n            scene.background = null;\n            \n            // Camera\n            const camera = new THREE.PerspectiveCamera(\n                flowParams.camera.fov,\n                width / height,\n                flowParams.camera.near,\n                flowParams.camera.far\n            );\n            camera.position.set(\n                flowParams.camera.position.x,\n                flowParams.camera.position.y,\n                flowParams.camera.position.z\n            );\n            camera.lookAt(0, 0, 0);\n            \n            // Renderer\n            const renderer = new THREE.WebGLRenderer({\n                antialias: flowParams.renderer.antialias,\n                alpha: flowParams.renderer.alpha\n            });\n            renderer.setSize(width, height);\n            renderer.setPixelRatio(Math.min(window.devicePixelRatio, flowParams.renderer.pixelRatio));\n            container.appendChild(renderer.domElement);\n            \n            // Controls\n            const controls = new OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = flowParams.controls.enableDamping;\n            controls.autoRotate = isAutoRotating.value;\n            controls.autoRotateSpeed = flowParams.controls.autoRotateSpeed;\n            controls.enablePan = flowParams.controls.enablePan;\n            controls.enableZoom = flowParams.controls.enableZoom;\n            controls.minPolarAngle = flowParams.controls.polarAngle;\n            controls.maxPolarAngle = flowParams.controls.polarAngle;\n            controls.minAzimuthAngle = -Infinity;\n            controls.maxAzimuthAngle = Infinity;\n            \n            // Lights\n            scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n            dirLight.position.set(5, 10, 7.5);\n            scene.add(dirLight);\n            \n            return { scene, camera, renderer, controls };\n        },\n        \n        // 清理場景資源\n        cleanup: (scene, renderer, materials, effect, pmremGenerator, container) => {\n            if (controls) controls.dispose();\n            if (renderer) {\n                renderer.dispose();\n                container?.removeChild(renderer.domElement);\n            }\n            \n            if (materials) {\n                materials.shader?.dispose();\n                materials.liquid?.dispose();\n                if (scene?.environment) scene.environment.dispose();\n            }\n            \n            if (effect) {\n                scene?.remove(effect);\n            }\n            \n            if (scene) {\n                scene.traverse((object) => {\n                    if (object instanceof THREE.Mesh) {\n                        object.geometry?.dispose();\n                        const material = object.material;\n                        if (Array.isArray(material)) {\n                            material.forEach((mat) => mat.dispose());\n                        } else if (material) {\n                            material.dispose();\n                        }\n                    }\n                });\n            }\n            \n            if (pmremGenerator) pmremGenerator.dispose();\n        }\n    }\n};\n// 更新球體位置\nfunction updateSpheres(currentTime) {\n    if (!isFlowing.value || !clock) return;\n\n    spheres.forEach(sphere => {\n        if (!sphere.active) return;\n\n        const progress = calculateSphereProgress(sphere, currentTime);\n        updateSpherePosition(sphere, progress);\n    });\n}\n\n// 計算球體進度\nfunction calculateSphereProgress(sphere, currentTime) {\n    const timeSinceStart = currentTime - sphere.startTime;\n    \n    switch (globalFlowState) {\n        case 'growing':\n            const normalizedTime = Math.min(\n                timeSinceStart / (sphere.properties.maxDistance / sphere.properties.speed),\n                1.0\n            );\n            return Math.pow(normalizedTime, flowParams.growth.easeOutPower);\n        \n        case 'shrinking':\n            if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                const timeSinceShrinking = currentTime - shrinkStartTime;\n                const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                return 1.0 - shrinkProgress;\n            }\n            return 1.0;\n        \n        case 'pauseAtEnd':\n            return 1.0;\n        \n        case 'pauseAtStart':\n        default:\n            return 0;\n    }\n}\n\n// 更新球體位置\nfunction updateSpherePosition(sphere, progress) {\n    // 計算目標位置\n    const targetPosition = sphere.direction.clone()\n        .multiplyScalar(sphere.properties.maxDistance * progress);\n    \n    // 從初始位置移動到目標位置\n    sphere.mesh.position.copy(targetPosition);\n}\n\n// 創建噴射球體\nfunction createSpheres() {\n    cleanupSpheres();\n    \n    for (let i = 0; i < flowParams.shootingSpheres.count; i++) {\n        const properties = utils.sphere.generateProperties();\n        \n        const geometry = new THREE.SphereGeometry(\n            properties.radius,\n            flowParams.shootingSpheres.geometry.segments,\n            flowParams.shootingSpheres.geometry.rings\n        );\n        \n        const material = new THREE.MeshPhysicalMaterial({\n            ...utils.material.getBaseConfig(),\n            envMap: scene.environment\n        });\n\n        const mesh = new THREE.Mesh(geometry, material);\n        \n        const spawnPosition = utils.random.vector(flowParams.shootingSpheres.spawnArea.radius);\n        mesh.position.copy(spawnPosition);\n\n        spheres.push({\n            mesh,\n            direction: utils.random.direction(),\n            startTime: null,\n            active: false,\n            properties\n        });\n\n        scene.add(mesh);\n    }\n}\n\n// 清理球體\nfunction cleanupSpheres() {\n    spheres.forEach(sphere => {\n        if (sphere.mesh) {\n            scene.remove(sphere.mesh);\n            sphere.mesh.geometry.dispose();\n            sphere.mesh.material.dispose();\n        }\n    });\n    spheres = [];\n}\n\n// --- Animation Loop ---\nfunction animate() {\n  animationFrameId = requestAnimationFrame(animate);\n\n    if (!effect || !materials || !camera || !renderer || !scene || !controls) return;\n\n    const currentTime = clock.getElapsedTime();\n    \n  updateLineMetaball(effect);\n    updateSpheres(currentTime);\n  controls.update();\n\n    if (currentMaterial.value === 'shader' && !isPixelated.value) {\n      materials.shader.uniforms.uTime.value = currentTime;\n      materials.shader.uniforms.viewVector.value = camera.position;\n  }\n\n  if (isPixelated.value && composer) {\n      composer.render();\n  } else {\n      renderer.render(scene, camera);\n  }\n}\n\n// --- Resize Handler ---\nfunction handleResize() {\n    if (!camera || !renderer || !materials) return;\n    const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n    const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n\n    if (composer) {\n        composer.setSize(width, height);\n    }\n\n    if (materials.shader) {\n        materials.shader.uniforms.uResolution.value.set(width, height);\n    }\n}\n\n// --- Lifecycle Hooks ---\nonMounted(() => {\n    if (!canvasContainer.value) {\n        console.error(\"Canvas container not found!\");\n        return;\n    }\n    \n    const { scene: newScene, camera: newCamera, renderer: newRenderer, controls: newControls } = utils.scene.initialize(canvasContainer.value);\n    \n    scene = newScene;\n    camera = newCamera;\n    renderer = newRenderer;\n    controls = newControls;\n    \n    // PMREMGenerator\n    pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n    \n    // Materials\n    materials = utils.material.generateMaterials(camera, scene);\n\n    // Marching Cubes\n    effect = new MarchingCubes(200, materials[currentMaterial.value], true, true, 100000);\n    effect.isolation = 300;\n    effect.scale.set(8, 8, 8);\n    effect.enableUvs = false;\n    effect.enableColors = false;\n    scene.add(effect);\n\n    // Post-processing Setup\n    composer = new EffectComposer(renderer);\n    pixelPass = new RenderPixelatedPass(5, scene, camera);\n    composer.addPass(pixelPass);\n    const outputPass = new OutputPass();\n    composer.addPass(outputPass);\n\n    // Clock\n    clock = new THREE.Clock();\n\n    // Load Env Map\n    loadEnvironmentMap();\n\n    // 在場景初始化後創建球體\n    createSpheres();\n\n    // Start animation\n    animate();\n    \n    // 自動啟動流動動畫（如果預設為開啟）\n    if (isFlowing.value) {\n        // 立即初始化流動狀態\n        console.log(\"初始化流動動畫狀態...\");\n        const currentTime = clock.getElapsedTime();\n        \n        // 保存當前狀態\n        savedLineState = {\n            lineTypes: [],\n            randomDirections: [],\n            currentTargetLengths: [],\n            lineStartTimes: []\n        };\n        \n        savedCameraState = {\n            position: camera.position.clone(),\n            quaternion: camera.quaternion.clone()\n        };\n        \n        // 設置初始全局狀態\n        globalFlowState = 'growing';\n        growStartTime = currentTime;\n        \n        // 初始化球體\n        spheres.forEach(sphere => {\n            sphere.startTime = currentTime;\n            sphere.active = true;\n            sphere.mesh.position.set(0, 0, 0);\n            sphere.direction.set(\n                Math.random() * 2 - 1,\n                Math.random() * 2 - 1,\n                Math.random() * 2 - 1\n            ).normalize();\n        });\n\n        // Load Model JSON 並在加載完成後開始動畫\n        loadModelJson();\n    }\n\n    // Add resize listener\n    window.addEventListener('resize', handleResize);\n});\n\nonUnmounted(() => {\n    cancelAnimationFrame(animationFrameId);\n    window.removeEventListener('resize', handleResize);\n    \n    utils.scene.cleanup(scene, renderer, materials, effect, pmremGenerator, canvasContainer.value);\n    \n    console.log(\"Three.js scene cleaned up.\");\n});\n</script>"],"version":3}