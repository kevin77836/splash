{"version":3,"file":"Splash-DJc1Nhcl.js","sources":["../../../../components/Splash.vue"],"sourcesContent":["<template>\n  <div class=\"c-splash-component\">\n    <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n  </div>\n</template>\n\n<script setup>\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\nimport { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';\nimport { TTFLoader } from 'three/examples/jsm/loaders/TTFLoader.js';\nimport gsap from 'gsap';\n\n// 父組件事件\nconst emit = defineEmits([\n  'stateChange',       // 狀態變化事件\n  'animationComplete', // 動畫完成事件\n  'resourcesLoaded'    // 資源載入完成事件\n]);\n\n// =========================================\n// 1. 響應式狀態和參數配置\n// =========================================\n\n// --- Core Refs ---\nconst canvasContainer = ref(null);\n\n// --- 線條參數配置 ---\nconst ttParams = reactive({\n  startStrength: 0.1,    // 粗到細線條：起始端粗度\n  endStrength: 0.01,     // 粗到細線條：末端粗度\n  minLength: 2.5,        // 粗到細線條：最小長度\n  maxLength: 3.5,        // 粗到細線條：最大長度\n  shrinkPower: 0.25,     // 粗到細線條：粗細變化曲線指數\n  numLines: 4            // 粗到細線條：數量\n});\n\nconst thParams = reactive({\n  startStrength: 0.01,   // 細到粗線條：起始端粗度\n  endStrength: 0.1,      // 細到粗線條：末端粗度\n  minLength: 2,          // 細到粗線條：最小長度\n  maxLength: 3,          // 細到粗線條：最大長度\n  shrinkPower: 1.25,     // 細到粗線條：粗細變化曲線指數\n  numLines: 3            // 細到粗線條：數量\n});\n\n// --- 球體參數配置 ---\nconst sphereParams = reactive({\n  count: 20,           // 球體數量\n  minRadius: 0.35,      // 最小半徑\n  maxRadius: 0.5,      // 最大半徑\n  minLength: 3.0,      // 最小目標長度\n  maxLength: 10.0,      // 最大目標長度\n  segmentDetail: 16,   // 幾何體細分\n  minScale: 0        // 最小縮放值(原點狀態)\n});\n\n// --- 流動動畫參數 ---\nconst animParams = reactive({\n  // 基本設定\n  mobileResolution: 100,\n  resolution: 100,                // Marching Cubes 解析度\n  numSegments: 50,                // 每條線分段數量\n  subtract: 20,                   // Metaball 減法參數\n  \n  // 統一動畫控制參數（現在代表秒數）\n  growSpeed: 3,                 // 生長動畫持續時間（秒）\n  growthEaseOutPower: 0.15,       // 生長緩動指數 (值越小結尾越平滑)\n  shrinkSpeed: 1,               // 收縮動畫持續時間（秒）\n  shrinkEaseInPower: 2.5,         // 收縮緩動指數 (值越大開頭越快)\n  \n  // 波浪效果設定\n  flowWaveFrequency: 1.0,         // 波浪頻率\n  flowWaveAmplitudeFactor: 0.15,  // 波浪振幅因子\n  flowWaveAmplitudeFactorAtStart: 0.5, // 原點狀態下的波浪振幅因子\n  flowWavePhaseFactor: Math.PI * 4, // 波浪相位因子\n});\n\n// =========================================\n// 2. Three.js 核心物件和狀態\n// =========================================\n\n// --- Three.js 核心物件 ---\nlet scene = null;\nlet camera = null;\nlet renderer = null;\nlet controls = null;\nlet effect = null;\nlet clock = null;\nlet material = null;\nlet pmremGenerator = null;\nlet animationFrameId = null;\nlet sphereGroup = null; // 新增球體群組物件\n\nlet targetRotationX = 0;\nlet targetRotationY = 0;\nlet targetPositionX = 0;\nlet targetPositionY = 0;\nlet modelRotationX = 0;\nlet modelRotationY = 0;\n\n// --- 滾動位移控制變量 ---\nlet targetScrollOffsetX = 0;\nlet targetScrollOffsetY = 0;\nlet targetScrollOffsetZ = 0;\n\n// --- 線條數據 ---\nlet lineStartTimes = [];      // 每條線的開始時間\nlet randomDirections = [];    // 每條線的隨機方向向量\nlet currentTargetLengths = []; // 每條線的目標長度\nlet lineTypes = [];           // 每條線的類型 ('tt' 或 'th')\nlet lineFlowState = [];       // 每條線的流動狀態\n\n// --- 球體特效 ---\nlet spheres = [];             // 儲存所有射出的球體\nlet sphereMaterial = null;    // 共用球體材質\n\n// --- 流動控制狀態 ---\nlet shrinkStartTime = null;   // 收合開始時間\nlet shrinkEndTime = null;     // 收合結束時間\nlet growStartTime = null;     // 生長開始時間\nlet globalFlowState = 'idle'; // 全局流動狀態\nlet delayedStateUpdateId = null; // 用於跟踪狀態更新的延遲回調ID\n\n// --- 文字物件 ---\nlet textMesh1 = null;\nlet textMesh2 = null;\nlet font = null;\nlet textTargetPosition1 = null; // 儲存文字1的目標位置\nlet textTargetPosition2 = null; // 儲存文字2的目標位置\nlet textOriginPosition1 = null; // 儲存文字1的原點位置\nlet textOriginPosition2 = null; // 儲存文字2的原點位置\n// =========================================\n// 3. 材質和環境設定\n// =========================================\n\n/**\n * 生成液體材質\n */\nfunction generateMaterial() {\n  return new THREE.MeshPhysicalMaterial({\n    color: 0xffffff,\n    metalness: 0,\n    roughness: 0,\n    transparent: true,\n    opacity: 0.5,\n    transmission: 1,   // 增加透光性\n    ior: 1.5,          // 折射率\n    thickness: 1,    // 材質厚度\n    envMapIntensity: 10.0,\n    side: THREE.DoubleSide,\n    dispersion: 2,\n  });\n}\n\n/**\n * 載入環境貼圖\n */\nfunction loadEnvironmentMap() {\n  return new Promise((resolve, reject) => {\n    new EXRLoader()\n      .setPath('/hdr/')\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n        texture.mapping = THREE.EquirectangularReflectionMapping;\n        const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n        pmremGenerator.dispose();\n        texture.dispose();\n\n        console.log(\"環境貼圖已載入\");\n        scene.environment = envMap;\n        \n        // 更新主材質\n        if (material) {\n          material.envMap = envMap;\n          material.needsUpdate = true;\n        }\n        if (sphereMaterial) {\n          sphereMaterial.envMap = envMap;\n          sphereMaterial.needsUpdate = true;\n        }\n        \n        resolve(envMap);\n      }, undefined, (error) => {\n        console.error('無法載入環境貼圖:', error);\n        reject(error);\n      });\n  });\n}\n\n/**\n * 載入字體並創建文字\n */\nfunction loadFontAndCreateText() {\n  const ttfLoader = new TTFLoader();\n  const fontLoader = new FontLoader();\n\n  ttfLoader.load('/fonts/Orbitron-Regular.ttf', (json) => {\n    font = fontLoader.parse(json);\n    \n    // 儲存目標位置\n    textTargetPosition1 = new THREE.Vector3(-4, 0, -5);\n    textTargetPosition2 = new THREE.Vector3(4, 0, -5);\n    \n    // 創建第一個文字 - 初始位置為原點\n    textMesh1 = createText('Splash', new THREE.Vector3(1, 0, -5),'left', 1);\n    scene.add(textMesh1);\n    \n    // 創建第二個文字 - 初始位置為原點\n    textMesh2 = createText('DigiLab', new THREE.Vector3(-1, 0, -5),'right', 1);\n    scene.add(textMesh2);\n  });\n}\n\n/**\n * 創建文字物件\n */\nfunction createText(text, position, align, size = 0.5) {\n  const shapes = font.generateShapes(text, size);\n  const geometry = new THREE.ShapeGeometry(shapes);\n  geometry.computeBoundingBox();\n\n  // 使用物理材質替代基本材質，以便能夠被折射\n  const material = new THREE.MeshPhysicalMaterial({\n    color: 0x000000,\n    transparent: true,\n    opacity: 0,\n    transmission: 1,  // 輕微的透射性\n  });\n\n  const mesh = new THREE.Mesh(geometry, material);\n  const textWidth = geometry.boundingBox.max.x - geometry.boundingBox.min.x;\n  if(align === 'left'){\n    mesh.position.set(position.x - textWidth, position.y, position.z);\n    textOriginPosition1 = new THREE.Vector3(position.x - textWidth, position.y, position.z);\n  }else if(align === 'right'){\n    mesh.position.set(position.x , position.y, position.z);\n    textOriginPosition2 = new THREE.Vector3(position.x , position.y, position.z);\n  }\n  \n  // 提高文字的渲染優先順序，確保被正確渲染和折射\n  mesh.renderOrder = 1;\n  \n  return mesh;\n}\n\n/**\n * 文字從原點到目標位置的動畫\n */\nfunction animateTextToTargetPosition() {\n  if (!textMesh1 || !textMesh2 || !textTargetPosition1 || !textTargetPosition2) return;\n  \n  // 停止當前可能正在執行的動畫\n  gsap.killTweensOf(textMesh1.position);\n  gsap.killTweensOf(textMesh2.position);\n  gsap.killTweensOf(textMesh1.material);\n  gsap.killTweensOf(textMesh2.material);\n  \n  // 計算文字1的目標位置（考慮文字寬度）\n  const text1Width = textMesh1.geometry.boundingBox.max.x - textMesh1.geometry.boundingBox.min.x;\n  const targetPos1 = textTargetPosition1.clone();\n  targetPos1.x -= text1Width / 2;\n  \n  // 計算文字2的目標位置（考慮文字寬度）\n  const text2Width = textMesh2.geometry.boundingBox.max.x - textMesh2.geometry.boundingBox.min.x;\n  const targetPos2 = textTargetPosition2.clone();\n  targetPos2.x -= text2Width / 2;\n  \n  // 設置動畫參數\n  const duration = animParams.growSpeed;\n  \n  // 確保文字一開始是透明的\n  textMesh1.material.opacity = 0;\n  textMesh2.material.opacity = 0;\n  \n  // 文字1位置動畫\n  gsap.to(textMesh1.position, {\n    x: targetPos1.x,\n    y: targetPos1.y,\n    z: targetPos1.z,\n    duration: duration,\n    ease: \"customGrowEase\" // 使用已註冊的自定義緩動函數\n  });\n  \n  // 文字1透明度動畫\n  gsap.to(textMesh1.material, {\n    opacity: 1,\n    duration: duration, // 透明度變化稍快於位移，提前達到完全不透明\n    ease: \"customGrowEase\"\n  });\n  \n  // 文字2位置動畫\n  gsap.to(textMesh2.position, {\n    x: targetPos2.x,\n    y: targetPos2.y,\n    z: targetPos2.z,\n    duration: duration,\n    ease: \"customGrowEase\" // 使用已註冊的自定義緩動函數\n  });\n  \n  // 文字2透明度動畫\n  gsap.to(textMesh2.material, {\n    opacity: 1,\n    duration: duration, // 透明度變化稍快於位移，提前達到完全不透明\n    ease: \"customGrowEase\"\n  });\n}\n\n/**\n * 文字從目標位置回到原點的動畫\n */\nfunction animateTextToOrigin() {\n  if (!textMesh1 || !textMesh2) return;\n  \n  // 停止當前可能正在執行的動畫\n  gsap.killTweensOf(textMesh1.position);\n  gsap.killTweensOf(textMesh2.position);\n  gsap.killTweensOf(textMesh1.material);\n  gsap.killTweensOf(textMesh2.material);\n  \n  // 設置動畫參數\n  const duration = animParams.shrinkSpeed;\n  \n  // 文字1位置動畫\n  gsap.to(textMesh1.position, {\n    x: textOriginPosition1.x,\n    y: textOriginPosition1.y,\n    z: textOriginPosition1.z,\n    duration: duration,\n    ease: \"customShrinkEase\" // 使用已註冊的自定義緩動函數\n  });\n  \n  // 文字1透明度動畫\n  gsap.to(textMesh1.material, {\n    opacity: 0,\n    duration: duration, // 透明度變化稍快，提前完全透明\n    ease: \"customShrinkEase\"\n  });\n  \n  // 文字2位置動畫\n  gsap.to(textMesh2.position, {\n    x: textOriginPosition2.x,\n    y: textOriginPosition2.y,\n    z: textOriginPosition2.z,\n    duration: duration,\n    ease: \"customShrinkEase\" // 使用已註冊的自定義緩動函數\n  });\n  \n  // 文字2透明度動畫\n  gsap.to(textMesh2.material, {\n    opacity: 0,\n    duration: duration, // 透明度變化稍快，提前完全透明\n    ease: \"customShrinkEase\"\n  });\n}\n\n/**\n * 重新生成所有線條\n */\nfunction regenerateLine() {\n  if (!clock || !effect) return;\n  const currentTime = clock.getElapsedTime();\n  const totalLines = ttParams.numLines + thParams.numLines;\n\n  // 調整陣列大小\n  lineStartTimes.length = totalLines;\n  randomDirections.length = totalLines;\n  currentTargetLengths.length = totalLines;\n  lineTypes.length = totalLines;\n  lineFlowState.length = totalLines;\n\n  let lineIndex = 0;\n\n  // 生成由粗到細線條\n  for(let i = 0; i < ttParams.numLines; i++) {\n    if (!randomDirections[lineIndex]) {\n      randomDirections[lineIndex] = new THREE.Vector3();\n    }\n    randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(ttParams.minLength, ttParams.maxLength);\n    lineTypes[lineIndex] = 'tt';\n    lineStartTimes[lineIndex] = currentTime;\n    \n    // 設置初始流動狀態\n    if (globalFlowState) {\n      lineFlowState[lineIndex] = globalFlowState;\n    } else {\n      lineFlowState[lineIndex] = 'growing';\n    }\n    \n    lineIndex++;\n  }\n\n  // 生成由細到粗線條\n  for(let i = 0; i < thParams.numLines; i++) {\n    if (!randomDirections[lineIndex]) {\n      randomDirections[lineIndex] = new THREE.Vector3();\n    }\n    randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(thParams.minLength, thParams.maxLength);\n    lineTypes[lineIndex] = 'th';\n    lineStartTimes[lineIndex] = currentTime;\n    \n    // 設置初始流動狀態\n    if (globalFlowState) {\n      lineFlowState[lineIndex] = globalFlowState;\n    } else {\n      lineFlowState[lineIndex] = 'growing';\n    }\n    \n    lineIndex++;\n  }\n  effect.reset();\n}\n\n/**\n * 更新Metaball線條效果\n */\nfunction updateLineMetaball(obj) {\n  if (!clock) return;\n  obj.reset();\n  const currentTime = clock.getElapsedTime();\n  const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n  const totalLines = ttParams.numLines + thParams.numLines;\n\n  // 處理每條線的metaball效果\n  for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n    if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n      continue;\n    }\n\n    if (currentTargetLengths[lineIndex] === undefined) continue;\n    const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n    let localCurrentLength = 0;\n    let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n\n    // 計算當前線條長度\n    if (globalFlowState === 'pauseAtStart') {\n      // 在收合完成狀態下，線條仍可見但保持最短\n      localCurrentLength = 0.01; // 調大一點以確保可見流動效果\n    } else if (globalFlowState === 'pauseAtEnd') {\n      // 在生長完成狀態下，線條保持最長\n      localCurrentLength = localMaxLength;\n    } else if (globalFlowState === 'growing') {\n      // 生長狀態 - 使用 GSAP 控制的進度\n      if (localMaxLength > 0.001) {\n        const duration = animParams.growSpeed;\n        const progress = Math.min(timeSinceStart / duration, 1.0);\n        // 使用 GSAP 風格的 ease out\n        const easedTime = Math.pow(progress, animParams.growthEaseOutPower);\n        localCurrentLength = easedTime * localMaxLength;\n      } else {\n        localCurrentLength = 0;\n      }\n    } else if (globalFlowState === 'shrinking') {\n      // 收縮狀態 - 使用 GSAP 控制的進度\n      if (shrinkStartTime !== null && shrinkEndTime !== null) {\n        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n        const timeSinceShrinking = currentTime - shrinkStartTime;\n        const linearShrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n        // 使用收縮緩動參數\n        const shrinkProgress = Math.pow(linearShrinkProgress, animParams.shrinkEaseInPower);\n        const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n        \n        // 當開始收縮時，我們需要從當前長度開始收縮\n        const duration = animParams.growSpeed;\n        const growProgress = Math.min(timeSinceStart / duration, 1.0);\n        const easedGrowTime = Math.pow(growProgress, animParams.growthEaseOutPower);\n        const lengthBeforeShrinking = easedGrowTime * localMaxLength;\n        \n        // 從當前長度開始按比例收縮\n        localCurrentLength = lengthBeforeShrinking * shrinkFactor;\n      } else {\n        localCurrentLength = localMaxLength;\n      }\n    } else {\n      // 默認狀態 - 靜態展示\n      if (localMaxLength > 0.001) {\n        const duration = animParams.growSpeed;\n        const progress = Math.min(timeSinceStart / duration, 1.0);\n        const easedTime = Math.pow(progress, animParams.growthEaseOutPower);\n        localCurrentLength = easedTime * localMaxLength;\n      } else {\n        localCurrentLength = 0;\n      }\n    }\n    \n    // 如果線條過短則跳過\n    if (localCurrentLength <= 0.001) continue;\n\n    const currentDirection = randomDirections[lineIndex];\n    const currentLineType = lineTypes[lineIndex];\n    if (!currentDirection || !currentLineType) continue;\n\n    // 根據線條類型選擇參數\n    let lineStartStrength, lineEndStrength, lineShrinkPowerVal;\n    if (currentLineType === 'tt') {\n      lineStartStrength = ttParams.startStrength;\n      lineEndStrength = ttParams.endStrength;\n      lineShrinkPowerVal = ttParams.shrinkPower;\n    } else { // 'th'\n      lineStartStrength = thParams.startStrength;\n      lineEndStrength = thParams.endStrength;\n      lineShrinkPowerVal = thParams.shrinkPower;\n    }\n\n    // 計算Metaball強度和位置\n    for (let i = 0; i <= animParams.numSegments; i++) {\n      const segmentT = i / animParams.numSegments;\n      const strengthFactor = Math.pow(segmentT, lineShrinkPowerVal);\n      const baseStrength = THREE.MathUtils.lerp(lineStartStrength, lineEndStrength, strengthFactor);\n\n      // 添加波浪效果\n      let dynamicStrength = baseStrength;\n      // 永遠啟用波浪效果，不受狀態影響\n      let flowAmplitude;\n      // 根據狀態選擇不同的振幅因子\n      if (globalFlowState === 'pauseAtStart') {\n        // 當線條處於原點時，使用更大的波浪振幅\n        flowAmplitude = animParams.flowWaveAmplitudeFactorAtStart * baseStrength;\n      } else if (globalFlowState === 'shrinking' && localCurrentLength < 0.1) {\n        // 當線條收縮接近原點時，也使用較大的波浪振幅\n        // 根據收縮進度平滑過渡振幅\n        const transitionFactor = Math.max(0, Math.min(1, 10 * (0.1 - localCurrentLength)));\n        const normalAmplitude = animParams.flowWaveAmplitudeFactor * baseStrength;\n        const startAmplitude = animParams.flowWaveAmplitudeFactorAtStart * baseStrength;\n        flowAmplitude = normalAmplitude + transitionFactor * (startAmplitude - normalAmplitude);\n      } else {\n        // 其他狀態使用標準振幅\n        flowAmplitude = animParams.flowWaveAmplitudeFactor * baseStrength;\n      }\n      const flowOffset = Math.sin(currentTime * animParams.flowWaveFrequency - segmentT * animParams.flowWavePhaseFactor) * flowAmplitude;\n      dynamicStrength += flowOffset;\n      dynamicStrength = Math.max(dynamicStrength, 0);\n\n      // 設置球體位置\n      const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n      const finalPos = localPos.add(centerOffset);\n\n      // 添加Metaball\n      obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, animParams.subtract);\n    }\n  }\n\n  obj.update();\n}\n\n/**\n * 初始化所有球體\n */\nfunction initSpheres() {\n  // 清理現有球體\n  clearSpheres();\n  \n  // 建立球體群組\n  if (!sphereGroup) {\n    sphereGroup = new THREE.Group();\n    scene.add(sphereGroup);\n  }\n  \n  // 創建新球體\n  for (let i = 0; i < sphereParams.count; i++) {\n    // 隨機方向\n    const direction = new THREE.Vector3(\n      Math.random() * 2 - 1,\n      Math.random() * 2 - 1,\n      Math.random() * 2 - 1\n    ).normalize();\n    \n    // 隨機大小\n    const size = sphereParams.minRadius + Math.random() * (sphereParams.maxRadius - sphereParams.minRadius);\n    \n    // 創建球體\n    const sphere = createSphere(direction, size);\n    \n    // 設置目標長度 (與線條相似的範圍)\n    sphere.targetLength = THREE.MathUtils.randFloat(sphereParams.minLength, sphereParams.maxLength);\n  }\n}\n\n/**\n * 清理所有球體\n */\nfunction clearSpheres() {\n  // 從場景中移除所有球體並釋放資源\n  for (let i = 0; i < spheres.length; i++) {\n    const sphere = spheres[i];\n    \n    if (sphere.mesh) {\n      if (sphereGroup) {\n        sphereGroup.remove(sphere.mesh);\n      } else {\n        scene.remove(sphere.mesh);\n      }\n      sphere.mesh.geometry.dispose();\n    }\n  }\n  \n  // 清空陣列\n  spheres = [];\n  \n  // 清空群組\n  if (sphereGroup) {\n    scene.remove(sphereGroup);\n    sphereGroup = new THREE.Group();\n    scene.add(sphereGroup);\n  }\n}\n\n/**\n * 創建並發射一個球體\n */\nfunction createSphere(direction, size) {\n  const geometry = new THREE.SphereGeometry(size, sphereParams.segmentDetail, sphereParams.segmentDetail);\n  \n  // 使用共用材質\n  if (!sphereMaterial) {\n    sphereMaterial = generateMaterial();\n  }\n  \n  const sphere = new THREE.Mesh(geometry, sphereMaterial);\n  \n  // 設置初始位置為原點\n  sphere.position.set(0, 0, 0);\n  \n  // 儲存球體數據\n  const sphereData = {\n    mesh: sphere,\n    direction: direction,\n    targetLength: 0,                  // 將在更新時設置\n    initialScale: size,\n    active: true,\n    progress: 0,                      // 當前進度 (0-1)\n    currentPosition: 0,               // 當前位置長度\n    lastUpdateTime: clock ? clock.getElapsedTime() : 0,  // 上次更新時間\n    transitionStartTime: null,        // 轉換開始時間\n    transitionStartPos: 0             // 轉換開始位置\n  };\n  \n  // 添加到球體群組和球體陣列\n  sphereGroup.add(sphere);\n  spheres.push(sphereData);\n  \n  return sphereData;\n}\n\n/**\n * 更新球體位置和狀態\n */\nfunction updateSpheres() {\n  if (!clock) return;\n  \n  // 更新每個球體的可視屬性\n  for (let i = 0; i < spheres.length; i++) {\n    const sphere = spheres[i];\n    if (!sphere.active || !sphere.mesh) continue;\n    \n    // 計算球體在其本地座標系中的位置\n    const spherePosition = sphere.direction.clone().multiplyScalar(sphere.currentPosition);\n    sphere.mesh.position.copy(spherePosition);\n    \n    // 更新進度比例 (0-1)\n    sphere.progress = sphere.targetLength > 0 ? sphere.currentPosition / sphere.targetLength : 0;\n    \n    // 根據進度計算大小\n    let scale;\n    if (sphere.currentPosition < 0.01) {\n      scale = sphereParams.minScale; // 保持最小可見大小\n    } else {\n      // 根據距離計算大小，確保球體大小與位置成比例\n      const sizeProgress = Math.min(sphere.progress * 1.5, 1.0); // 略微加速大小變化\n      scale = sphereParams.minScale + (sphere.initialScale - sphereParams.minScale) * sizeProgress;\n    }\n    \n    sphere.mesh.scale.set(scale, scale, scale);\n  }\n}\n\n/**\n * 動畫主循環\n */\nfunction animate() {\n  animationFrameId = requestAnimationFrame(animate);\n\n  if (!effect || !material || !camera || !renderer || !scene || !controls) return;\n\n  // 更新場景邏輯\n  updateLineMetaball(effect);\n  \n  // 更新球體\n  updateSpheres();\n  \n  // 平滑過渡到目標旋轉角度\n  modelRotationX += (targetRotationX - modelRotationX) * 0.05;\n  modelRotationY += (targetRotationY - modelRotationY) * 0.05;\n  \n  // 應用旋轉到場景\n  effect.rotation.x = modelRotationX;\n  effect.rotation.y = modelRotationY;\n  if(isMobileDevice()){\n    effect.rotation.y += 0.0025;\n    if (sphereGroup) {\n      sphereGroup.rotation.y += 0.0025;\n    }\n  }\n  \n  // 更新 effect 和球體群組位置\n  effect.position.x = targetPositionX;\n  effect.position.y = targetPositionY;\n  \n  if (sphereGroup) {\n    sphereGroup.rotation.x = modelRotationX;\n    sphereGroup.rotation.y = modelRotationY;\n    sphereGroup.position.x = targetPositionX;\n    sphereGroup.position.y = targetPositionY;\n  }\n  \n  // 結合滑鼠控制和滾動位移的最終位置\n  scene.position.x = targetScrollOffsetX;\n  scene.position.y = targetScrollOffsetY;\n  scene.position.z = targetScrollOffsetZ;\n  \n  // 確保控制器始終更新 - 保持自動旋轉\n  controls.update();\n  \n  // 渲染場景\n  renderer.render(scene, camera);\n}\n\n/**\n * 處理視窗大小變化\n */\nfunction handleResize() {\n  if (!camera || !renderer) return;\n  const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n  const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n  renderer.setSize(width, height);\n}\n\n// =========================================\n// 7. 生命週期鉤子\n// =========================================\n\n/**\n * 初始化Three.js場景和相關物件\n */\nfunction initializeScene() {\n  if (!canvasContainer.value) {\n    console.error(\"Canvas container not found!\");\n    return false;\n  }\n  \n  const container = canvasContainer.value;\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n\n  // 場景\n  scene = new THREE.Scene();\n  scene.background = null;\n\n  // 相機\n  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  camera.position.set(0, 0, 30);\n  camera.lookAt(scene.position);\n\n  // 渲染器\n  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n  container.appendChild(renderer.domElement);\n\n  // 控制器\n  controls = new OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n\n  // 禁止縮放和平移，只允許旋轉\n  controls.enableZoom = false;     // 禁止縮放\n  controls.enablePan = false;      // 禁止平移\n  controls.enableRotate = false;\n  controls.minDistance = camera.position.length(); // 固定距離\n  controls.maxDistance = camera.position.length(); // 固定距離\n\n  // PMREMGenerator\n  pmremGenerator = new THREE.PMREMGenerator(renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  // 材質\n  material = generateMaterial();\n\n  // Marching Cubes\n  let resolution;\n  if (!isMobileDevice()){\n    resolution = animParams.resolution;\n  }else{\n    resolution = animParams.mobileResolution;\n  }\n  const derivedIsolation = resolution * 1.5;\n  effect = new MarchingCubes(resolution, material, true, true, 100000);\n  effect.isolation = derivedIsolation;\n  effect.scale.set(8, 8, 8);\n  effect.enableUvs = false;\n  effect.enableColors = false;\n  \n  // 設置線條的渲染順序，確保可以對文字進行折射\n  effect.renderOrder = 2;\n  \n  scene.add(effect);\n  \n  // 創建球體群組\n  sphereGroup = new THREE.Group();\n  // 設置球體群組的渲染順序\n  sphereGroup.renderOrder = 2;\n  scene.add(sphereGroup);\n\n  // 時鐘\n  clock = new THREE.Clock();\n  \n  // 初始化共用材質\n  sphereMaterial = generateMaterial();\n  \n  // 初始化滾動位移變量\n  targetScrollOffsetX = 0;\n  targetScrollOffsetY = 0;\n  targetScrollOffsetZ = 0;\n  \n  // 載入字體並創建文字\n  loadFontAndCreateText();\n\n  // 註冊自定義緩動函數（只註冊一次）\n  gsap.registerEase(\"customGrowEase\", function(x) {\n    return Math.pow(x, animParams.growthEaseOutPower);\n  });\n  \n  // 自定義緩動函數，完全匹配線條使用的 Math.pow(x, shrinkEaseInPower)\n  gsap.registerEase(\"customShrinkEase\", function(x) {\n    return Math.pow(x, animParams.shrinkEaseInPower);\n  });\n  \n  return true;\n}\n\n/**\n * 清理Three.js資源\n */\nfunction cleanupScene() {\n  // 停止動畫\n  cancelAnimationFrame(animationFrameId);\n\n  // 移除視窗大小變化監聽\n  window.removeEventListener('resize', handleResize);\n\n  // 重置滾動位移變量\n  targetScrollOffsetX = 0;\n  targetScrollOffsetY = 0;\n  targetScrollOffsetZ = 0;\n\n  // 清理球體\n  clearSpheres();\n\n  // 清理Three.js資源\n  if (controls) controls.dispose();\n  if (renderer) renderer.dispose();\n  if (material) {\n    material.dispose();\n    if (scene?.environment) scene.environment.dispose();\n  }\n  \n  if (effect) {\n    scene?.remove(effect);\n  }\n  \n  // 清理球體群組\n  if (sphereGroup) {\n    scene?.remove(sphereGroup);\n    sphereGroup = null;\n  }\n  \n  // 清理文字相關資源\n  textTargetPosition1 = null;\n  textTargetPosition2 = null;\n  textOriginPosition1 = null;\n  textOriginPosition2 = null;\n  \n  if (scene) {\n    // 清理場景中的物件\n    scene.traverse((object) => {\n      if (object instanceof THREE.Mesh) {\n        object.geometry?.dispose();\n        const objMaterial = object.material;\n        if (Array.isArray(objMaterial)) {\n          objMaterial.forEach((mat) => mat.dispose());\n        } else if (objMaterial) {\n          objMaterial.dispose();\n        }\n      }\n    });\n  }\n  \n  if (pmremGenerator) pmremGenerator.dispose();\n\n  // 移除畫布\n  if (canvasContainer.value && renderer) {\n    canvasContainer.value.removeChild(renderer.domElement);\n  }\n\n  // 清理球體材質\n  if (sphereMaterial) {\n    sphereMaterial.dispose();\n  }\n\n  // 清理文字物件\n  if (textMesh1) {\n    scene.remove(textMesh1);\n    textMesh1.geometry.dispose();\n    textMesh1.material.dispose();\n  }\n  if (textMesh2) {\n    scene.remove(textMesh2);\n    textMesh2.geometry.dispose();\n    textMesh2.material.dispose();\n  }\n\n  console.log(\"Three.js場景已清理\");\n}\n\n// =========================================\n// 8. 用戶互動控制\n// =========================================\n\n/**\n * 檢查是否為行動裝置\n */\nfunction isMobileDevice() {\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n}\n\n//開始生長動畫\nfunction startGrowingAnimation() {\n  if(globalFlowState=='growing' || globalFlowState=='pauseAtEnd') return;\n  if (delayedStateUpdateId !== null) {\n    gsap.killTweensOf(delayedStateUpdateId);\n    delayedStateUpdateId = null;\n  }\n  globalFlowState = 'growing';\n  startSyncGrowing();\n}\n\n//開始收合動畫\nfunction startShrinkingAnimation() {\n  if(globalFlowState=='shrinking' || globalFlowState=='pauseAtStart') return;\n  \n  if (delayedStateUpdateId !== null) {\n    gsap.killTweensOf(delayedStateUpdateId);\n    delayedStateUpdateId = null;\n  }\n\n  globalFlowState = 'shrinking';\n  startSyncShrinking();\n}\n\n/**\n * 初始化為收合狀態\n */\nfunction initializeCollapsedState() {\n  // 設置全局狀態為收合完成\n  updateFlowState('pauseAtStart');\n  \n  // 初始線條生成（但保持最小長度）\n  regenerateLine();\n  \n  // 初始化球體\n  initSpheres();\n  \n  // 設置所有線條狀態為初始狀態\n  const totalLines = ttParams.numLines + thParams.numLines;\n  for (let i = 0; i < totalLines; i++) {\n    if (lineFlowState[i] === undefined) continue;\n    lineFlowState[i] = 'pauseAtStart';\n  }\n  \n  console.log(\"初始化完成：線條收合狀態\");\n}\n\n// 當狀態改變時通知父組件\nfunction updateFlowState(newState) {\n  globalFlowState = newState;\n  emit('stateChange', newState);\n  \n  // 檢查是否完成特定狀態，通知父組件\n  if (newState === 'pauseAtEnd') {\n    console.log(\"所有線條已生長完成，暫停動畫\");\n    emit('animationComplete', 'growing');\n  } else if (newState === 'pauseAtStart') {\n    console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n    emit('animationComplete', 'shrinking');\n  }\n}\n\n/**\n * 開始同步生長所有線條\n */\nfunction startSyncGrowing() {\n  if (!clock) return;\n  const currentTime = clock.getElapsedTime();\n  const totalLines = ttParams.numLines + thParams.numLines;\n  \n  console.log(\"所有線條同步生長\");\n  \n  // 確保球體已初始化\n  if (spheres.length === 0) {\n    initSpheres();\n  }\n  \n  // 清除所有現有的 GSAP 動畫和延遲回調\n  gsap.killTweensOf(spheres);\n  if (delayedStateUpdateId !== null) {\n    gsap.killTweensOf(delayedStateUpdateId);\n    delayedStateUpdateId = null;\n  }\n  \n  // 更新全局狀態\n  updateFlowState('growing');\n  growStartTime = currentTime;\n  \n  // 設置生長動畫時間\n  const growDuration = animParams.growSpeed;\n  \n  // 使用 GSAP 控制球體動畫\n  for (let i = 0; i < spheres.length; i++) {\n    const sphere = spheres[i];\n    if (sphere.mesh) {\n      // 記錄起始位置\n      sphere.transitionStartTime = currentTime;\n      sphere.transitionStartPos = sphere.currentPosition;\n      \n      // 使用自定義緩動函數\n      gsap.to(sphere, {\n        currentPosition: sphere.targetLength,\n        duration: growDuration,\n        ease: \"customGrowEase\",\n        onUpdate: function() {\n          // 確保狀態一致\n          if (globalFlowState !== 'growing' && globalFlowState !== 'pauseAtEnd') {\n            sphere.currentPosition = sphere.targetLength;\n          }\n        },\n        onComplete: function() {\n          // 確保完全到位\n          sphere.currentPosition = sphere.targetLength;\n        }\n      });\n    }\n  }\n  \n  // 重置所有線條的方向和長度\n  for (let i = 0; i < totalLines; i++) {\n    if (lineStartTimes[i] === undefined) continue;\n    \n    // 重新生成隨機方向\n    if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n    randomDirections[i]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    \n    // 更新線條類型和長度\n    lineTypes[i] = (i < ttParams.numLines) ? 'tt' : 'th';\n    const minL = (lineTypes[i] === 'tt') ? ttParams.minLength : thParams.minLength;\n    const maxL = (lineTypes[i] === 'tt') ? ttParams.maxLength : thParams.maxLength;\n    currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n    \n    // 更新線條狀態\n    lineStartTimes[i] = currentTime;\n    lineFlowState[i] = 'growing';\n  }\n  \n  // 在線條預計完成生長時更新全局狀態\n  delayedStateUpdateId = { id: \"stateUpdate\" };\n  gsap.to(delayedStateUpdateId, {\n    id: \"stateUpdate\", \n    duration: growDuration,\n    onComplete: function() {\n      updateFlowState('pauseAtEnd');\n      delayedStateUpdateId = null;\n    }\n  });\n}\n\n/**\n * 開始同步收合所有線條\n */\nfunction startSyncShrinking() {\n  if (!clock) return;\n  const currentTime = clock.getElapsedTime();\n  \n  console.log(\"所有線條同步收合\");\n  \n  // 清除所有現有的 GSAP 動畫和延遲回調\n  gsap.killTweensOf(spheres);\n  if (delayedStateUpdateId !== null) {\n    gsap.killTweensOf(delayedStateUpdateId);\n    delayedStateUpdateId = null;\n  }\n  \n  // 更新全局狀態\n  updateFlowState('shrinking');\n  \n  // 設置收合時間\n  shrinkStartTime = currentTime;\n  \n  // 使用 GSAP 設置收合動畫\n  const shrinkDuration = animParams.shrinkSpeed;\n  \n  // 設置結束時間（為了兼容現有代碼）\n  shrinkEndTime = currentTime + shrinkDuration;\n  \n  // 為每個球體設置收縮動畫\n  for (let i = 0; i < spheres.length; i++) {\n    const sphere = spheres[i];\n    if (sphere.mesh) {\n      // 記錄起始位置\n      sphere.transitionStartTime = currentTime;\n      sphere.transitionStartPos = sphere.currentPosition;\n      \n      // 使用 GSAP 直接為每個球體設置收縮動畫\n      gsap.to(sphere, {\n        currentPosition: 0,\n        duration: shrinkDuration,\n        ease: \"customShrinkEase\",\n        onUpdate: function() {\n          // 確保狀態一致\n          if (globalFlowState !== 'shrinking' && globalFlowState !== 'pauseAtStart') {\n            sphere.currentPosition = 0;\n          }\n        },\n        onComplete: function() {\n          // 確保完全歸零\n          sphere.currentPosition = 0;\n        }\n      });\n    }\n  }\n  \n  // 保持現有線條方向和目標長度，只更新起始時間\n  const totalLines = ttParams.numLines + thParams.numLines;\n  for (let i = 0; i < totalLines; i++) {\n    if (lineStartTimes[i] === undefined) continue;\n    // 更新線條狀態和時間，但保持當前方向和目標長度\n    lineFlowState[i] = 'shrinking';\n  }\n  \n  // 在線條預計完成收縮時更新全局狀態\n  delayedStateUpdateId = { id: \"stateUpdate\" };\n  gsap.to(delayedStateUpdateId, {\n    id: \"stateUpdate\",\n    duration: shrinkDuration,\n    onComplete: function() {\n      updateFlowState('pauseAtStart');\n      delayedStateUpdateId = null;\n    }\n  });\n}\n\n/**\n * 添加滑鼠控制事件\n */\nfunction addMouseControlEvents() {\n  const container = canvasContainer.value;\n  if (!container) return;\n  \n  // 只有在非行動裝置上才添加滑鼠控制\n  if (!isMobileDevice()) {\n    console.log('啟用桌面滑鼠控制');\n    window.addEventListener('mousemove', onMouseMove);\n  } else {\n    console.log('行動裝置，不啟用滑鼠控制');\n  }\n}\n\n/**\n * 移除滑鼠控制事件\n */\nfunction removeMouseControlEvents() {\n  const container = canvasContainer.value;\n  if (!container) return;\n  \n  // 無論是否為行動裝置，都應移除事件以防止內存洩漏\n  window.removeEventListener('mousemove', onMouseMove);\n}\n\n/**\n * 滑鼠移動事件處理\n */\nfunction onMouseMove(event) {\n  // 如果是行動裝置，則直接返回不處理\n  if (isMobileDevice()) return;\n  \n  // 計算滑鼠與視窗中心的偏移\n  const centerX = window.innerWidth / 2;\n  const centerY = window.innerHeight / 2;\n  \n  // 計算偏移並加上減速因子使移動不那麼劇烈\n  const offsetX = (event.clientX - centerX) * 0.001;\n  const offsetY = (event.clientY - centerY) * 0.001;\n  \n  // 更新目標位置 (使偏移更小以獲得更細膩的移動)\n  targetPositionX = offsetX;\n  targetPositionY = -offsetY; // 負值使移動方向與滑鼠一致\n  \n  // 更新目標旋轉角度 (滑鼠水平移動控制Y軸旋轉，垂直移動控制X軸旋轉)\n  // 使用百分比計算以適應不同螢幕尺寸\n  targetRotationY = (event.clientX / window.innerWidth - 0.5) * Math.PI * 2;\n  targetRotationX = (event.clientY / window.innerHeight - 0.5) * Math.PI * 2;\n  \n  // 限制旋轉範圍\n  targetRotationX = Math.max(-Math.PI, Math.min(Math.PI, targetRotationX));\n  targetRotationY = Math.max(-Math.PI, Math.min(Math.PI, targetRotationY));\n}\n\nonMounted(() => {\n  // 初始化場景\n  if (!initializeScene()) return;\n\n  // 開始動畫循環（但不啟動流動）\n  animate();\n  \n  // 載入環境貼圖\n  loadEnvironmentMap().then(() => {\n    console.log('環境貼圖載入完成');\n    \n    // 初始化為收合狀態\n    initializeCollapsedState();\n    \n    // 通知父組件資源已載入\n    emit('resourcesLoaded', true);\n    \n  }).catch(error => {\n    console.error('環境貼圖載入失敗:', error);\n  });\n\n  // 監聽視窗大小變化\n  window.addEventListener('resize', handleResize);\n});\n\nonUnmounted(() => {\n  cleanupScene();\n\n  // 移除滑鼠控制事件\n  removeMouseControlEvents();\n});\n\n// 暴露方法給父組件\ndefineExpose({\n  startGrowingAnimation,\n  startShrinkingAnimation,\n  addMouseControlEvents,\n  updatePosition,\n  animateTextToTargetPosition,\n  animateTextToOrigin\n});\n\n/**\n * 根據滾動位置更新模型位置\n */\nfunction updatePosition(xOffset, yOffset, zOffset) {\n  if (!scene) return;\n  \n  // 設置目標滾動位移，animate 函數會平滑過渡到這些值\n  targetScrollOffsetX = xOffset;\n  targetScrollOffsetY = -yOffset;\n  targetScrollOffsetZ = zOffset;\n  \n  console.log(`更新滾動位移: x=${xOffset}, y=${yOffset}, z=${zOffset}`);\n}\n</script>"],"names":[],"mappings":";;;;;;;;;;;;;;AA2BM,UAAA,kBAAkB,IAAI,IAAI;AAGf,aAAS;AAAA,MACxB,eAAe;AAAA;AAAA,MACf,aAAa;AAAA;AAAA,MACb,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA,IACX,CAAA;AAEgB,aAAS;AAAA,MACxB,eAAe;AAAA;AAAA,MACf,aAAa;AAAA;AAAA,MACb,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA,IACX,CAAA;AAGoB,aAAS;AAAA,MAC5B,OAAO;AAAA;AAAA,MACP,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,eAAe;AAAA;AAAA,MACf,UAAU;AAAA;AAAA,IACX,CAAA;AAGkB,aAAS;AAAA;AAAA,MAE1B,kBAAkB;AAAA,MAClB,YAAY;AAAA;AAAA,MACZ,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA;AAAA,MAGV,WAAW;AAAA;AAAA,MACX,oBAAoB;AAAA;AAAA,MACpB,aAAa;AAAA;AAAA,MACb,mBAAmB;AAAA;AAAA;AAAA,MAGnB,mBAAmB;AAAA;AAAA,MACnB,yBAAyB;AAAA;AAAA,MACzB,gCAAgC;AAAA;AAAA,MAChC,qBAAqB,KAAK,KAAK;AAAA;AAAA,IAChC,CAAA;AA6CD,QAAI,kBAAkB;AA+HtB,aAAS,8BAA8B;AACyC;AAAA,IAuD7E;AAMH,aAAS,sBAAsB;AACC;AAAA,IAyC7B;AAskBH,aAAS,iBAAiB;AACjB,aAAA,iEAAiE,KAAK,SAAU,SAAS;AAAA,IAAA;AAIlG,aAAS,wBAAwB;AAC5B,UAAA,mBAAiB,aAAa,mBAAiB,aAAc;AAK9C,wBAAA;AAAA,IACD;AAInB,aAAS,0BAA0B;AAC9B,UAAA,mBAAiB,eAAe,mBAAiB,eAAgB;AAOlD,wBAAA;AAAA,IACC;AA8MrB,aAAS,wBAAwB;AAC/B,YAAM,YAAY,gBAAgB;AAClC,UAAI,CAAC,UAAW;AAGZ,UAAA,CAAC,kBAAkB;AACrB,gBAAQ,IAAI,UAAU;AACf,QAAA,SAAA,iBAAiB,aAAa,WAAW;AAAA,MAAA,OAC3C;AACL,gBAAQ,IAAI,cAAc;AAAA,MAAA;AAAA,IAC5B;AAiBF,aAAS,YAAY,OAAO;AAE1B,UAAI,iBAAkB;AAGhB,YAAA,mBAAiB,aAAa;AAC9B,YAAA,mBAAiB,cAAc;AAG/B,OAAW,MAAM,UAAU,WAAW;AACtC,OAAW,MAAM,UAAU,WAAW;AAQ5C,OAAmB,MAAM,UAAU,SAAO,aAAa,OAAO,KAAK,KAAK;AACxE,OAAmB,MAAM,UAAU,SAAO,cAAc,OAAO,KAAK,KAAK;AAAA,IAIF;AAoC5D,aAAA;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAKQ,aAAA,eAAe,SAAS,SAAS,SAAS;AACrC;AAAA,IAOkD;;;;;;;;;;;;"}