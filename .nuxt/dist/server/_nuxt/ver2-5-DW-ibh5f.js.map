{"version":3,"file":"ver2-5-DW-ibh5f.js","sources":["../../../../components/Splash1.vue","../../../../pages/ver2-5.vue"],"sourcesContent":["<template>\n  <div class=\"splash-container\">\n    <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n  </div>\n</template>\n\n<script setup>\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// 父組件事件\nconst emit = defineEmits([\n  'stateChange',       // 狀態變化事件\n  'animationComplete', // 動畫完成事件\n  'resourcesLoaded'    // 資源載入完成事件\n]);\n\n// =========================================\n// 1. 響應式狀態和參數配置\n// =========================================\n\n// --- Core Refs ---\nconst canvasContainer = ref(null);\n\n// --- UI 狀態 ---\nconst isPlaying = ref(false);\n\n// --- 線條參數配置 ---\nconst ttParams = reactive({\n  startStrength: 0.1,    // 粗到細線條：起始端粗度\n  endStrength: 0.01,     // 粗到細線條：末端粗度\n  minLength: 2.5,        // 粗到細線條：最小長度\n  maxLength: 3.5,        // 粗到細線條：最大長度\n  shrinkPower: 0.25,     // 粗到細線條：粗細變化曲線指數\n  numLines: 4            // 粗到細線條：數量\n});\n\nconst thParams = reactive({\n  startStrength: 0.01,   // 細到粗線條：起始端粗度\n  endStrength: 0.1,      // 細到粗線條：末端粗度\n  minLength: 2,          // 細到粗線條：最小長度\n  maxLength: 3,          // 細到粗線條：最大長度\n  shrinkPower: 1.25,     // 細到粗線條：粗細變化曲線指數\n  numLines: 3            // 細到粗線條：數量\n});\n\n// --- 流動動畫參數 ---\nconst animParams = reactive({\n  // 基本設定\n  resolution: 200,                // Marching Cubes 解析度\n  growthSpeed: 5.0,               // 線條生長速度\n  growthEaseOutPower: 0.15,       // 生長緩動指數\n  numSegments: 50,                // 每條線分段數量\n  subtract: 20,                   // Metaball 減法參數\n  \n  // 流動效果設定\n  flowGrowthSpeedFactor: 0.1,\n  flowWaveAmplitudeFactorAtStart: 1,     // 原點狀態的波浪振幅因子\n  flowShrinkDurationFactor: 0.2,  // 流動模式下的收縮持續時間因子\n  baseShrinkDuration: 3.0,        // 基本收縮持續時間 (秒)\n  \n  // 波浪效果設定\n  flowWaveFrequency: 1.0,         // 波浪頻率\n  flowWaveAmplitudeFactor: 0.15,  // 波浪振幅因子\n  flowWavePhaseFactor: Math.PI * 4, // 波浪相位因子\n});\n\n// =========================================\n// 2. Three.js 核心物件和狀態\n// =========================================\n\n// --- Three.js 核心物件 ---\nlet scene = null;\nlet camera = null;\nlet renderer = null;\nlet controls = null;\nlet effect = null;\nlet clock = null;\nlet material = null;\nlet pmremGenerator = null;\nlet animationFrameId = null;\n\n// --- 線條數據 ---\nlet lineStartTimes = [];      // 每條線的開始時間\nlet randomDirections = [];    // 每條線的隨機方向向量\nlet currentTargetLengths = []; // 每條線的目標長度\nlet lineTypes = [];           // 每條線的類型 ('tt' 或 'th')\nlet lineFlowState = [];       // 每條線的流動狀態\n\n// --- 流動控制狀態 ---\nlet shrinkStartTime = null;   // 收合開始時間\nlet shrinkEndTime = null;     // 收合結束時間\nlet growStartTime = null;     // 生長開始時間\nlet globalFlowState = 'idle'; // 全局流動狀態\n\n// =========================================\n// 3. 材質和環境設定\n// =========================================\n\n/**\n * 生成液體材質\n */\nfunction generateMaterial() {\n  return new THREE.MeshPhysicalMaterial({\n    color: 0xffffff,\n    metalness: 0,\n    roughness: 0,\n    transparent: true,\n    opacity: 0.75,\n    transmission: 1,   // 增加透光性\n    ior: 1.5,          // 折射率\n    thickness: 1.0,    // 材質厚度\n    envMapIntensity: 300.0,\n    side: THREE.DoubleSide\n  });\n}\n\n/**\n * 載入環境貼圖\n */\nfunction loadEnvironmentMap() {\n  return new Promise((resolve, reject) => {\n    new EXRLoader()\n      .setPath('/hdr/')\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n        texture.mapping = THREE.EquirectangularReflectionMapping;\n        const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n        pmremGenerator.dispose();\n        texture.dispose();\n\n        console.log(\"環境貼圖已載入\");\n        scene.environment = envMap;\n        if (material) {\n          material.envMap = envMap;\n          material.needsUpdate = true;\n        }\n        resolve(envMap);\n      }, undefined, (error) => {\n        console.error('無法載入環境貼圖:', error);\n        reject(error);\n      });\n  });\n}\n\n// =========================================\n// 4. 線條和動畫控制\n// =========================================\n\n/**\n * 重新生成所有線條\n */\nfunction regenerateLine() {\n  if (!clock || !effect) return;\n  const currentTime = clock.getElapsedTime();\n  const totalLines = ttParams.numLines + thParams.numLines;\n\n  // 調整陣列大小\n  lineStartTimes.length = totalLines;\n  randomDirections.length = totalLines;\n  currentTargetLengths.length = totalLines;\n  lineTypes.length = totalLines;\n  lineFlowState.length = totalLines;\n\n  let lineIndex = 0;\n\n  // 生成由粗到細線條\n  for(let i = 0; i < ttParams.numLines; i++) {\n    if (!randomDirections[lineIndex]) {\n      randomDirections[lineIndex] = new THREE.Vector3();\n    }\n    randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(ttParams.minLength, ttParams.maxLength);\n    lineTypes[lineIndex] = 'tt';\n    lineStartTimes[lineIndex] = currentTime;\n    \n    // 設置初始流動狀態\n    if (globalFlowState) {\n      lineFlowState[lineIndex] = globalFlowState;\n    } else {\n      lineFlowState[lineIndex] = 'growing';\n    }\n    \n    lineIndex++;\n  }\n\n  // 生成由細到粗線條\n  for(let i = 0; i < thParams.numLines; i++) {\n    if (!randomDirections[lineIndex]) {\n      randomDirections[lineIndex] = new THREE.Vector3();\n    }\n    randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(thParams.minLength, thParams.maxLength);\n    lineTypes[lineIndex] = 'th';\n    lineStartTimes[lineIndex] = currentTime;\n    \n    // 設置初始流動狀態\n    if (globalFlowState) {\n      lineFlowState[lineIndex] = globalFlowState;\n    } else {\n      lineFlowState[lineIndex] = 'growing';\n    }\n    \n    lineIndex++;\n  }\n  effect.reset();\n}\n\n/**\n * 更新Metaball線條效果\n */\nfunction updateLineMetaball(obj) {\n  if (!clock) return;\n  obj.reset();\n  const currentTime = clock.getElapsedTime();\n  const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n  const totalLines = ttParams.numLines + thParams.numLines;\n\n  // 更新全局流動狀態\n  updateGlobalFlowState(currentTime);\n\n  // 處理每條線的metaball效果\n  for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n    if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n      continue;\n    }\n\n    if (currentTargetLengths[lineIndex] === undefined) continue;\n    const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n    let localCurrentLength = 0;\n    let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n\n    // 計算當前線條長度\n    if (globalFlowState === 'pauseAtStart') {\n      // 在收合完成狀態下，線條仍可見但保持最短\n      localCurrentLength = 0.05; // 調大一點以確保可見流動效果\n    } else if (globalFlowState === 'pauseAtEnd') {\n      // 在生長完成狀態下，線條保持最長\n      localCurrentLength = localMaxLength;\n    } else if (globalFlowState === 'growing') {\n      // 生長狀態\n      if (localMaxLength > 0.001) {\n        const currentGrowthSpeed = animParams.growthSpeed * animParams.flowGrowthSpeedFactor;\n        const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n        const easedTime = Math.pow(normalizedTime, animParams.growthEaseOutPower);\n        localCurrentLength = easedTime * localMaxLength;\n      } else {\n        localCurrentLength = 0;\n      }\n    } else if (globalFlowState === 'shrinking') {\n      // 收縮狀態\n      if (shrinkStartTime !== null && shrinkEndTime !== null) {\n        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n        const timeSinceShrinking = currentTime - shrinkStartTime;\n        const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n        const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n        \n        // 當按下return開始收縮時，我們需要從當前長度開始收縮\n        const currentGrowthSpeed = animParams.growthSpeed * animParams.flowGrowthSpeedFactor;\n        const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n        const easedTime = Math.pow(normalizedTime, animParams.growthEaseOutPower);\n        const lengthBeforeShrinking = easedTime * localMaxLength;\n        \n        // 從當前長度開始按比例收縮\n        localCurrentLength = lengthBeforeShrinking * shrinkFactor;\n      } else {\n        localCurrentLength = localMaxLength;\n      }\n    } else {\n      // 默認狀態 - 靜態展示\n      if (localMaxLength > 0.001) {\n        const normalizedTime = Math.min(timeSinceStart / (localMaxLength / (animParams.growthSpeed / obj.scale.x)), 1.0);\n        const easedTime = Math.pow(normalizedTime, animParams.growthEaseOutPower);\n        localCurrentLength = easedTime * localMaxLength;\n      } else {\n        localCurrentLength = 0;\n      }\n    }\n    \n    // 如果線條過短則跳過\n    if (localCurrentLength <= 0.001) continue;\n\n    const currentDirection = randomDirections[lineIndex];\n    const currentLineType = lineTypes[lineIndex];\n    if (!currentDirection || !currentLineType) continue;\n\n    // 根據線條類型選擇參數\n    let lineStartStrength, lineEndStrength, lineShrinkPowerVal;\n    if (currentLineType === 'tt') {\n      lineStartStrength = ttParams.startStrength;\n      lineEndStrength = ttParams.endStrength;\n      lineShrinkPowerVal = ttParams.shrinkPower;\n    } else { // 'th'\n      lineStartStrength = thParams.startStrength;\n      lineEndStrength = thParams.endStrength;\n      lineShrinkPowerVal = thParams.shrinkPower;\n    }\n\n    // 計算Metaball強度和位置\n    for (let i = 0; i <= animParams.numSegments; i++) {\n      const segmentT = i / animParams.numSegments;\n      const strengthFactor = Math.pow(segmentT, lineShrinkPowerVal);\n      const baseStrength = THREE.MathUtils.lerp(lineStartStrength, lineEndStrength, strengthFactor);\n\n      // 添加波浪效果\n      let dynamicStrength = baseStrength;\n      // 永遠啟用波浪效果，不受狀態影響\n      let flowAmplitude;\n      if (globalFlowState === 'pauseAtStart') {\n        // 當線條處於原點時，使用更大的波浪振幅\n        flowAmplitude = animParams.flowWaveAmplitudeFactorAtStart * baseStrength;\n      } else {\n        // 其他狀態使用標準振幅\n        flowAmplitude = animParams.flowWaveAmplitudeFactor * baseStrength;\n      }\n      const flowOffset = Math.sin(currentTime * animParams.flowWaveFrequency - segmentT * animParams.flowWavePhaseFactor) * flowAmplitude;\n      dynamicStrength += flowOffset;\n      dynamicStrength = Math.max(dynamicStrength, 0);\n\n      // 設置球體位置\n      const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n      const finalPos = localPos.add(centerOffset);\n\n      // 添加Metaball\n      obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, animParams.subtract);\n    }\n  }\n\n  obj.update();\n}\n\n// =========================================\n// 5. 流動狀態控制\n// =========================================\n\n/**\n * 更新全局流動狀態\n */\nfunction updateGlobalFlowState(currentTime) {\n  if (!clock) return;\n  \n  // 檢查當前時間和設定的時間節點\n  if (globalFlowState === 'growing' && growStartTime !== null) {\n    // 計算所有線條的平均生長完成度\n    const totalLines = ttParams.numLines + thParams.numLines;\n    let totalGrowthProgress = 0;\n    let activeLines = 0;\n    \n    for (let i = 0; i < totalLines; i++) {\n      if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n      \n      activeLines++;\n      const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n      const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n      const currentGrowthSpeed = animParams.growthSpeed * animParams.flowGrowthSpeedFactor;\n      const linearDuration = localMaxLength / (currentGrowthSpeed / (effect?.scale.x || 1));\n      const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n      \n      totalGrowthProgress += growthProgress;\n    }\n    \n    const averageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n    \n    // 當平均生長進度達到99%以上，切換到暫停狀態\n    if (averageProgress >= 0.99) {\n      updateFlowState('pauseAtEnd');\n    }\n  } else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n    // 檢查是否達到收合結束時間\n    if (currentTime >= shrinkEndTime) {\n      updateFlowState('pauseAtStart');\n    }\n  }\n}\n\n/**\n * 開始同步收合所有線條\n */\nfunction startSyncShrinking() {\n  if (!clock) return;\n  const currentTime = clock.getElapsedTime();\n  \n  console.log(\"所有線條同步收合\");\n  \n  // 更新全局狀態\n  updateFlowState('shrinking');\n  \n  // 設置收合時間\n  shrinkStartTime = currentTime;\n  shrinkEndTime = currentTime + animParams.baseShrinkDuration * animParams.flowShrinkDurationFactor;\n  \n  // 保持現有線條方向和目標長度，只更新起始時間\n  const totalLines = ttParams.numLines + thParams.numLines;\n  for (let i = 0; i < totalLines; i++) {\n    if (lineStartTimes[i] === undefined) continue;\n    // 更新線條狀態和時間，但保持當前方向和目標長度\n    lineFlowState[i] = 'shrinking';\n  }\n}\n\n/**\n * 開始同步生長所有線條\n */\nfunction startSyncGrowing() {\n  if (!clock) return;\n  const currentTime = clock.getElapsedTime();\n  const totalLines = ttParams.numLines + thParams.numLines;\n  \n  console.log(\"所有線條同步生長\");\n  \n  // 更新全局狀態\n  updateFlowState('growing');\n  growStartTime = currentTime;\n  \n  // 重置所有線條的方向和長度\n  for (let i = 0; i < totalLines; i++) {\n    if (lineStartTimes[i] === undefined) continue;\n    \n    // 重新生成隨機方向\n    if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n    randomDirections[i]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    \n    // 更新線條類型和長度\n    lineTypes[i] = (i < ttParams.numLines) ? 'tt' : 'th';\n    const minL = (lineTypes[i] === 'tt') ? ttParams.minLength : thParams.minLength;\n    const maxL = (lineTypes[i] === 'tt') ? ttParams.maxLength : thParams.maxLength;\n    currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n    \n    // 更新線條狀態\n    lineStartTimes[i] = currentTime;\n    lineFlowState[i] = 'growing';\n  }\n}\n\n// =========================================\n// 6. 動畫和渲染\n// =========================================\n\n/**\n * 動畫主循環\n */\nfunction animate() {\n  animationFrameId = requestAnimationFrame(animate);\n\n  if (!effect || !material || !camera || !renderer || !scene || !controls) return;\n\n  // 更新場景邏輯\n  updateLineMetaball(effect);\n  \n  // 確保控制器始終更新 - 保持自動旋轉\n  controls.update();\n  \n  // 渲染場景\n  renderer.render(scene, camera);\n}\n\n/**\n * 處理視窗大小變化\n */\nfunction handleResize() {\n  if (!camera || !renderer) return;\n  const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n  const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n  renderer.setSize(width, height);\n}\n\n// =========================================\n// 7. 生命週期鉤子\n// =========================================\n\n/**\n * 初始化Three.js場景和相關物件\n */\nfunction initializeScene() {\n  if (!canvasContainer.value) {\n    console.error(\"Canvas container not found!\");\n    return false;\n  }\n  \n  const container = canvasContainer.value;\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n\n  // 場景\n  scene = new THREE.Scene();\n  scene.background = null;\n\n  // 相機\n  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  camera.position.set(0, 0, 30);\n  camera.lookAt(scene.position);\n\n  // 渲染器\n  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n  container.appendChild(renderer.domElement);\n\n  // 控制器\n  controls = new OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.autoRotate = true; // 永遠啟用自動旋轉\n  controls.autoRotateSpeed = 2.0;\n\n  // PMREMGenerator\n  pmremGenerator = new THREE.PMREMGenerator(renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  // 材質\n  material = generateMaterial();\n\n  // Marching Cubes\n  const derivedIsolation = animParams.resolution * 1.5;\n  effect = new MarchingCubes(animParams.resolution, material, true, true, 100000);\n  effect.isolation = derivedIsolation;\n  effect.scale.set(8, 8, 8);\n  effect.enableUvs = false;\n  effect.enableColors = false;\n  scene.add(effect);\n\n  // 時鐘\n  clock = new THREE.Clock();\n  \n  return true;\n}\n\n/**\n * 清理Three.js資源\n */\nfunction cleanupScene() {\n  // 停止動畫\n  cancelAnimationFrame(animationFrameId);\n\n  // 移除視窗大小變化監聽\n  window.removeEventListener('resize', handleResize);\n\n  // 清理Three.js資源\n  if (controls) controls.dispose();\n  if (renderer) renderer.dispose();\n  if (material) {\n    material.dispose();\n    if (scene?.environment) scene.environment.dispose();\n  }\n  \n  if (effect) {\n    scene?.remove(effect);\n  }\n  \n  if (scene) {\n    // 清理場景中的物件\n    scene.traverse((object) => {\n      if (object instanceof THREE.Mesh) {\n        object.geometry?.dispose();\n        const objMaterial = object.material;\n        if (Array.isArray(objMaterial)) {\n          objMaterial.forEach((mat) => mat.dispose());\n        } else if (objMaterial) {\n          objMaterial.dispose();\n        }\n      }\n    });\n  }\n  \n  if (pmremGenerator) pmremGenerator.dispose();\n\n  // 移除畫布\n  if (canvasContainer.value && renderer) {\n    canvasContainer.value.removeChild(renderer.domElement);\n  }\n\n  console.log(\"Three.js場景已清理\");\n}\n\n// =========================================\n// 8. 用戶互動控制\n// =========================================\n\n/**\n * 開始生長動畫\n */\nfunction startGrowingAnimation() {\n  // 不管當前是什麼狀態，直接切換到生長狀態\n  if(isPlaying.value == false) {\n    isPlaying.value = true;\n    globalFlowState = 'growing';\n    startSyncGrowing();\n  }\n}\n\n/**\n * 開始收合動畫\n */\nfunction startShrinkingAnimation() {\n  // 不管當前是什麼狀態，直接切換到收合狀態\n  if(isPlaying.value == true) {\n    isPlaying.value = false;\n    globalFlowState = 'shrinking';\n    startSyncShrinking();\n  }\n}\n\n/**\n * 初始化為收合狀態\n */\nfunction initializeCollapsedState() {\n  // 設置全局狀態為收合完成\n  updateFlowState('pauseAtStart');\n  \n  // 初始線條生成（但保持最小長度）\n  regenerateLine();\n  \n  // 設置所有線條狀態為初始狀態\n  const totalLines = ttParams.numLines + thParams.numLines;\n  for (let i = 0; i < totalLines; i++) {\n    if (lineFlowState[i] === undefined) continue;\n    lineFlowState[i] = 'pauseAtStart';\n  }\n  \n  console.log(\"初始化完成：線條收合狀態\");\n}\n\n// 當狀態改變時通知父組件\nfunction updateFlowState(newState) {\n  globalFlowState = newState;\n  emit('stateChange', newState);\n  \n  // 檢查是否完成特定狀態，通知父組件\n  if (newState === 'pauseAtEnd') {\n    console.log(\"所有線條已生長完成，暫停動畫\");\n    emit('animationComplete', 'growing');\n  } else if (newState === 'pauseAtStart') {\n    console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n    emit('animationComplete', 'shrinking');\n  }\n}\n\nonMounted(() => {\n  // 初始化場景\n  if (!initializeScene()) return;\n\n  // 開始動畫循環（但不啟動流動）\n  animate();\n  \n  // 載入環境貼圖\n  loadEnvironmentMap().then(() => {\n    console.log('環境貼圖載入完成');\n    \n    // 初始化為收合狀態\n    initializeCollapsedState();\n    \n    // 資源載入完成，啟用按鈕\n    isPlaying.value = false;\n    \n    // 通知父組件資源已載入\n    emit('resourcesLoaded', true);\n    \n  }).catch(error => {\n    console.error('環境貼圖載入失敗:', error);\n  });\n\n  // 監聽視窗大小變化\n  window.addEventListener('resize', handleResize);\n});\n\nonUnmounted(() => {\n  cleanupScene();\n});\n\n// 暴露方法給父組件\ndefineExpose({\n  startGrowingAnimation,\n  startShrinkingAnimation,\n});\n</script>\n\n<style scoped>\n.splash-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n</style>\n","<template>\n  <Splash1 \n    ref=\"splashRef\" \n    @resourcesLoaded=\"handleResourcesLoaded\"\n    @stateChange=\"handleStateChange\"\n    @animationComplete=\"handleAnimationComplete\"\n  />\n  <div class=\"button-group\">\n    <button @click=\"growingFunction\">開始生長</button>\n    <button @click=\"shrinkingFunction\">開始收合</button>\n    <button @click=\"startAutoPlay\">開始自動播放</button>\n    <button @click=\"stopAutoPlay\">停止自動播放</button>\n    <div class=\"status\">狀態: {{ currentState }}</div>\n    <div class=\"status\">資源狀態: {{ loadComplete ? '已載入' : '載入中' }}</div>\n    <div class=\"status\">自動播放: {{ isAutoPlaying ? '進行中' : '停止' }}</div>\n  </div>\n</template>\n<script setup>\nconst splashRef = ref(null);\nconst loadComplete = ref(false);\nconst currentState = ref('idle');\nconst isAutoPlaying = ref(false);\nlet autoPlayTimer = null;\n\n// 基本動畫控制函數\nconst growingFunction = () => {\n  if (splashRef.value) {\n    splashRef.value.startGrowingAnimation();\n  }\n}\n\nconst shrinkingFunction = () => {\n  if (splashRef.value) {\n    splashRef.value.startShrinkingAnimation();\n  }\n}\n\n// 處理資源載入完成事件\nconst handleResourcesLoaded = () => {\n  loadComplete.value = true;\n  console.log('資源載入完成，開始自動播放');\n  startAutoPlay();\n}\n\n// 處理狀態變化\nconst handleStateChange = (state) => {\n  currentState.value = state;\n}\n\n// 處理動畫完成事件\nconst handleAnimationComplete = (animationType) => {\n  if (!isAutoPlaying.value) return;\n  \n  if (animationType === 'growing') {\n    // 生長動畫完成，等待1秒後開始收縮\n    autoPlayTimer = setTimeout(() => {\n      shrinkingFunction();\n    }, 1000);\n  } else if (animationType === 'shrinking') {\n    // 收縮動畫完成，等待1秒後開始生長\n    autoPlayTimer = setTimeout(() => {\n      growingFunction();\n    }, 1000);\n  }\n}\n\n// 開始自動播放\nconst startAutoPlay = () => {\n  if (isAutoPlaying.value) return; // 如果已經在播放則不執行\n  \n  isAutoPlaying.value = true;\n  \n  // 從生長動畫開始\n  growingFunction();\n}\n\n// 停止自動播放\nconst stopAutoPlay = () => {\n  isAutoPlaying.value = false;\n  \n  // 清除任何待執行的定時器\n  if (autoPlayTimer) {\n    clearTimeout(autoPlayTimer);\n    autoPlayTimer = null;\n  }\n  \n  // 執行收合動畫，使其回到起點\n  shrinkingFunction();\n}\n\n// 組件卸載時清理\nonUnmounted(() => {\n  if (autoPlayTimer) {\n    clearTimeout(autoPlayTimer);\n  }\n  isAutoPlaying.value = false;\n});\n</script>\n\n<style scoped>\n.splash-page {\n  width: 100%;\n  height: 100vh;\n  overflow: hidden;\n}\n\n.button-group {\n  position: absolute;\n  top: 20px;\n  left: 20px;\n  z-index: 10;\n}\n\n.status {\n  margin-top: 8px;\n  color: white;\n  background-color: rgba(0, 0, 0, 0.6);\n  padding: 5px 10px;\n  border-radius: 4px;\n}\n\nbutton {\n  margin-right: 8px;\n  padding: 8px 12px;\n  border: none;\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, 0.6);\n  color: white;\n  cursor: pointer;\n}\n\nbutton:hover {\n  background-color: rgba(40, 40, 40, 0.8);\n}\n</style>"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAwBwB,QAAI,IAAI;AAG1B,UAAA,YAAY,IAAI,KAAK;AAGV,aAAS;AAAA,MACxB,eAAe;AAAA;AAAA,MACf,aAAa;AAAA;AAAA,MACb,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA,IACX,CAAA;AAEgB,aAAS;AAAA,MACxB,eAAe;AAAA;AAAA,MACf,aAAa;AAAA;AAAA,MACb,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA,IACX,CAAA;AAGkB,aAAS;AAAA;AAAA,MAE1B,YAAY;AAAA;AAAA,MACZ,aAAa;AAAA;AAAA,MACb,oBAAoB;AAAA;AAAA,MACpB,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA;AAAA,MAGV,uBAAuB;AAAA,MACvB,gCAAgC;AAAA;AAAA,MAChC,0BAA0B;AAAA;AAAA,MAC1B,oBAAoB;AAAA;AAAA;AAAA,MAGpB,mBAAmB;AAAA;AAAA,MACnB,yBAAyB;AAAA;AAAA,MACzB,qBAAqB,KAAK,KAAK;AAAA;AAAA,IAChC,CAAA;AAugBD,aAAS,wBAAwB;AAE5B,UAAA,UAAU,SAAS,OAAO;AAC3B,kBAAU,QAAQ;AAAA,MAED;AAAA,IACnB;AAMF,aAAS,0BAA0B;AAE9B,UAAA,UAAU,SAAS,MAAM;AAC1B,kBAAU,QAAQ;AAAA,MAEC;AAAA,IACrB;AAuEW,aAAA;AAAA,MACX;AAAA,MACA;AAAA,IAAA,CACD;;;;;;;;;;;;;;;;;ACppBD,UAAM,YAAY,IAAI,IAAI;AAC1B,UAAM,eAAe,IAAI,KAAK;AAC9B,UAAM,eAAe,IAAI,MAAM;AAC/B,UAAM,gBAAgB,IAAI,KAAK;AAI/B,UAAM,kBAAkB,MAAM;AAC5B,UAAI,UAAU,OAAO;AACnB,kBAAU,MAAM,sBAAuB;AAAA,MAC3C;AAAA,IACA;AAEA,UAAM,oBAAoB,MAAM;AAC9B,UAAI,UAAU,OAAO;AACnB,kBAAU,MAAM,wBAAyB;AAAA,MAC7C;AAAA,IACA;AAGA,UAAM,wBAAwB,MAAM;AAClC,mBAAa,QAAQ;AACrB,cAAQ,IAAI,eAAe;AAC3B,oBAAe;AAAA,IACjB;AAGA,UAAM,oBAAoB,CAAC,UAAU;AACnC,mBAAa,QAAQ;AAAA,IACvB;AAGA,UAAM,0BAA0B,CAAC,kBAAkB;AACjD,UAAI,CAAC,cAAc,MAAO;AAE1B,UAAI,kBAAkB,WAAW;AAEf,mBAAW,MAAM;AAC/B,4BAAmB;AAAA,QACpB,GAAE,GAAI;AAAA,MACX,WAAa,kBAAkB,aAAa;AAExB,mBAAW,MAAM;AAC/B,0BAAiB;AAAA,QAClB,GAAE,GAAI;AAAA,MACX;AAAA,IACA;AAGA,UAAM,gBAAgB,MAAM;AAC1B,UAAI,cAAc,MAAO;AAEzB,oBAAc,QAAQ;AAGtB,sBAAiB;AAAA,IACnB;;;;;;;;;;;;;;;;;;;;;;"}