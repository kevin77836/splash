{"version":3,"file":"loadJson-2-CAKKLvi1.js","sources":["../../../../pages/loadJson-2.vue"],"sourcesContent":["<template>\n    <div class=\"splash-container\">\n      <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n    </div>\n  </template>\n  \n  <script setup>\n  import * as THREE from 'three';\n  import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\n  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n  import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n  \n  // --- Refs ---\n  const canvasContainer = ref(null);\n  \n  // --- 常量設定 ---\n  const CONFIG = {\n    segments: 50,      // 線條分段數\n    subtract: 20,      // Metaball 減值\n    resolution: 200,   // Marching Cubes 解析度\n    isolation: 300,    // Marching Cubes 獨立閾值\n    scale: 8,          // 效果縮放比例\n    randomRange: 2,    // 隨機方向範圍\n    directionCount: 3, // 方向向量維度\n    lineRange: {       // 線條長度範圍\n      min: 2,\n      max: 3.5\n    }\n  };\n  \n  // --- 核心組件 ---\n  let scene, camera, renderer, controls, effect, clock;\n  let materials, pmremGenerator, animationFrameId;\n  \n  // --- 模型數據 ---\n  let lineData = {\n    startTimes: [],\n    directions: [],\n    lengths: [],\n    types: [],\n    states: []\n  };\n  \n  // --- 動畫狀態 ---\n  const animation = {\n    state: 'idle',        // 當前動畫狀態 (idle, growing, pauseAtEnd, shrinking, pauseAtStart)\n    shrinkStart: null,    // 收縮開始時間\n    shrinkEnd: null,      // 收縮結束時間\n    growStart: null,      // 生長開始時間\n    centerBallVisible: false,  // 中心球體可見性\n    ballFadeStart: null   // 球體淡出開始時間\n  };\n  \n  // --- 動畫參數 ---\n  const params = {\n      centerBall: {\n      max: 1.0,        // 最大強度\n      min: 0.0,        // 最小強度\n      fadeDuration: 5.0, // 淡出時間\n      easing: {\n        type: 'easeIn', // 緩動類型\n        power: 0.5      // 緩動強度\n          }\n      },\n      timing: {\n      shrinkBase: 3.0,    // 基礎收縮時間\n      shrinkFactor: 0.2   // 收縮時間因子\n      },\n      growth: {\n      speed: 5.0,         // 基礎生長速度\n      easePower: 0.15,    // 生長緩動指數\n      speedFactor: 0.1    // 生長速度因子\n      },\n      wave: {\n      frequency: 1.0,     // 波浪頻率\n      amplitude: 0.3,     // 波浪振幅因子\n      phase: Math.PI * 4  // 波浪相位因子\n    },\n    render: {\n      pixelRatio: 1.5,    // 像素比例\n      rotateSpeed: 5.0    // 旋轉速度\n      }\n  };\n  \n  // --- 材質與渲染 ---\n  \n  // 創建液體材質\n  function createMaterial() {\n    return new THREE.MeshStandardMaterial({\n        color: 0xffffff,\n        metalness: 1,\n        roughness: 0,\n        transparent: true,\n        opacity: 0.25,\n        side: THREE.DoubleSide,\n        envMap: null\n    });\n  }\n  \n  // 載入環境貼圖\n  function loadEnvironmentMap() {\n    return new Promise((resolve, reject) => {\n    new EXRLoader()\n        .setPath('/hdr/')\n        .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', \n          (texture) => {\n            texture.mapping = THREE.EquirectangularReflectionMapping;\n            const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n            pmremGenerator.dispose();\n            texture.dispose();\n  \n            scene.environment = envMap;\n            if (materials?.liquid) {\n                materials.liquid.envMap = envMap;\n                materials.liquid.needsUpdate = true;\n            }\n            \n            resolve(envMap);\n          }, \n          undefined, \n          (error) => {\n            console.error('環境貼圖載入失敗:', error);\n            reject(error);\n          }\n        );\n        });\n  }\n  \n  // --- Metaball 和動畫相關 ---\n  \n  // 主要更新函數\n  function updateMetaball(obj) {\n    if (!clock) return;\n    \n    obj.reset();\n    const time = clock.getElapsedTime();\n    const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n\n    // 更新狀態並處理狀態轉換\n    updateAnimationState(time);\n\n    // 添加中心球體\n    addCenterBall(obj, centerOffset, time);\n    \n    // 更新所有線條\n    updateLines(obj, centerOffset, time);\n\n    obj.update();\n  }\n  \n  // 添加中心球體\n  function addCenterBall(obj, offset, time) {\n    const strength = calculateBallStrength(time);\n    \n    if (strength > 0.01) {\n      obj.addBall(offset.x, offset.y, offset.z, strength, CONFIG.subtract);\n      animation.centerBallVisible = true;\n    } else {\n      animation.centerBallVisible = false;\n    }\n  }\n  \n  // 計算球體強度\n  function calculateBallStrength(time) {\n    const { state, shrinkStart, shrinkEnd, ballFadeStart } = animation;\n    const { min, max, fadeDuration, easing } = params.centerBall;\n    \n    if (state === 'shrinking' && shrinkStart !== null && shrinkEnd !== null) {\n      // 收縮階段 - 球體逐漸變大\n      const shrinkDuration = shrinkEnd - shrinkStart;\n      const progress = Math.min((time - shrinkStart) / shrinkDuration, 1.0);\n      return min + progress * (max - min);\n    } \n    else if (state === 'pauseAtStart') {\n      // 暫停階段 - 球體逐漸淡出\n      if (ballFadeStart === null) {\n        animation.ballFadeStart = time;\n        return max;\n        }\n        \n      const fadeProgress = Math.min((time - ballFadeStart) / fadeDuration, 1.0);\n      const easedProgress = applyEasing(fadeProgress, easing);\n      return max * (1.0 - easedProgress);\n    } \n    \n    return min;\n  }\n  \n  // 更新所有線條\n  function updateLines(obj, centerOffset, time) {\n    const count = lineData.types.length;\n    \n    for (let i = 0; i < count; i++) {\n      if (!isLineActive(i, time)) continue;\n      \n      const direction = lineData.directions[i];\n      const type = lineData.types[i];\n      const maxLength = lineData.lengths[i] / obj.scale.x;\n      const timeSinceStart = time - lineData.startTimes[i];\n      \n      const length = calculateLineLength(maxLength, timeSinceStart, obj.scale.x);\n      if (length <= 0.001 || !direction || !type) continue;\n      \n      addLineSegments(obj, length, direction, type, centerOffset, time);\n    }\n  }\n  \n  // 檢查線條是否處於活動狀態\n  function isLineActive(index, time) {\n    return lineData.startTimes[index] !== undefined && \n           time >= lineData.startTimes[index] && \n           lineData.lengths[index] !== undefined;\n  }\n  \n  // 計算線條長度\n  function calculateLineLength(maxLength, timeSinceStart, scaleX) {\n    if (maxLength <= 0.001) return 0;\n    \n    const { state, shrinkStart, shrinkEnd } = animation;\n    const { speed, easePower, speedFactor } = params.growth;\n    const currentTime = clock.getElapsedTime();\n    \n    switch (state) {\n        case 'growing':\n        // 生長階段 - 線條逐漸變長\n        const currentSpeed = speed * speedFactor;\n        const duration = maxLength / (currentSpeed / scaleX);\n        const timeRatio = Math.min(timeSinceStart / duration, 1.0);\n        return Math.pow(timeRatio, easePower) * maxLength;\n            \n        case 'pauseAtEnd':\n        // 生長結束暫停\n            return maxLength;\n            \n        case 'shrinking':\n        // 收縮階段 - 線條逐漸變短\n        if (shrinkStart !== null && shrinkEnd !== null) {\n          const shrinkDuration = shrinkEnd - shrinkStart;\n          const progress = Math.min((currentTime - shrinkStart) / shrinkDuration, 1.0);\n          return maxLength * (1.0 - progress);\n            }\n            return maxLength;\n            \n        case 'pauseAtStart':\n        // 收縮結束暫停\n            return 0.001;\n            \n        default:\n            return 0;\n    }\n  }\n  \n  // 為線條添加所有 metaball 分段\n  function addLineSegments(obj, length, direction, type, offset, time) {\n    for (let i = 0; i <= CONFIG.segments; i++) {\n      const t = i / CONFIG.segments;\n      const strength = calculateSegmentStrength(t, type, time);\n      const position = calculateSegmentPosition(t, length, direction, offset);\n      \n      obj.addBall(position.x, position.y, position.z, strength, CONFIG.subtract);\n    }\n  }\n  \n  // 計算 metaball 分段的強度\n  function calculateSegmentStrength(t, type, time) {\n    const isTipType = type === 'tt';\n    const strengthFactor = Math.pow(t, isTipType ? 0.25 : 1.25);\n    \n        const baseStrength = THREE.MathUtils.lerp(\n      isTipType ? 0.1 : 0.01,\n      isTipType ? 0.01 : 0.1,\n            strengthFactor\n        );\n\n    // 添加波浪效果\n    const { frequency, amplitude, phase } = params.wave;\n    const waveOffset = Math.sin(time * frequency - t * phase) * amplitude * baseStrength;\n    \n    return Math.max(baseStrength + waveOffset, 0);\n  }\n        \n  // 計算分段位置\n  function calculateSegmentPosition(t, length, direction, offset) {\n    const localPos = direction.clone().multiplyScalar(length * t);\n    return localPos.add(offset);\n  }\n  \n  // --- 動畫流程控制 ---\n  \n  // 更新全局動畫狀態\n  function updateAnimationState(time) {\n    const { state, growStart, shrinkStart, shrinkEnd } = animation;\n    \n    // 生長完成後轉換到暫停\n    if (state === 'growing' && growStart !== null) {\n      const progress = calculateGrowthProgress(time);\n      if (progress >= 0.99) {\n        animation.state = 'pauseAtEnd';\n        console.log(\"生長完成，暫停中\");\n        setTimeout(startShrinking, 1000);\n      }\n    } \n    // 收縮完成後轉換到暫停\n    else if (state === 'shrinking' && shrinkStart !== null && shrinkEnd !== null) {\n      if (time >= shrinkEnd) {\n        animation.state = 'pauseAtStart';\n        console.log(\"收縮完成，暫停中\");\n        setTimeout(startGrowing, 1000);\n      }\n    }\n    \n    // 更新所有線條狀態\n    updateLineStates();\n  }\n  \n  // 更新所有線條狀態\n  function updateLineStates() {\n    const count = lineData.states.length;\n    const currentState = animation.state;\n    \n    for (let i = 0; i < count; i++) {\n      lineData.states[i] = currentState;\n    }\n  }\n  \n  // 計算平均生長進度\n  function calculateGrowthProgress(time) {\n    const count = lineData.types.length;\n    let totalProgress = 0;\n    let activeCount = 0;\n    \n    for (let i = 0; i < count; i++) {\n      if (!lineData.startTimes[i] || !lineData.lengths[i]) continue;\n      \n      activeCount++;\n      const maxLength = lineData.lengths[i] / (effect?.scale.x || 1);\n      const elapsed = time - (lineData.startTimes[i] || time);\n      const speed = params.growth.speed * params.growth.speedFactor;\n      const duration = maxLength / (speed / (effect?.scale.x || 1));\n      \n      totalProgress += Math.min(elapsed / duration, 1.0);\n    }\n    \n    return activeCount > 0 ? totalProgress / activeCount : 0;\n  }\n  \n  // 開始收縮階段\n  function startShrinking() {\n    if (!clock) return;\n    \n    const time = clock.getElapsedTime();\n    animation.state = 'shrinking';\n    animation.shrinkStart = time;\n    animation.shrinkEnd = time + params.timing.shrinkBase * params.timing.shrinkFactor;\n    animation.centerBallVisible = true;\n    animation.ballFadeStart = null;\n    \n    console.log(\"開始收縮，顯示中心球體\");\n  }\n  \n  // 開始生長階段\n  function startGrowing() {\n    if (!clock) return;\n    \n    const time = clock.getElapsedTime();\n    animation.state = 'growing';\n    animation.growStart = time;\n    animation.centerBallVisible = false;\n    animation.ballFadeStart = null;\n    \n    regenerateLines(time);\n    console.log(\"開始生長，隱藏中心球體\");\n  }\n  \n  // 重新生成線條\n  function regenerateLines(time) {\n    const count = lineData.types.length;\n    const { min, max } = CONFIG.lineRange;\n    \n    for (let i = 0; i < count; i++) {\n      if (lineData.startTimes[i] === undefined) continue;\n      \n      // 生成新的隨機方向\n      if (!lineData.directions[i]) {\n        lineData.directions[i] = new THREE.Vector3();\n      }\n      \n      // 填充隨機方向\n      const vector = lineData.directions[i];\n      const range = CONFIG.randomRange;\n      vector.set(\n        Math.random() * range - range/2,\n        Math.random() * range - range/2,\n        Math.random() * range - range/2\n      ).normalize();\n      \n      // 更新長度和開始時間\n      lineData.lengths[i] = THREE.MathUtils.randFloat(min, max);\n      lineData.startTimes[i] = time;\n    }\n  }\n  \n  // 應用緩動效果\n  function applyEasing(progress, config) {\n    switch (config.type) {\n      case 'easeIn':\n        return Math.pow(progress, config.power);\n      case 'easeOut':\n        return 1 - Math.pow(1 - progress, config.power);\n      default: // linear\n        return progress;\n    }\n  }\n  \n  // --- 資源加載 ---\n  \n  // 載入模型JSON\n  function loadModelJson() {\n    return fetch('/modelJson.json')\n        .then(response => response.json())\n        .then(config => {\n        initializeModelData(config);\n            applyModelConfiguration(config);\n        startAnimation();\n        return config;\n        })\n        .catch(error => {\n        console.error(\"模型設定載入失敗:\", error);\n        throw error;\n        });\n  }\n  \n  // 初始化模型數據\n  function initializeModelData(config) {\n    const count = config.lineTypes.length;\n    const time = clock?.getElapsedTime() ?? 0;\n    \n    // 重置數據結構\n    lineData = {\n      startTimes: new Array(count),\n      directions: new Array(count),\n      lengths: new Array(count),\n      types: new Array(count),\n      states: new Array(count)\n    };\n    \n    // 填充數據\n    for (let i = 0; i < count; i++) {\n      lineData.types[i] = config.lineTypes[i];\n      lineData.lengths[i] = config.currentTargetLengths[i];\n        \n        if (config.randomDirections[i]) {\n        lineData.directions[i] = new THREE.Vector3(\n                config.randomDirections[i].x,\n                config.randomDirections[i].y,\n                config.randomDirections[i].z\n            );\n        }\n        \n      lineData.startTimes[i] = time - 1000; // 立即可見\n      lineData.states[i] = 'growing';\n    }\n  }\n  \n  // 應用模型配置\n  function applyModelConfiguration(config) {\n    if (!effect || !config.cameraQuaternion) return;\n    \n    const quaternion = new THREE.Quaternion(\n        config.cameraQuaternion.x,\n        config.cameraQuaternion.y,\n        config.cameraQuaternion.z,\n        config.cameraQuaternion.w\n    );\n    \n    effect.quaternion.set(0, 0, 0, 1);\n    const invertedQuaternion = quaternion.clone().invert();\n    effect.quaternion.premultiply(invertedQuaternion);\n    effect.matrixWorldNeedsUpdate = true;\n    effect.updateMatrixWorld(true);\n    effect.matrixAutoUpdate = false;\n  }\n  \n  // 開始動畫循環\n  function startAnimation() {\n    animation.state = 'growing';\n    animation.growStart = clock.getElapsedTime();\n    \n    if (effect) effect.reset();\n  }\n  \n  // --- 核心渲染循環 ---\n  \n  function animate() {\n    animationFrameId = requestAnimationFrame(animate);\n  \n    if (!isSceneReady()) return;\n  \n    updateMetaball(effect);\n    controls.update();\n    renderer.render(scene, camera);\n  }\n  \n  // 檢查場景是否準備就緒\n  function isSceneReady() {\n    return effect && materials && camera && renderer && scene && controls;\n  }\n  \n  // --- 場景管理 ---\n  \n  // 處理視窗大小變化\n  function handleResize() {\n    if (!camera || !renderer) return;\n    \n    const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n    const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n  \n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n  }\n  \n  // 初始化場景\n  function initScene() {\n    if (!canvasContainer.value) {\n      console.error(\"找不到畫布容器!\");\n      return false;\n    }\n    \n    // 獲取容器尺寸\n    const container = canvasContainer.value;\n    const width = container.clientWidth;\n    const height = container.clientHeight;\n  \n    // 場景設置\n    scene = new THREE.Scene();\n    scene.background = null; // 透明背景\n  \n    // 相機設置\n    camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n    camera.position.set(0, 0, 30);\n    camera.lookAt(0, 0, 0);\n  \n    // 渲染器設置\n    renderer = new THREE.WebGLRenderer({ \n      antialias: true, \n      alpha: true \n    });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, params.render.pixelRatio));\n    container.appendChild(renderer.domElement);\n  \n    // 控制器設置\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.autoRotate = true;\n    controls.autoRotateSpeed = params.render.rotateSpeed;\n    controls.enableZoom = false;\n  \n    // 燈光設置\n    scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n    dirLight.position.set(5, 10, 7.5);\n    scene.add(dirLight);\n  \n    // 環境貼圖處理\n    pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n  \n    // 材質準備\n    materials = { liquid: createMaterial() };\n  \n    // Marching Cubes 效果\n    effect = new MarchingCubes(\n      CONFIG.resolution, \n      materials.liquid, \n      true, \n      true, \n      100000\n    );\n    effect.isolation = CONFIG.isolation;\n    effect.scale.set(CONFIG.scale, CONFIG.scale, CONFIG.scale);\n    effect.enableUvs = false;\n    effect.enableColors = false;\n    scene.add(effect);\n  \n    // 時鐘\n    clock = new THREE.Clock();\n    \n    return true;\n  }\n  \n  // 清理資源\n  function cleanupResources() {\n    cancelAnimationFrame(animationFrameId);\n    window.removeEventListener('resize', handleResize);\n  \n    // 釋放控制器\n    if (controls) controls.dispose();\n    \n    // 釋放渲染器\n    if (renderer) renderer.dispose();\n    \n    // 釋放材質和環境\n    if (materials?.liquid) {\n        materials.liquid.dispose();\n        if (scene?.environment) scene.environment.dispose();\n    }\n    \n    // 移除效果\n    if (effect) {\n        scene?.remove(effect);\n    }\n    \n    // 清理場景\n    if (scene) {\n      scene.traverse((object) => {\n          if (object instanceof THREE.Mesh) {\n          if (object.geometry) object.geometry.dispose();\n          \n              const material = object.material;\n              if (Array.isArray(material)) {\n            material.forEach(mat => mat.dispose());\n              } else if (material) {\n                  material.dispose();\n              }\n          }\n      });\n    }\n    \n    // 釋放環境處理器\n    if (pmremGenerator) pmremGenerator.dispose();\n  \n    // 移除畫布\n    if (canvasContainer.value && renderer) {\n      canvasContainer.value.removeChild(renderer.domElement);\n    }\n  }\n  \n  // --- 生命週期掛鉤 ---\n  \n  onMounted(async () => {\n    if (!initScene()) return;\n    \n    try {\n      // 並行加載資源\n      await Promise.all([\n        loadEnvironmentMap(),\n        loadModelJson()\n      ]);\n    \n      // 啟動渲染循環\n    animate();\n    \n    // 處理視窗大小變化\n    window.addEventListener('resize', handleResize);\n    } catch (error) {\n      console.error(\"初始化失敗:\", error);\n    }\n  });\n  \n  onUnmounted(() => {\n    cleanupResources();\n  });\n  </script>"],"names":[],"mappings":";;;;;;AAa0B,QAAI,IAAI;;;;;;;;;;;;"}