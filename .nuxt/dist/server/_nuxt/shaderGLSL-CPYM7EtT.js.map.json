{"file":"shaderGLSL-CPYM7EtT.js","mappings":"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","names":[],"sources":["../../../../components/SplashGLSL.vue","../../../../pages/shaderGLSL.vue"],"sourcesContent":["<template>\n  <div class=\"c-splash-component\">\n    <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n  </div>\n</template>\n\n<script setup>\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// 父組件事件\nconst emit = defineEmits([\n  'stateChange',       // 狀態變化事件\n  'animationComplete', // 動畫完成事件\n  'resourcesLoaded'    // 資源載入完成事件\n]);\n\n// =========================================\n// 1. 響應式狀態和參數配置\n// =========================================\n\n// --- Core Refs ---\nconst canvasContainer = ref(null);\n\n// --- 線條參數配置 ---\nconst ttParams = reactive({\n  startStrength: 0.1,    // 粗到細線條：起始端粗度\n  endStrength: 0.01,     // 粗到細線條：末端粗度\n  minLength: 2.5,        // 粗到細線條：最小長度\n  maxLength: 3.5,        // 粗到細線條：最大長度\n  shrinkPower: 0.25,     // 粗到細線條：粗細變化曲線指數\n  numLines: 4            // 粗到細線條：數量\n});\n\nconst thParams = reactive({\n  startStrength: 0.01,   // 細到粗線條：起始端粗度\n  endStrength: 0.1,      // 細到粗線條：末端粗度\n  minLength: 2,          // 細到粗線條：最小長度\n  maxLength: 3,          // 細到粗線條：最大長度\n  shrinkPower: 1.25,     // 細到粗線條：粗細變化曲線指數\n  numLines: 3            // 細到粗線條：數量\n});\n\n// --- 球體參數配置 ---\nconst sphereParams = reactive({\n  count: 20,           // 球體數量\n  minRadius: 0.35,      // 最小半徑\n  maxRadius: 0.5,      // 最大半徑\n  minLength: 3.0,      // 最小目標長度\n  maxLength: 10.0,      // 最大目標長度\n  segmentDetail: 16,   // 幾何體細分\n  minScale: 0        // 最小縮放值(原點狀態)\n});\n\n// --- 流動動畫參數 ---\nconst animParams = reactive({\n  // 基本設定\n  mobileResolution: 100,\n  resolution: 100,                // Marching Cubes 解析度\n  numSegments: 50,                // 每條線分段數量\n  subtract: 20,                   // Metaball 減法參數\n  \n  // 統一動畫控制參數\n  growSpeed: 0.1,                 // 生長速度 (值越大生長越快)\n  growthEaseOutPower: 0.15,       // 生長緩動指數 (值越小結尾越平滑)\n  shrinkSpeed: 1,               // 收縮速度 (值越大收縮越快)\n  shrinkEaseInPower: 2.5,         // 收縮緩動指數 (值越大開頭越快)\n  \n  // 波浪效果設定\n  flowWaveFrequency: 1.0,         // 波浪頻率\n  flowWaveAmplitudeFactor: 0.3,  // 波浪振幅因子\n  flowWaveAmplitudeFactorAtStart: 1.5, // 原點狀態下的波浪振幅因子\n  flowWavePhaseFactor: Math.PI * 4, // 波浪相位因子\n});\n\n// =========================================\n// 2. Three.js 核心物件和狀態\n// =========================================\n\n// --- Three.js 核心物件 ---\nlet scene = null;\nlet camera = null;\nlet renderer = null;\nlet controls = null;\nlet effect = null;\nlet clock = null;\nlet material = null;\nlet pmremGenerator = null;\nlet animationFrameId = null;\n\n// --- 滑鼠控制變量 ---\nlet mouseX = 0;\nlet mouseY = 0;\nlet targetRotationX = 0;\nlet targetRotationY = 0;\nlet targetPositionX = 0;\nlet targetPositionY = 0;\nlet modelRotationX = 0;\nlet modelRotationY = 0;\n\n// --- 滾動位移控制變量 ---\nlet targetScrollOffsetX = 0;\nlet targetScrollOffsetY = 0;\nlet targetScrollOffsetZ = 0;\n\n// --- 線條數據 ---\nlet lineStartTimes = [];      // 每條線的開始時間\nlet randomDirections = [];    // 每條線的隨機方向向量\nlet currentTargetLengths = []; // 每條線的目標長度\nlet lineTypes = [];           // 每條線的類型 ('tt' 或 'th')\nlet lineFlowState = [];       // 每條線的流動狀態\n\n// --- 球體特效 ---\nlet spheres = [];             // 儲存所有射出的球體\nlet sphereMaterial = null;    // 共用球體材質\n\n// --- 流動控制狀態 ---\nlet shrinkStartTime = null;   // 收合開始時間\nlet shrinkEndTime = null;     // 收合結束時間\nlet growStartTime = null;     // 生長開始時間\nlet globalFlowState = 'idle'; // 全局流動狀態\n\n// =========================================\n// 3. 材質和環境設定\n// =========================================\n\n/**\n * 生成液體材質\n */\nfunction generateMaterial() {\n  return new THREE.MeshPhysicalMaterial({\n    color: 0xffffff,\n    metalness: 0,\n    roughness: 0,\n    transparent: true,\n    opacity: 0.75,\n    transmission: 1,   // 增加透光性\n    ior: 1.5,          // 折射率\n    thickness: 1.0,    // 材質厚度\n    envMapIntensity: 10.0,\n    side: THREE.DoubleSide\n  });\n}\n\n/**\n * 載入環境貼圖\n */\nfunction loadEnvironmentMap() {\n  return new Promise((resolve, reject) => {\n    new EXRLoader()\n      .setPath('/hdr/')\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n        texture.mapping = THREE.EquirectangularReflectionMapping;\n        const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n        pmremGenerator.dispose();\n        texture.dispose();\n\n        console.log(\"環境貼圖已載入\");\n        scene.environment = envMap;\n        \n        // 更新主材質\n        if (material) {\n          material.envMap = envMap;\n          material.needsUpdate = true;\n        }\n        if (sphereMaterial) {\n          sphereMaterial.envMap = envMap;\n          sphereMaterial.needsUpdate = true;\n        }\n        \n        resolve(envMap);\n      }, undefined, (error) => {\n        console.error('無法載入環境貼圖:', error);\n        reject(error);\n      });\n  });\n}\n\n// =========================================\n// 4. 線條和動畫控制\n// =========================================\n\n/**\n * 重新生成所有線條\n */\nfunction regenerateLine() {\n  if (!clock || !effect) return;\n  const currentTime = clock.getElapsedTime();\n  const totalLines = ttParams.numLines + thParams.numLines;\n\n  // 調整陣列大小\n  lineStartTimes.length = totalLines;\n  randomDirections.length = totalLines;\n  currentTargetLengths.length = totalLines;\n  lineTypes.length = totalLines;\n  lineFlowState.length = totalLines;\n\n  let lineIndex = 0;\n\n  // 生成由粗到細線條\n  for(let i = 0; i < ttParams.numLines; i++) {\n    if (!randomDirections[lineIndex]) {\n      randomDirections[lineIndex] = new THREE.Vector3();\n    }\n    randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(ttParams.minLength, ttParams.maxLength);\n    lineTypes[lineIndex] = 'tt';\n    lineStartTimes[lineIndex] = currentTime;\n    \n    // 設置初始流動狀態\n    if (globalFlowState) {\n      lineFlowState[lineIndex] = globalFlowState;\n    } else {\n      lineFlowState[lineIndex] = 'growing';\n    }\n    \n    lineIndex++;\n  }\n\n  // 生成由細到粗線條\n  for(let i = 0; i < thParams.numLines; i++) {\n    if (!randomDirections[lineIndex]) {\n      randomDirections[lineIndex] = new THREE.Vector3();\n    }\n    randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(thParams.minLength, thParams.maxLength);\n    lineTypes[lineIndex] = 'th';\n    lineStartTimes[lineIndex] = currentTime;\n    \n    // 設置初始流動狀態\n    if (globalFlowState) {\n      lineFlowState[lineIndex] = globalFlowState;\n    } else {\n      lineFlowState[lineIndex] = 'growing';\n    }\n    \n    lineIndex++;\n  }\n  effect.reset();\n}\n\n/**\n * 更新Metaball線條效果\n */\nfunction updateLineMetaball(obj) {\n  if (!clock) return;\n  obj.reset();\n  const currentTime = clock.getElapsedTime();\n  const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n  const totalLines = ttParams.numLines + thParams.numLines;\n\n  // 更新全局流動狀態\n  updateGlobalFlowState(currentTime);\n\n  // 處理每條線的metaball效果\n  for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n    if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n      continue;\n    }\n\n    if (currentTargetLengths[lineIndex] === undefined) continue;\n    const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n    let localCurrentLength = 0;\n    let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n\n    // 計算當前線條長度\n    if (globalFlowState === 'pauseAtStart') {\n      // 在收合完成狀態下，線條仍可見但保持最短\n      localCurrentLength = 0.05; // 調大一點以確保可見流動效果\n    } else if (globalFlowState === 'pauseAtEnd') {\n      // 在生長完成狀態下，線條保持最長\n      localCurrentLength = localMaxLength;\n    } else if (globalFlowState === 'growing') {\n      // 生長狀態\n      if (localMaxLength > 0.001) {\n        const currentGrowthSpeed = animParams.growSpeed;\n        const linearDuration = localMaxLength / currentGrowthSpeed;\n        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n        const easedTime = Math.pow(normalizedTime, animParams.growthEaseOutPower);\n        localCurrentLength = easedTime * localMaxLength;\n      } else {\n        localCurrentLength = 0;\n      }\n    } else if (globalFlowState === 'shrinking') {\n      // 收縮狀態\n      if (shrinkStartTime !== null && shrinkEndTime !== null) {\n        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n        const timeSinceShrinking = currentTime - shrinkStartTime;\n        const linearShrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n        // 使用收縮緩動參數\n        const shrinkProgress = Math.pow(linearShrinkProgress, animParams.shrinkEaseInPower);\n        const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n        \n        // 當按下return開始收縮時，我們需要從當前長度開始收縮\n        const currentGrowthSpeed = animParams.growSpeed;\n        const linearDuration = localMaxLength / currentGrowthSpeed;\n        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n        const easedTime = Math.pow(normalizedTime, animParams.growthEaseOutPower);\n        const lengthBeforeShrinking = easedTime * localMaxLength;\n        \n        // 從當前長度開始按比例收縮\n        localCurrentLength = lengthBeforeShrinking * shrinkFactor;\n      } else {\n        localCurrentLength = localMaxLength;\n      }\n    } else {\n      // 默認狀態 - 靜態展示\n      if (localMaxLength > 0.001) {\n        const normalizedTime = Math.min(timeSinceStart / (localMaxLength / animParams.growSpeed), 1.0);\n        const easedTime = Math.pow(normalizedTime, animParams.growthEaseOutPower);\n        localCurrentLength = easedTime * localMaxLength;\n      } else {\n        localCurrentLength = 0;\n      }\n    }\n    \n    // 如果線條過短則跳過\n    if (localCurrentLength <= 0.001) continue;\n\n    const currentDirection = randomDirections[lineIndex];\n    const currentLineType = lineTypes[lineIndex];\n    if (!currentDirection || !currentLineType) continue;\n\n    // 根據線條類型選擇參數\n    let lineStartStrength, lineEndStrength, lineShrinkPowerVal;\n    if (currentLineType === 'tt') {\n      lineStartStrength = ttParams.startStrength;\n      lineEndStrength = ttParams.endStrength;\n      lineShrinkPowerVal = ttParams.shrinkPower;\n    } else { // 'th'\n      lineStartStrength = thParams.startStrength;\n      lineEndStrength = thParams.endStrength;\n      lineShrinkPowerVal = thParams.shrinkPower;\n    }\n\n    // 計算Metaball強度和位置\n    for (let i = 0; i <= animParams.numSegments; i++) {\n      const segmentT = i / animParams.numSegments;\n      const strengthFactor = Math.pow(segmentT, lineShrinkPowerVal);\n      const baseStrength = THREE.MathUtils.lerp(lineStartStrength, lineEndStrength, strengthFactor);\n\n      // 添加波浪效果\n      let dynamicStrength = baseStrength;\n      // 永遠啟用波浪效果，不受狀態影響\n      let flowAmplitude;\n      // 根據狀態選擇不同的振幅因子\n      if (globalFlowState === 'pauseAtStart') {\n        // 當線條處於原點時，使用更大的波浪振幅\n        flowAmplitude = animParams.flowWaveAmplitudeFactorAtStart * baseStrength;\n      } else if (globalFlowState === 'shrinking' && localCurrentLength < 0.1) {\n        // 當線條收縮接近原點時，也使用較大的波浪振幅\n        // 根據收縮進度平滑過渡振幅\n        const transitionFactor = Math.max(0, Math.min(1, 10 * (0.1 - localCurrentLength)));\n        const normalAmplitude = animParams.flowWaveAmplitudeFactor * baseStrength;\n        const startAmplitude = animParams.flowWaveAmplitudeFactorAtStart * baseStrength;\n        flowAmplitude = normalAmplitude + transitionFactor * (startAmplitude - normalAmplitude);\n      } else {\n        // 其他狀態使用標準振幅\n        flowAmplitude = animParams.flowWaveAmplitudeFactor * baseStrength;\n      }\n      const flowOffset = Math.sin(currentTime * animParams.flowWaveFrequency - segmentT * animParams.flowWavePhaseFactor) * flowAmplitude;\n      dynamicStrength += flowOffset;\n      dynamicStrength = Math.max(dynamicStrength, 0);\n\n      // 設置球體位置\n      const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n      const finalPos = localPos.add(centerOffset);\n\n      // 添加Metaball\n      obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, animParams.subtract);\n    }\n  }\n\n  obj.update();\n}\n\n// =========================================\n// 5. 流動狀態控制\n// =========================================\n\n/**\n * 更新全局流動狀態\n */\nfunction updateGlobalFlowState(currentTime) {\n  if (!clock) return;\n  \n  // 檢查當前時間和設定的時間節點\n  if (globalFlowState === 'growing' && growStartTime !== null) {\n    // 計算所有線條的平均生長完成度\n    const totalLines = ttParams.numLines + thParams.numLines;\n    let totalGrowthProgress = 0;\n    let activeLines = 0;\n    \n    for (let i = 0; i < totalLines; i++) {\n      if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n      \n      activeLines++;\n      const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n      const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n      const currentGrowthSpeed = animParams.growSpeed;\n      const linearDuration = localMaxLength / currentGrowthSpeed;\n      const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n      \n      totalGrowthProgress += growthProgress;\n    }\n    \n    const averageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n    \n    // 當平均生長進度達到99%以上，切換到暫停狀態\n    if (averageProgress >= 0.99) {\n      updateFlowState('pauseAtEnd');\n    }\n  } else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n    // 檢查是否達到收合結束時間\n    if (currentTime >= shrinkEndTime) {\n      updateFlowState('pauseAtStart');\n    }\n  }\n}\n\n/**\n * 創建並發射一個球體\n */\nfunction createSphere(direction, size) {\n  const geometry = new THREE.SphereGeometry(size, sphereParams.segmentDetail, sphereParams.segmentDetail);\n  \n  // 使用共用材質\n  if (!sphereMaterial) {\n    sphereMaterial = generateMaterial();\n  }\n  \n  const sphere = new THREE.Mesh(geometry, sphereMaterial);\n  \n  // 設置初始位置為原點\n  sphere.position.set(0, 0, 0);\n  \n  // 儲存球體數據\n  const sphereData = {\n    mesh: sphere,\n    direction: direction,\n    targetLength: 0,                  // 將在更新時設置\n    initialScale: size,\n    active: true,\n    progress: 0,                      // 當前進度 (0-1)\n    currentPosition: 0,               // 當前位置長度\n    lastUpdateTime: clock ? clock.getElapsedTime() : 0,  // 上次更新時間\n    transitionStartTime: null,        // 轉換開始時間\n    transitionStartPos: 0             // 轉換開始位置\n  };\n  \n  // 添加到場景和球體陣列\n  scene.add(sphere);\n  spheres.push(sphereData);\n  \n  return sphereData;\n}\n\n/**\n * 初始化所有球體\n */\nfunction initSpheres() {\n  // 清理現有球體\n  clearSpheres();\n  \n  // 創建新球體\n  for (let i = 0; i < sphereParams.count; i++) {\n    // 隨機方向\n    const direction = new THREE.Vector3(\n      Math.random() * 2 - 1,\n      Math.random() * 2 - 1,\n      Math.random() * 2 - 1\n    ).normalize();\n    \n    // 隨機大小\n    const size = sphereParams.minRadius + Math.random() * (sphereParams.maxRadius - sphereParams.minRadius);\n    \n    // 創建球體\n    const sphere = createSphere(direction, size);\n    \n    // 設置目標長度 (與線條相似的範圍)\n    sphere.targetLength = THREE.MathUtils.randFloat(sphereParams.minLength, sphereParams.maxLength);\n  }\n}\n\n/**\n * 清理所有球體\n */\nfunction clearSpheres() {\n  // 從場景中移除所有球體並釋放資源\n  for (let i = 0; i < spheres.length; i++) {\n    const sphere = spheres[i];\n    \n    if (sphere.mesh) {\n      scene.remove(sphere.mesh);\n      sphere.mesh.geometry.dispose();\n    }\n  }\n  \n  // 清空陣列\n  spheres = [];\n}\n\n/**\n * 更新球體位置和狀態\n * 支持從任何位置開始收合/生長\n */\nfunction updateSpheres() {\n  if (!clock) return;\n  \n  const currentTime = clock.getElapsedTime();\n  \n  // 計算線條的平均生長進度，用於同步球體\n  let linesAverageProgress = 1.0;\n  \n  if (globalFlowState === 'growing' && growStartTime !== null) {\n    // 只有在生長狀態時才需要計算線條進度\n    const totalLines = ttParams.numLines + thParams.numLines;\n    let totalGrowthProgress = 0;\n    let activeLines = 0;\n    \n    for (let i = 0; i < totalLines; i++) {\n      if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n      \n      activeLines++;\n      const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n      const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n      const currentGrowthSpeed = animParams.growSpeed;\n      const linearDuration = localMaxLength / currentGrowthSpeed;\n      const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n      \n      totalGrowthProgress += growthProgress;\n    }\n    \n    linesAverageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 1.0;\n  }\n  \n  // 更新每個球體\n  for (let i = 0; i < spheres.length; i++) {\n    const sphere = spheres[i];\n    if (!sphere.active || !sphere.mesh) continue;\n    \n    let currentPosition = 0;\n    \n    // 根據全局流動狀態更新球體位置\n    if (globalFlowState === 'pauseAtStart') {\n      // 原點狀態\n      currentPosition = 0;\n    } else if (globalFlowState === 'pauseAtEnd') {\n      // 完全展開狀態\n      currentPosition = sphere.targetLength;\n    } else if (globalFlowState === 'growing') {\n      // 生長狀態 - 與線條同步\n      if (growStartTime !== null) {\n        // 記錄起始位置（僅在狀態變化時）\n        if (sphere.transitionStartTime !== growStartTime) {\n          sphere.transitionStartTime = growStartTime;\n          sphere.transitionStartPos = sphere.currentPosition;\n        }\n        \n        // 使用與線條相同的平均進度，確保同步\n        const totalProgress = Math.pow(linesAverageProgress, animParams.growthEaseOutPower);\n        \n        // 計算應該增長的距離比例\n        const targetGrowthDist = sphere.targetLength - sphere.transitionStartPos;\n        const growthDistance = targetGrowthDist * totalProgress;\n        \n        // 新位置是起始位置加上生長的距離\n        currentPosition = sphere.transitionStartPos + growthDistance;\n        \n        // 當線條接近完成時，確保球體也完全到位\n        if (linesAverageProgress >= 0.99) {\n          currentPosition = sphere.targetLength;\n        }\n      }\n    } else if (globalFlowState === 'shrinking') {\n      // 收縮狀態 - 從當前位置開始收縮\n      if (shrinkStartTime !== null && shrinkEndTime !== null) {\n        // 如果這是狀態轉換的開始，記錄起始位置\n        if (sphere.transitionStartTime !== shrinkStartTime) {\n          sphere.transitionStartTime = shrinkStartTime;\n          sphere.transitionStartPos = sphere.currentPosition;\n        }\n        \n        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n        const timeSinceShrink = currentTime - shrinkStartTime;\n        // 使用收縮緩動參數計算進度\n        const linearShrinkProgress = Math.min(timeSinceShrink / shrinkDuration, 1.0);\n        const shrinkProgress = Math.pow(linearShrinkProgress, animParams.shrinkEaseInPower);\n        \n        // 計算應該收縮的距離比例\n        const targetShrinkDist = sphere.transitionStartPos;\n        const shrinkDistance = targetShrinkDist * shrinkProgress;\n        \n        // 新位置是起始位置減去收縮的距離\n        currentPosition = sphere.transitionStartPos - shrinkDistance;\n        \n        // 當收縮接近完成時，確保球體完全歸零\n        if (shrinkProgress >= 0.99) {\n          currentPosition = 0;\n        }\n      }\n    }\n    \n    // 確保位置在有效範圍內\n    currentPosition = Math.max(0, Math.min(currentPosition, sphere.targetLength));\n    \n    // 更新球體當前位置\n    sphere.currentPosition = currentPosition;\n    \n    // 計算球體進度比例 (0-1)\n    sphere.progress = sphere.targetLength > 0 ? currentPosition / sphere.targetLength : 0;\n    \n    // 根據進度計算位置\n    const spherePosition = sphere.direction.clone().multiplyScalar(currentPosition);\n    sphere.mesh.position.copy(spherePosition);\n    \n    // 根據進度計算大小\n    let scale;\n    if (currentPosition < 0.01) {\n      scale = sphereParams.minScale; // 保持最小可見大小\n    } else {\n      // 根據距離計算大小，確保球體大小與位置成比例\n      const sizeProgress = Math.min(sphere.progress * 1.5, 1.0); // 略微加速大小變化\n      scale = sphereParams.minScale + (sphere.initialScale - sphereParams.minScale) * sizeProgress;\n    }\n    \n    sphere.mesh.scale.set(scale, scale, scale);\n  }\n}\n\n// =========================================\n// 6. 動畫和渲染\n// =========================================\n\n/**\n * 動畫主循環\n */\nfunction animate() {\n  animationFrameId = requestAnimationFrame(animate);\n\n  if (!effect || !material || !camera || !renderer || !scene || !controls) return;\n\n  // 更新場景邏輯\n  updateLineMetaball(effect);\n  \n  // 更新球體\n  updateSpheres();\n  \n  // 平滑過渡到目標旋轉角度\n  modelRotationX += (targetRotationX - modelRotationX) * 0.05;\n  modelRotationY += (targetRotationY - modelRotationY) * 0.05;\n  \n  // 應用旋轉到場景\n  scene.rotation.x = modelRotationX;\n  scene.rotation.y = modelRotationY;\n  if(isMobileDevice()){\n    effect.rotation.y += 0.0025;\n    for(let i=0;i<spheres.length;i++){\n      spheres[i].mesh.rotation.y += 0.0025;\n    }\n  }\n  \n  // 結合滑鼠控制和滾動位移的最終位置\n  scene.position.x = targetPositionX + targetScrollOffsetX;\n  scene.position.y = targetPositionY + targetScrollOffsetY;\n  scene.position.z = targetScrollOffsetZ;\n  \n  // 確保控制器始終更新 - 保持自動旋轉\n  controls.update();\n  \n  // 渲染場景\n  renderer.render(scene, camera);\n}\n\n/**\n * 處理視窗大小變化\n */\nfunction handleResize() {\n  if (!camera || !renderer) return;\n  const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n  const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n  renderer.setSize(width, height);\n}\n\n// =========================================\n// 7. 生命週期鉤子\n// =========================================\n\n/**\n * 初始化Three.js場景和相關物件\n */\nfunction initializeScene() {\n  if (!canvasContainer.value) {\n    console.error(\"Canvas container not found!\");\n    return false;\n  }\n  \n  const container = canvasContainer.value;\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n\n  // 場景\n  scene = new THREE.Scene();\n  scene.background = null;\n\n  // 相機\n  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  camera.position.set(0, 0, 30);\n  camera.lookAt(scene.position);\n\n  // 渲染器\n  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n  container.appendChild(renderer.domElement);\n\n  // 控制器\n  controls = new OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n\n  // 禁止縮放和平移，只允許旋轉\n  controls.enableZoom = false;     // 禁止縮放\n  controls.enablePan = false;      // 禁止平移\n  controls.enableRotate = false;\n  controls.minDistance = camera.position.length(); // 固定距離\n  controls.maxDistance = camera.position.length(); // 固定距離\n\n  // PMREMGenerator\n  pmremGenerator = new THREE.PMREMGenerator(renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  // 材質\n  material = generateMaterial();\n\n  // Marching Cubes\n  let resolution;\n  if (!isMobileDevice()){\n    resolution = animParams.resolution;\n  }else{\n    resolution = animParams.mobileResolution;\n  }\n  const derivedIsolation = resolution * 1.5;\n  effect = new MarchingCubes(resolution, material, true, true, 100000);\n  effect.isolation = derivedIsolation;\n  effect.scale.set(8, 8, 8);\n  effect.enableUvs = false;\n  effect.enableColors = false;\n  scene.add(effect);\n\n  // 時鐘\n  clock = new THREE.Clock();\n  \n  // 初始化共用材質\n  sphereMaterial = generateMaterial();\n  \n  // 初始化滾動位移變量\n  targetScrollOffsetX = 0;\n  targetScrollOffsetY = 0;\n  targetScrollOffsetZ = 0;\n  \n  return true;\n}\n\n/**\n * 清理Three.js資源\n */\nfunction cleanupScene() {\n  // 停止動畫\n  cancelAnimationFrame(animationFrameId);\n\n  // 移除視窗大小變化監聽\n  window.removeEventListener('resize', handleResize);\n\n  // 重置滾動位移變量\n  targetScrollOffsetX = 0;\n  targetScrollOffsetY = 0;\n  targetScrollOffsetZ = 0;\n\n  // 清理球體\n  clearSpheres();\n\n  // 清理Three.js資源\n  if (controls) controls.dispose();\n  if (renderer) renderer.dispose();\n  if (material) {\n    material.dispose();\n    if (scene?.environment) scene.environment.dispose();\n  }\n  \n  if (effect) {\n    scene?.remove(effect);\n  }\n  \n  if (scene) {\n    // 清理場景中的物件\n    scene.traverse((object) => {\n      if (object instanceof THREE.Mesh) {\n        object.geometry?.dispose();\n        const objMaterial = object.material;\n        if (Array.isArray(objMaterial)) {\n          objMaterial.forEach((mat) => mat.dispose());\n        } else if (objMaterial) {\n          objMaterial.dispose();\n        }\n      }\n    });\n  }\n  \n  if (pmremGenerator) pmremGenerator.dispose();\n\n  // 移除畫布\n  if (canvasContainer.value && renderer) {\n    canvasContainer.value.removeChild(renderer.domElement);\n  }\n\n  // 清理球體材質\n  if (sphereMaterial) {\n    sphereMaterial.dispose();\n  }\n\n  console.log(\"Three.js場景已清理\");\n}\n\n// =========================================\n// 8. 用戶互動控制\n// =========================================\n\n/**\n * 檢查是否為行動裝置\n */\nfunction isMobileDevice() {\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n}\n\n/**\n * 開始生長動畫\n */\nfunction startGrowingAnimation() {\n  // 不管當前是什麼狀態，直接切換到生長狀態\n  if(globalFlowState!=='growing' && globalFlowState!=='pauseAtEnd') {\n    globalFlowState = 'growing';\n    startSyncGrowing();\n  }\n}\n\n/**\n * 開始收合動畫\n */\nfunction startShrinkingAnimation() {\n  // 不管當前是什麼狀態，直接切換到收合狀態\n  if(globalFlowState!=='shrinking' && globalFlowState!=='pauseAtStart') {\n    globalFlowState = 'shrinking';\n    startSyncShrinking();\n  }\n}\n\n/**\n * 初始化為收合狀態\n */\nfunction initializeCollapsedState() {\n  // 設置全局狀態為收合完成\n  updateFlowState('pauseAtStart');\n  \n  // 初始線條生成（但保持最小長度）\n  regenerateLine();\n  \n  // 初始化球體\n  initSpheres();\n  \n  // 設置所有線條狀態為初始狀態\n  const totalLines = ttParams.numLines + thParams.numLines;\n  for (let i = 0; i < totalLines; i++) {\n    if (lineFlowState[i] === undefined) continue;\n    lineFlowState[i] = 'pauseAtStart';\n  }\n  \n  console.log(\"初始化完成：線條收合狀態\");\n}\n\n// 當狀態改變時通知父組件\nfunction updateFlowState(newState) {\n  globalFlowState = newState;\n  emit('stateChange', newState);\n  \n  // 檢查是否完成特定狀態，通知父組件\n  if (newState === 'pauseAtEnd') {\n    console.log(\"所有線條已生長完成，暫停動畫\");\n    emit('animationComplete', 'growing');\n  } else if (newState === 'pauseAtStart') {\n    console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n    emit('animationComplete', 'shrinking');\n  }\n}\n\n/**\n * 開始同步生長所有線條\n */\nfunction startSyncGrowing() {\n  if (!clock) return;\n  const currentTime = clock.getElapsedTime();\n  const totalLines = ttParams.numLines + thParams.numLines;\n  \n  console.log(\"所有線條同步生長\");\n  \n  // 確保球體已初始化\n  if (spheres.length === 0) {\n    initSpheres();\n  }\n  \n  // 更新全局狀態\n  updateFlowState('growing');\n  growStartTime = currentTime;\n  \n  // 不需要更新球體進度方向，updateSpheres 會根據全局狀態自動處理\n  \n  // 重置所有線條的方向和長度\n  for (let i = 0; i < totalLines; i++) {\n    if (lineStartTimes[i] === undefined) continue;\n    \n    // 重新生成隨機方向\n    if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n    randomDirections[i]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    \n    // 更新線條類型和長度\n    lineTypes[i] = (i < ttParams.numLines) ? 'tt' : 'th';\n    const minL = (lineTypes[i] === 'tt') ? ttParams.minLength : thParams.minLength;\n    const maxL = (lineTypes[i] === 'tt') ? ttParams.maxLength : thParams.maxLength;\n    currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n    \n    // 更新線條狀態\n    lineStartTimes[i] = currentTime;\n    lineFlowState[i] = 'growing';\n  }\n}\n\n/**\n * 開始同步收合所有線條\n */\nfunction startSyncShrinking() {\n  if (!clock) return;\n  const currentTime = clock.getElapsedTime();\n  \n  console.log(\"所有線條同步收合\");\n  \n  // 更新全局狀態\n  updateFlowState('shrinking');\n  \n  // 設置收合時間\n  shrinkStartTime = currentTime;\n  // 使用直接的收縮速度參數，值越大收縮越快，因此需要倒數\n  shrinkEndTime = currentTime + (1.0 / animParams.shrinkSpeed);\n  \n  // 不需要更新球體進度方向，updateSpheres 會根據全局狀態自動處理\n  \n  // 保持現有線條方向和目標長度，只更新起始時間\n  const totalLines = ttParams.numLines + thParams.numLines;\n  for (let i = 0; i < totalLines; i++) {\n    if (lineStartTimes[i] === undefined) continue;\n    // 更新線條狀態和時間，但保持當前方向和目標長度\n    lineFlowState[i] = 'shrinking';\n  }\n}\n\n/**\n * 添加滑鼠控制事件\n */\nfunction addMouseControlEvents() {\n  const container = canvasContainer.value;\n  if (!container) return;\n  \n  // 只有在非行動裝置上才添加滑鼠控制\n  if (!isMobileDevice()) {\n    console.log('啟用桌面滑鼠控制');\n    window.addEventListener('mousemove', onMouseMove);\n  } else {\n    console.log('行動裝置，不啟用滑鼠控制');\n  }\n}\n\n/**\n * 移除滑鼠控制事件\n */\nfunction removeMouseControlEvents() {\n  const container = canvasContainer.value;\n  if (!container) return;\n  \n  // 無論是否為行動裝置，都應移除事件以防止內存洩漏\n  window.removeEventListener('mousemove', onMouseMove);\n}\n\n/**\n * 滑鼠移動事件處理\n */\nfunction onMouseMove(event) {\n  // 如果是行動裝置，則直接返回不處理\n  if (isMobileDevice()) return;\n  \n  // 計算滑鼠與視窗中心的偏移\n  const centerX = window.innerWidth / 2;\n  const centerY = window.innerHeight / 2;\n  \n  // 計算偏移並加上減速因子使移動不那麼劇烈\n  const offsetX = (event.clientX - centerX) * 0.001;\n  const offsetY = (event.clientY - centerY) * 0.001;\n  \n  // 更新目標位置 (使偏移更小以獲得更細膩的移動)\n  targetPositionX = offsetX;\n  targetPositionY = -offsetY; // 負值使移動方向與滑鼠一致\n  \n  // 更新目標旋轉角度 (滑鼠水平移動控制Y軸旋轉，垂直移動控制X軸旋轉)\n  // 使用百分比計算以適應不同螢幕尺寸\n  targetRotationY = (event.clientX / window.innerWidth - 0.5) * Math.PI * 2;\n  targetRotationX = (event.clientY / window.innerHeight - 0.5) * Math.PI * 2;\n  \n  // 限制旋轉範圍\n  targetRotationX = Math.max(-Math.PI, Math.min(Math.PI, targetRotationX));\n  targetRotationY = Math.max(-Math.PI, Math.min(Math.PI, targetRotationY));\n  \n  // 更新滑鼠位置\n  mouseX = event.clientX;\n  mouseY = event.clientY;\n}\n\nonMounted(() => {\n  // 初始化場景\n  if (!initializeScene()) return;\n\n  // 開始動畫循環（但不啟動流動）\n  animate();\n  \n  // 載入環境貼圖\n  loadEnvironmentMap().then(() => {\n    console.log('環境貼圖載入完成');\n    \n    // 初始化為收合狀態\n    initializeCollapsedState();\n    \n    // 通知父組件資源已載入\n    emit('resourcesLoaded', true);\n    \n  }).catch(error => {\n    console.error('環境貼圖載入失敗:', error);\n  });\n\n  // 監聽視窗大小變化\n  window.addEventListener('resize', handleResize);\n});\n\nonUnmounted(() => {\n  cleanupScene();\n\n  // 移除滑鼠控制事件\n  removeMouseControlEvents();\n});\n\n// 暴露方法給父組件\ndefineExpose({\n  startGrowingAnimation,\n  startShrinkingAnimation,\n  addMouseControlEvents,\n  updatePosition\n});\n\n/**\n * 根據滾動位置更新模型位置\n */\nfunction updatePosition(xOffset, yOffset, zOffset) {\n  if (!scene) return;\n  \n  // 設置目標滾動位移，animate 函數會平滑過渡到這些值\n  targetScrollOffsetX = xOffset;\n  targetScrollOffsetY = -yOffset;\n  targetScrollOffsetZ = zOffset;\n  \n  console.log(`更新滾動位移: x=${xOffset}, y=${yOffset}, z=${zOffset}`);\n}\n</script>","<template>\n    <div class=\"main-container\">\n        <div class=\"main-section\">\n            <div v-if=\"loadComplete && !isStarted\" class=\"startButton\" @click=\"clickStart\">\n                Start\n            </div>\n      \n            <h1 :class=\"{'hidden': !isLandingPage || (isLandingPage && !isStarted)}\" class=\"company-name\">\n            <span class=\"front-name\">\n            Splash\n            </span>\n            <span class=\"back-name\">\n            DigiLab\n                </span>\n            </h1>\n        </div>\n        <div v-if=\"isStarted\" class=\"section section2\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section3\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section4\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section5\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section aboutUsSection\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section6\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section7\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section8\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section9\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section ourWorksSection\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section10\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section11\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section12\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section13\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section14\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section15\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section section16\">\n        </div>\n        <div v-if=\"isStarted\" class=\"section contactUsSection\">\n        </div>\n    </div>\n    <SplashGLSL\n    ref=\"splashRef\" \n    @resourcesLoaded=\"handleResourcesLoaded\"\n    @stateChange=\"handleStateChange\"\n    @animationComplete=\"handleAnimationComplete\"\n    />\n    <div :class=\"{'active': isStarted && isLandingPage}\" class=\"l-footer\">\n        <div class=\"desktop-group\">\n            <div class=\"footer-saparator\">\n                <div class=\"footer-saparator-line\"></div>\n            </div>\n            <div class=\"footer-link\">\n                Let's Make a Splash\n            </div>\n            <div class=\"footer-saparator\">\n                <div class=\"footer-saparator-line\"></div>\n            </div>\n        </div>        \n    </div>\n    <div :class=\"{'active': isStarted}\" class=\"l-header\">\n        <div class=\"desktop-group\">\n            <div class=\"header-link\" :class=\"{'hidden': isLandingPage}\">\n                Splash DigiLab\n            </div>\n            <div class=\"header-saparator\" :class=\"{'hidden': isLandingPage}\">\n                <div class=\"header-saparator-line\"></div>\n            </div>\n            <div class=\"header-link\" @click=\"scrollToSection('aboutUsSection')\">\n                About Us\n            </div>\n            <div class=\"header-saparator\" :class=\"{'hidden': !isLandingPage}\">\n                <div class=\"header-saparator-line\"></div>\n            </div>\n            <div class=\"header-link\" @click=\"scrollToSection('ourWorksSection')\">\n                Our Works\n            </div>\n            <div class=\"header-saparator\" :class=\"{'hidden': !isLandingPage}\">\n                <div class=\"header-saparator-line\"></div>\n            </div>\n            <div class=\"header-link\" @click=\"scrollToSection('contactUsSection')\">\n                Contact Us\n            </div>\n        </div>\n\n        <!-- 漢堡選單按鈕 -->\n        <div class=\"mobile-group\">\n            <div class=\"header-link\" :class=\"{'hidden': isLandingPage}\">Splash DigiLab</div>\n            <div class=\"header-saparator\">\n                <div class=\"header-saparator-line\"></div>\n            </div>\n            <div class=\"hamburger-menu\" @click=\"toggleMenu\">\n                <div :class=\"{'open': isMenuOpen}\" class=\"hamburger-icon\">\n                    <span></span>\n                    <span></span>\n                    <span></span>\n                </div>\n            </div>\n        </div>\n        <!-- 行動裝置選單 -->\n        <div :class=\"{'active': isMenuOpen}\" class=\"mobile-menu\">\n            <div class=\"menu-item\" @click=\"scrollToSection('aboutUsSection', true)\">\n                About Us\n            </div>\n            <div class=\"menu-item\" @click=\"scrollToSection('ourWorksSection', true)\">\n                Our Works\n            </div>\n            <div class=\"menu-item\" @click=\"scrollToSection('contactUsSection', true)\">\n                Contact Us\n            </div>\n        </div>\n    </div>\n        <!-- <div class=\"button-group\">\n        <button @click=\"growingFunction\">開始生長</button>\n        <button @click=\"shrinkingFunction\">開始收合</button>\n        <button @click=\"startAutoPlay\">開始自動播放</button>\n        <button @click=\"stopAutoPlay\">停止自動播放</button>\n        <div class=\"status\">狀態: {{ currentState }}</div>\n        <div class=\"status\">資源狀態: {{ loadComplete ? '已載入' : '載入中' }}</div>\n        <div class=\"status\">自動播放: {{ isAutoPlaying ? '進行中' : '停止' }}</div>\n        </div> -->\n</template>\n<script setup>\n    import gsap from 'gsap';\n    import { ScrollTrigger } from 'gsap/ScrollTrigger';\n    import { useWindowSize } from '@vueuse/core'\n    const { width, height } = useWindowSize();\n    \n    // 註冊 ScrollTrigger 插件\n    if (process.client) {\n        gsap.registerPlugin(ScrollTrigger);\n    }\n    \n    const splashRef = ref(null);\n    const loadComplete = ref(false);\n    const currentState = ref('idle');\n    const isAutoPlaying = ref(false);\n    const isStarted = ref(false);\n    const isMenuOpen = ref(false);\n    const isLandingPage = ref(true);\n    let autoPlayTimer = null;\n    \n    \n    // 設置 ScrollTrigger 動畫\n    const setupScrollAnimations = () => {\n        // 確保所有區塊已經渲染\n        if (process.client) {\n            nextTick(() => {\n                // 定義所有區塊的配置\n                const sectionConfigs = [\n                    {\n                        trigger: '.section2',\n                        start: 'top 80%',\n                        markers: false,\n                        onEnter: () => {\n                            stopAutoPlay();\n                            isLandingPage.value = false;\n                        },\n                        onLeaveBack: () => {\n                            startAutoPlay();\n                            isLandingPage.value = true;\n                        },\n                    },\n                    {\n                        trigger: '.section3',\n                        start: 'center center',\n                        endTrigger: '.section6',\n                        end: 'center center',\n                        markers: false,\n                        scrub: 2,\n                        onUpdate: (self) => {\n                            updatePosition(0, 0, 0, 0, -5, 0, self.progress);\n                        }\n                    },\n                    {\n                        trigger: '.section6',\n                        start: 'center center',\n                        end: 'center center',\n                        markers: false,\n                        onEnter: () => growingFunction(),\n                        onLeaveBack: () => shrinkingFunction(),\n                    },\n                    {\n                        trigger: '.section10',\n                        start: 'center center',\n                        markers: false,\n                        onEnter: () => shrinkingFunction(),\n                        onLeaveBack: () => growingFunction()\n                    },\n                    {\n                        trigger: '.section11',\n                        start: 'center center',\n                        markers: false,\n                        onEnter: () => growingFunction(),\n                        onLeaveBack: () => shrinkingFunction()\n                    },\n                    {\n                        trigger: '.section12',\n                        start: 'center center',\n                        markers: false,\n                        onEnter: () => shrinkingFunction(),\n                        onLeaveBack: () => growingFunction()\n                    },\n                    {\n                        trigger: '.section13',\n                        start: 'center center',\n                        end: 'bottom top',\n                        scrub: 1,\n                        markers: false,\n                        onEnter: () => growingFunction(),\n                        onLeaveBack: () => shrinkingFunction(),\n                    },\n                    {\n                        trigger: '.section14',\n                        start: 'center center',\n                        end: 'bottom top',\n                        scrub: 1,\n                        markers: false,\n                        onEnter: () => shrinkingFunction(),\n                        onLeaveBack: () => growingFunction(),\n                    },\n                    {\n                        trigger: '.section15',\n                        start: 'center center',\n                        markers: false,\n                        onEnter: () => growingFunction(),\n                        onLeaveBack: () => shrinkingFunction()\n                    }\n                ];\n                \n                // 為每個配置創建相應的 ScrollTrigger\n                sectionConfigs.forEach(config => {\n                    gsap.timeline({\n                        scrollTrigger: {\n                            trigger: config.trigger,\n                            start: config.start,\n                            end: config.end,\n                            endTrigger: config.endTrigger,\n                            scrub: config.scrub,\n                            markers: config.markers,\n                            onEnter: config.onEnter,\n                            onLeaveBack: config.onLeaveBack,\n                            onUpdate: config.onUpdate\n                        }\n                    });\n                });\n            });\n        \n        }\n\n    };\n\n    const updatePosition = (fromX, fromY, fromZ, toX, toY, toZ, progress) => {\n        if (splashRef.value) {\n            const x = (toX - fromX) * progress;\n            const y = (toY - fromY) * progress;\n            const z = (toZ - fromZ) * progress;\n            const offsetX = fromX + x;\n            const offsetY = fromY + y;\n            const offsetZ = fromZ + z;\n            splashRef.value.updatePosition(offsetX, offsetY, offsetZ);\n        }\n    }\n    \n    // 基本動畫控制函數\n    const growingFunction = () => {\n        if (splashRef.value) {\n        splashRef.value.startGrowingAnimation();\n        }\n    }\n    \n    const shrinkingFunction = () => {\n        if (splashRef.value) {\n        splashRef.value.startShrinkingAnimation();\n        }\n    }\n    \n    // 處理資源載入完成事件\n    const handleResourcesLoaded = () => {\n        loadComplete.value = true;\n    }\n    \n    // 處理狀態變化\n    const handleStateChange = (state) => {\n        currentState.value = state;\n    }\n    \n    // 處理動畫完成事件\n    const handleAnimationComplete = (animationType) => {\n        if (!isAutoPlaying.value) return;\n        \n        if (animationType === 'growing') {\n            // 生長動畫完成，等待1秒後開始收縮\n            autoPlayTimer = setTimeout(() => {\n                shrinkingFunction();\n            }, 0);\n        } else if (animationType === 'shrinking') {\n            // 收縮動畫完成，等待2秒後開始生長\n            autoPlayTimer = setTimeout(() => {\n                growingFunction();\n            }, 1000);\n        }\n    }\n    \n    const clickStart = () => {\n        isStarted.value = true;\n        startAutoPlay();\n        splashRef.value.addMouseControlEvents();\n        \n        // 設置滾動動畫\n        setupScrollAnimations();\n        \n        // 啟用頁面滾動\n        document.body.style.overflow = 'auto';\n    }\n    \n    // 開始自動播放\n    const startAutoPlay = () => {\n        if (isAutoPlaying.value) return; // 如果已經在播放則不執行\n        isAutoPlaying.value = true;\n        \n        // 從生長動畫開始\n        growingFunction();\n    }\n    \n    // 停止自動播放\n    const stopAutoPlay = () => {\n        isAutoPlaying.value = false;\n        \n        // 清除任何待執行的定時器\n        if (autoPlayTimer) {\n            clearTimeout(autoPlayTimer);\n            autoPlayTimer = null;\n        }\n        \n        // 執行收合動畫，使其回到起點\n        shrinkingFunction();\n    }\n    \n    // 切換漢堡選單\n    const toggleMenu = () => {\n        isMenuOpen.value = !isMenuOpen.value;\n        // 當選單打開時禁止滾動\n        if (isMenuOpen.value) {\n            document.body.style.overflow = 'hidden';\n        } else {\n            // 如果已經開始，則恢復滾動\n            if (isStarted.value) {\n                document.body.style.overflow = 'auto';\n            }\n        }\n    }\n    \n    // 滾動到指定區塊\n    const scrollToSection = (sectionClass, isFromMobile = false) => {\n        // 如果從行動版選單點擊，先關閉選單\n        if (isFromMobile) {\n            toggleMenu();\n        }\n        \n        // 使用 setTimeout 確保 DOM 已更新\n        setTimeout(() => {\n            const section = document.querySelector(`.${sectionClass}`);\n            if (section) {\n                // 使用平滑滾動\n                window.scrollTo({\n                    top: section.offsetTop,\n                    behavior: 'smooth'\n                });\n            }\n        }, 100);\n    }\n    \n    onMounted(() => {\n        document.body.style.overflow = 'hidden';\n    });\n    // 組件卸載時清理\n    onUnmounted(() => {\n        if (autoPlayTimer) {\n            clearTimeout(autoPlayTimer);\n        }\n        isAutoPlaying.value = false;\n        \n        // 清理所有 ScrollTrigger 實例\n        ScrollTrigger.getAll().forEach(trigger => trigger.kill());\n    });\n</script>"],"version":3}