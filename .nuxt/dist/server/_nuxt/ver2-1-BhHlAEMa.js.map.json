{"file":"ver2-1-BhHlAEMa.js","mappings":";;;;;;AAiBwB,QAAI,IAAI;AAGf,aAAS;AAAA,MACxB,eAAe;AAAA;AAAA,MACf,aAAa;AAAA;AAAA,MACb,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA,IACX,CAAA;AAEgB,aAAS;AAAA,MACxB,eAAe;AAAA;AAAA,MACf,aAAa;AAAA;AAAA,MACb,WAAW;AAAA;AAAA,MACX,WAAW;AAAA;AAAA,MACX,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA,IACX,CAAA;AAGkB,aAAS;AAAA;AAAA,MAE1B,YAAY;AAAA;AAAA,MACZ,aAAa;AAAA;AAAA,MACb,oBAAoB;AAAA;AAAA,MACpB,aAAa;AAAA;AAAA,MACb,UAAU;AAAA;AAAA;AAAA,MAGV,uBAAuB;AAAA;AAAA,MACvB,0BAA0B;AAAA;AAAA,MAC1B,oBAAoB;AAAA;AAAA;AAAA,MAGpB,mBAAmB;AAAA;AAAA,MACnB,yBAAyB;AAAA;AAAA,MACzB,qBAAqB,KAAK,KAAK;AAAA;AAAA;AAAA,MAG/B,uBAAuB;AAAA;AAAA,MACvB,uBAAuB;AAAA;AAAA,IACxB,CAAA;AAGiB,QAAI,IAAI;;;;;;;;;;;;","names":[],"sources":["../../../../pages/ver2-1.vue"],"sourcesContent":["<template>\n  <div class=\"splash-container\">\n    <div ref=\"canvasContainer\" class=\"canvas-container\"></div>\n  </div>\n</template>\n\n<script setup>\nimport * as THREE from 'three';\nimport { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\n\n// =========================================\n// 1. 響應式狀態和參數配置\n// =========================================\n\n// --- Core Refs ---\nconst canvasContainer = ref(null);\n\n// --- 線條參數配置 ---\nconst ttParams = reactive({\n  startStrength: 0.1,    // 粗到細線條：起始端粗度\n  endStrength: 0.01,     // 粗到細線條：末端粗度\n  minLength: 2.5,        // 粗到細線條：最小長度\n  maxLength: 3.5,        // 粗到細線條：最大長度\n  shrinkPower: 0.25,     // 粗到細線條：粗細變化曲線指數\n  numLines: 4            // 粗到細線條：數量\n});\n\nconst thParams = reactive({\n  startStrength: 0.01,   // 細到粗線條：起始端粗度\n  endStrength: 0.1,      // 細到粗線條：末端粗度\n  minLength: 2,          // 細到粗線條：最小長度\n  maxLength: 3,          // 細到粗線條：最大長度\n  shrinkPower: 1.25,     // 細到粗線條：粗細變化曲線指數\n  numLines: 3            // 細到粗線條：數量\n});\n\n// --- 流動動畫參數 ---\nconst animParams = reactive({\n  // 基本設定\n  resolution: 200,                // Marching Cubes 解析度\n  growthSpeed: 5.0,               // 線條生長速度\n  growthEaseOutPower: 0.15,       // 生長緩動指數\n  numSegments: 50,                // 每條線分段數量\n  subtract: 20,                   // Metaball 減法參數\n  \n  // 流動效果設定\n  flowGrowthSpeedFactor: 0.1,     // 流動模式下的生長速度因子\n  flowShrinkDurationFactor: 0.2,  // 流動模式下的收縮持續時間因子\n  baseShrinkDuration: 3.0,        // 基本收縮持續時間 (秒)\n  \n  // 波浪效果設定\n  flowWaveFrequency: 1.0,         // 波浪頻率\n  flowWaveAmplitudeFactor: 0.15,  // 波浪振幅因子\n  flowWavePhaseFactor: Math.PI * 4, // 波浪相位因子\n  \n  // 球體設定\n  maxCenterBallStrength: 2.0,     // 中心球體最大強度\n  minCenterBallStrength: 0.0,     // 中心球體最小強度\n});\n\n// 永遠啟用流動動畫\nconst isFlowing = ref(true);\n\n// =========================================\n// 2. Three.js 核心物件和狀態\n// =========================================\n\n// --- Three.js 核心物件 ---\nlet scene = null;\nlet camera = null;\nlet renderer = null;\nlet controls = null;\nlet effect = null;\nlet clock = null;\nlet material = null;\nlet pmremGenerator = null;\nlet animationFrameId = null;\n\n// --- 線條數據 ---\nlet lineStartTimes = [];      // 每條線的開始時間\nlet randomDirections = [];    // 每條線的隨機方向向量\nlet currentTargetLengths = []; // 每條線的目標長度\nlet lineTypes = [];           // 每條線的類型 ('tt' 或 'th')\nlet lineFlowState = [];       // 每條線的流動狀態\n\n// --- 流動控制狀態 ---\nlet savedLineState = null;    // 線條狀態備份\nlet savedCameraState = null;  // 相機狀態備份\nlet shrinkStartTime = null;   // 收合開始時間\nlet shrinkEndTime = null;     // 收合結束時間\nlet growStartTime = null;     // 生長開始時間\nlet centerBallVisible = false; // 中心球體可見性\nlet globalFlowState = 'idle'; // 全局流動狀態\n\n// =========================================\n// 3. 材質和環境設定\n// =========================================\n\n/**\n * 生成液體材質\n * @returns {THREE.MeshPhysicalMaterial} 液體效果材質\n */\nfunction generateMaterial() {\n  return new THREE.MeshPhysicalMaterial({\n        color: 0xffffff,\n        metalness: 0.9,\n        roughness: 0,\n        transparent: true,\n        opacity: 0.25,\n    transmission: 1,   // 增加透光性\n    ior: 1.5,          // 折射率\n    thickness: 1.0,    // 材質厚度\n    envMapIntensity: 1.0,\n    side: THREE.DoubleSide\n  });\n}\n\n/**\n * 載入環境貼圖\n * @returns {Promise<THREE.Texture>} 環境貼圖Promise\n */\nfunction loadEnvironmentMap() {\n  return new Promise((resolve, reject) => {\n  new EXRLoader()\n      .setPath('/hdr/')\n      .load('HDR_Light_Studio_Free_HDRI_Design_04.exr', (texture) => {\n          texture.mapping = THREE.EquirectangularReflectionMapping;\n          const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n          pmremGenerator.dispose();\n          texture.dispose();\n\n        console.log(\"環境貼圖已載入\");\n          scene.environment = envMap;\n        if (material) {\n          material.envMap = envMap;\n          material.needsUpdate = true;\n          }\n        resolve(envMap);\n      }, undefined, (error) => {\n        console.error('無法載入環境貼圖:', error);\n        reject(error);\n      });\n      });\n}\n\n// =========================================\n// 4. 線條和動畫控制\n// =========================================\n\n/**\n * 重新生成所有線條\n */\nfunction regenerateLine() {\n  if (!clock || !effect) return;\n    const currentTime = clock.getElapsedTime();\n  const totalLines = ttParams.numLines + thParams.numLines;\n\n    // 調整陣列大小\n    lineStartTimes.length = totalLines;\n    randomDirections.length = totalLines;\n    currentTargetLengths.length = totalLines;\n    lineTypes.length = totalLines;\n    lineFlowState.length = totalLines;\n\n    let lineIndex = 0;\n\n    // 生成由粗到細線條\n  for(let i = 0; i < ttParams.numLines; i++) {\n        if (!randomDirections[lineIndex]) {\n            randomDirections[lineIndex] = new THREE.Vector3();\n        }\n        randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(ttParams.minLength, ttParams.maxLength);\n        lineTypes[lineIndex] = 'tt';\n        lineStartTimes[lineIndex] = currentTime;\n        lineFlowState[lineIndex] = 'growing';\n        lineIndex++;\n    }\n\n    // 生成由細到粗線條\n  for(let i = 0; i < thParams.numLines; i++) {\n        if (!randomDirections[lineIndex]) {\n            randomDirections[lineIndex] = new THREE.Vector3();\n        }\n        randomDirections[lineIndex]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(thParams.minLength, thParams.maxLength);\n        lineTypes[lineIndex] = 'th';\n        lineStartTimes[lineIndex] = currentTime;\n        lineFlowState[lineIndex] = 'growing';\n        lineIndex++;\n    }\n    effect.reset();\n}\n\n/**\n * 更新Metaball線條效果\n * @param {MarchingCubes} obj Marching Cubes物件\n */\nfunction updateLineMetaball(obj) {\n    if (!clock) return;\n    obj.reset();\n    const currentTime = clock.getElapsedTime();\n    const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5);\n  const totalLines = ttParams.numLines + thParams.numLines;\n\n    // 更新全局流動狀態\n    updateGlobalFlowState(currentTime);\n\n    // 添加中心metaball球體 (如果可見)\n    if (centerBallVisible) {\n        // 計算中心球體的強度\n        const centerBallStrength = calculateCenterBallStrength(currentTime);\n        if (centerBallStrength > 0.01) {\n            // 將中心球體添加到metaball系統\n      obj.addBall(centerOffset.x, centerOffset.y, centerOffset.z, centerBallStrength, animParams.subtract);\n        }\n    }\n\n  // 處理每條線的metaball效果\n    for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {\n        if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {\n            continue;\n        }\n\n        if (currentTargetLengths[lineIndex] === undefined) continue;\n        const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;\n        let localCurrentLength = 0;\n        let timeSinceStart = currentTime - lineStartTimes[lineIndex];\n\n    // 計算當前線條長度\n        if (isFlowing.value) {\n      // 流動模式：根據全局流動狀態決定長度\n            switch (globalFlowState) {\n                case 'growing':\n                    if (localMaxLength > 0.001) {\n            const currentGrowthSpeed = animParams.growthSpeed * animParams.flowGrowthSpeedFactor;\n                        const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x);\n                        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n            const easedTime = Math.pow(normalizedTime, animParams.growthEaseOutPower);\n                        localCurrentLength = easedTime * localMaxLength;\n                    } else {\n                        localCurrentLength = 0;\n                    }\n                    break;\n                case 'pauseAtEnd':\n                    localCurrentLength = localMaxLength;\n                    break;\n                case 'shrinking':\n                    // 計算收合進度（所有線條使用相同的開始和結束時間）\n                    if (shrinkStartTime !== null && shrinkEndTime !== null) {\n                        const shrinkDuration = shrinkEndTime - shrinkStartTime;\n                        const timeSinceShrinking = currentTime - shrinkStartTime;\n                        const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n                        const shrinkFactor = Math.max(0, 1.0 - shrinkProgress);\n                        localCurrentLength = localMaxLength * shrinkFactor;\n                    } else {\n                        localCurrentLength = localMaxLength;\n                    }\n                    break;\n                case 'pauseAtStart':\n                    localCurrentLength = 0.001;\n                    break;\n                default:\n                    localCurrentLength = 0;\n                    break;\n            }\n            \n            // 更新單獨線條狀態以匹配全局狀態\n            lineFlowState[lineIndex] = globalFlowState;\n        } else {\n      // 非流動模式：標準生長邏輯\n            if (localMaxLength > 0.001) {\n        const normalizedTime = Math.min(timeSinceStart / (localMaxLength / (animParams.growthSpeed / obj.scale.x)), 1.0);\n        const easedTime = Math.pow(normalizedTime, animParams.growthEaseOutPower);\n                localCurrentLength = easedTime * localMaxLength;\n            } else {\n                localCurrentLength = 0;\n            }\n        }\n        \n    // 如果線條過短則跳過\n        if (localCurrentLength <= 0.001) continue;\n\n        const currentDirection = randomDirections[lineIndex];\n        const currentLineType = lineTypes[lineIndex];\n        if (!currentDirection || !currentLineType) continue;\n\n        // 根據線條類型選擇參數\n        let lineStartStrength, lineEndStrength, lineShrinkPowerVal;\n        if (currentLineType === 'tt') {\n      lineStartStrength = ttParams.startStrength;\n      lineEndStrength = ttParams.endStrength;\n      lineShrinkPowerVal = ttParams.shrinkPower;\n        } else { // 'th'\n      lineStartStrength = thParams.startStrength;\n      lineEndStrength = thParams.endStrength;\n      lineShrinkPowerVal = thParams.shrinkPower;\n        }\n\n        // 計算Metaball強度和位置\n    for (let i = 0; i <= animParams.numSegments; i++) {\n      const segmentT = i / animParams.numSegments;\n            const strengthFactor = Math.pow(segmentT, lineShrinkPowerVal);\n            const baseStrength = THREE.MathUtils.lerp(lineStartStrength, lineEndStrength, strengthFactor);\n\n      // 添加波浪效果\n            let dynamicStrength = baseStrength;\n            if (isFlowing.value) {\n        const flowAmplitude = animParams.flowWaveAmplitudeFactor * baseStrength;\n        const flowOffset = Math.sin(currentTime * animParams.flowWaveFrequency - segmentT * animParams.flowWavePhaseFactor) * flowAmplitude;\n                dynamicStrength += flowOffset;\n                dynamicStrength = Math.max(dynamicStrength, 0);\n            }\n\n      // 設置球體位置\n            const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT);\n            const finalPos = localPos.add(centerOffset);\n\n      // 添加Metaball\n      obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, animParams.subtract);\n        }\n    }\n\n    obj.update();\n}\n\n// =========================================\n// 5. 流動狀態控制\n// =========================================\n\n/**\n * 更新全局流動狀態\n * @param {number} currentTime 當前時間\n */\nfunction updateGlobalFlowState(currentTime) {\n  if (!isFlowing.value || !clock) return;\n  \n  // 檢查當前時間和設定的時間節點\n  if (globalFlowState === 'growing' && growStartTime !== null) {\n    // 計算所有線條的平均生長完成度\n    const totalLines = ttParams.numLines + thParams.numLines;\n    let totalGrowthProgress = 0;\n    let activeLines = 0;\n    \n    for (let i = 0; i < totalLines; i++) {\n      if (lineStartTimes[i] === undefined || currentTargetLengths[i] === undefined) continue;\n      \n      activeLines++;\n      const localMaxLength = currentTargetLengths[i] / (effect?.scale.x || 1);\n      const timeSinceStart = currentTime - (lineStartTimes[i] || currentTime);\n      const currentGrowthSpeed = animParams.growthSpeed * animParams.flowGrowthSpeedFactor;\n      const linearDuration = localMaxLength / (currentGrowthSpeed / (effect?.scale.x || 1));\n      const growthProgress = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;\n      \n      totalGrowthProgress += growthProgress;\n    }\n    \n    const averageProgress = activeLines > 0 ? totalGrowthProgress / activeLines : 0;\n    \n    // 當平均生長進度達到99%以上，切換到暫停狀態\n    if (averageProgress >= 0.99) {\n      globalFlowState = 'pauseAtEnd';\n      console.log(\"所有線條已生長完成，進入暫停狀態\");\n      \n      // 延遲一段時間後開始收合\n      setTimeout(() => {\n        if (isFlowing.value) {\n          startSyncShrinking();\n        }\n      }, 1000); // 暫停1秒後開始收合\n            }\n  } else if (globalFlowState === 'shrinking' && shrinkStartTime !== null && shrinkEndTime !== null) {\n    // 檢查是否達到收合結束時間\n    if (currentTime >= shrinkEndTime) {\n      globalFlowState = 'pauseAtStart';\n      console.log(\"所有線條已收合完成，進入起始暫停狀態\");\n      \n      // 延遲一段時間後開始新的生長週期\n      setTimeout(() => {\n        if (isFlowing.value) {\n          startSyncGrowing();\n        }\n      }, 1000); // 暫停1秒後開始生長\n    }\n  }\n}\n\n/**\n * 開始同步收合所有線條\n */\nfunction startSyncShrinking() {\n  if (!clock) return;\n  const currentTime = clock.getElapsedTime();\n  \n  console.log(\"所有線條同步收合\");\n  \n  // 更新全局狀態\n  globalFlowState = 'shrinking';\n  \n  // 設置收合時間\n  shrinkStartTime = currentTime;\n  shrinkEndTime = currentTime + animParams.baseShrinkDuration * animParams.flowShrinkDurationFactor;\n  \n  // 顯示中心metaball球體\n  centerBallVisible = true;\n    }\n\n/**\n * 開始同步生長所有線條\n */\nfunction startSyncGrowing() {\n  if (!clock) return;\n  const currentTime = clock.getElapsedTime();\n  const totalLines = ttParams.numLines + thParams.numLines;\n    \n  console.log(\"所有線條同步生長\");\n  \n  // 更新全局狀態\n  globalFlowState = 'growing';\n  growStartTime = currentTime;\n  \n  // 隱藏中心球體\n        centerBallVisible = false;\n        \n  // 重置所有線條的方向和長度\n  for (let i = 0; i < totalLines; i++) {\n    if (lineStartTimes[i] === undefined) continue;\n    \n    // 重新生成隨機方向\n    if (!randomDirections[i]) randomDirections[i] = new THREE.Vector3();\n    randomDirections[i]?.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n    \n    // 更新線條類型和長度\n    lineTypes[i] = (i < ttParams.numLines) ? 'tt' : 'th';\n    const minL = (lineTypes[i] === 'tt') ? ttParams.minLength : thParams.minLength;\n    const maxL = (lineTypes[i] === 'tt') ? ttParams.maxLength : thParams.maxLength;\n    currentTargetLengths[i] = THREE.MathUtils.randFloat(minL, maxL);\n\n    // 更新線條狀態\n    lineStartTimes[i] = currentTime;\n  }\n}\n\n/**\n * 計算中心球體的強度\n * @param {number} currentTime 當前時間\n * @returns {number} 球體強度值\n */\nfunction calculateCenterBallStrength(currentTime) {\n  if (!clock || shrinkStartTime === null || shrinkEndTime === null) return 0;\n  \n  if (currentTime === undefined) {\n    currentTime = clock.getElapsedTime();\n    }\n  \n  if (globalFlowState === 'shrinking') {\n    // 在收合階段，球體強度隨收合進度增加\n    const shrinkDuration = shrinkEndTime - shrinkStartTime;\n    const timeSinceShrinking = currentTime - shrinkStartTime;\n    const shrinkProgress = Math.min(timeSinceShrinking / shrinkDuration, 1.0);\n    return animParams.minCenterBallStrength + shrinkProgress * (animParams.maxCenterBallStrength - animParams.minCenterBallStrength);\n  } else if (globalFlowState === 'pauseAtStart') {\n    // 在收合完成階段，球體保持最大強度\n    return animParams.maxCenterBallStrength;\n  } else {\n    // 其他狀態下球體強度最小\n    return animParams.minCenterBallStrength;\n  }\n}\n\n// =========================================\n// 6. 動畫和渲染\n// =========================================\n\n/**\n * 動畫主循環\n */\nfunction animate() {\n  animationFrameId = requestAnimationFrame(animate);\n\n  if (!effect || !material || !camera || !renderer || !scene || !controls) return;\n\n  // 更新場景邏輯\n  updateLineMetaball(effect);\n  controls.update();\n  \n  // 渲染場景\n      renderer.render(scene, camera);\n}\n\n/**\n * 處理視窗大小變化\n */\nfunction handleResize() {\n  if (!camera || !renderer) return;\n    const width = canvasContainer.value?.clientWidth ?? window.innerWidth;\n    const height = canvasContainer.value?.clientHeight ?? window.innerHeight;\n\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n}\n\n// =========================================\n// 7. 生命週期鉤子\n// =========================================\n\n/**\n * 初始化Three.js場景和相關物件\n */\nfunction initializeScene() {\n  if (!canvasContainer.value) {\n    console.error(\"Canvas container not found!\");\n    return false;\n  }\n  \n  const container = canvasContainer.value;\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n\n  // 場景\n  scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x111111); // 暗色背景配合液體材質\n\n  // 相機\n  camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);\n  camera.position.set(0, 0, 30);\n  camera.lookAt(scene.position);\n\n  // 渲染器\n  renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));\n  container.appendChild(renderer.domElement);\n\n  // 控制器\n  controls = new OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.autoRotate = true; // 永遠啟用自動旋轉\n  controls.autoRotateSpeed = 2.0;\n\n  // 燈光\n  scene.add(new THREE.AmbientLight(0xffffff, 0.3));\n  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);\n  dirLight.position.set(5, 10, 7.5);\n  scene.add(dirLight);\n\n  // PMREMGenerator\n  pmremGenerator = new THREE.PMREMGenerator(renderer);\n  pmremGenerator.compileEquirectangularShader();\n\n  // 材質\n  material = generateMaterial();\n\n  // Marching Cubes\n  const derivedIsolation = animParams.resolution * 1.5;\n  effect = new MarchingCubes(animParams.resolution, material, true, true, 100000);\n  effect.isolation = derivedIsolation;\n  effect.scale.set(8, 8, 8);\n  effect.enableUvs = false;\n  effect.enableColors = false;\n  scene.add(effect);\n\n  // 時鐘\n  clock = new THREE.Clock();\n\n  return true;\n}\n\n/**\n * 清理Three.js資源\n */\nfunction cleanupScene() {\n  // 停止動畫\n  cancelAnimationFrame(animationFrameId);\n\n  // 移除視窗大小變化監聽\n  window.removeEventListener('resize', handleResize);\n\n  // 清理Three.js資源\n  if (controls) controls.dispose();\n  if (renderer) renderer.dispose();\n  if (material) {\n    material.dispose();\n      if (scene?.environment) scene.environment.dispose();\n  }\n  \n  if (effect) {\n      scene?.remove(effect);\n  }\n  \n   if (scene) {\n    // 清理場景中的物件\n        scene.traverse((object) => {\n            if (object instanceof THREE.Mesh) {\n                object.geometry?.dispose();\n        const objMaterial = object.material;\n        if (Array.isArray(objMaterial)) {\n          objMaterial.forEach((mat) => mat.dispose());\n        } else if (objMaterial) {\n          objMaterial.dispose();\n                }\n            }\n        });\n    }\n  \n  if (pmremGenerator) pmremGenerator.dispose();\n\n  // 移除畫布\n  if (canvasContainer.value && renderer) {\n    canvasContainer.value.removeChild(renderer.domElement);\n  }\n\n  console.log(\"Three.js場景已清理\");\n}\n\nonMounted(() => {\n  // 初始化場景\n  if (!initializeScene()) return;\n\n  // 載入環境貼圖\n  loadEnvironmentMap().then(() => {\n    console.log('環境貼圖載入完成');\n  }).catch(error => {\n    console.error('環境貼圖載入失敗:', error);\n  });\n            \n  // 初始線條生成\n  regenerateLine();\n            \n  // 開始流動動畫\n            setTimeout(() => {\n                    startSyncGrowing();\n  }, 500);\n\n  // 開始動畫\n  animate();\n\n  // 監聽視窗大小變化\n  window.addEventListener('resize', handleResize);\n});\n\nonUnmounted(() => {\n  cleanupScene();\n});\n</script>"],"version":3}