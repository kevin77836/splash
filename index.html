<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Splash Logo Generator</title>
  <style>
    body { 
        position: relative;
        margin: 0; 
        overflow: hidden; 
        background-color: #ffffff; /* 改為白色背景 */
    }
    canvas { display: block; }
    .control-panel {
      position: absolute;
      width: 250px; /* 稍微加寬 */
      padding: 15px;
      border-radius: 8px;
      font-family: 'Arial', sans-serif;
      font-size: 14px;
      background: rgba(25, 25, 25, 0.85);
      color: #e0e0e0;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      max-height: calc(100vh - 20px); /* 避免超出視窗 */
      overflow-y: auto;
    }
    .thick-to-thin-panel {
        top: 10px;
        left: 10px;
    }
    .thin-to-thick-panel {
        top: 10px;
        right: 10px;
    }
    .common-panel {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        height: auto;
        width: 350px; /* 可以根據內容調整寬度 */
        flex-direction: column; /* 讓元素垂直排列 */
        align-items: center; /* 居中對齊 */
    }
    .panel-title {
      font-size: 16px;
      font-weight: bold;
      margin-top: 5px;
      margin-bottom: 15px;
      text-align: center;
      border-bottom: 1px solid #444;
      padding-bottom: 8px;
      width: 100%;
    }
    .control-group {
      margin-bottom: 12px;
      width: 100%;
    }
    .control-label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #e0e0e0;
    }
    .value-display {
      float: right;
      font-weight: normal;
      color: #bdbdbd;
    }
    input[type="range"] {
      width: 100%;
      margin-top: 5px;
      -webkit-appearance: none;
      height: 6px;
      background: #444;
      border-radius: 3px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      background: #e0e0e0;
      border-radius: 50%;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 15px;
      height: 15px;
      background: #e0e0e0;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    button {
      width: 100%;
      margin-top: 15px;
      padding: 8px;
      background-color: #424242;
      color: #e0e0e0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: #616161;
    }
  </style>

  <!-- Import Map：把三方模組名稱映射到 CDN ESM URL -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
      "GLTFExporter": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/exporters/GLTFExporter.js",
      "EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/postprocessing/EffectComposer.js",
      "RenderPass": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/postprocessing/RenderPass.js",
      "ShaderPass": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/postprocessing/ShaderPass.js",
      "FXAAShader": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/shaders/FXAAShader.js",
      "EXRLoader": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/EXRLoader.js"
    }
  }
  </script>

  <!-- Shader 直接內嵌 -->
  <script id="vertexShader" type="x-shader/x-vertex">
    uniform vec3 viewVector;
    uniform vec2 uResolution;
    uniform float uTime;
    varying vec2 vUv;
    varying float opacity;
    void main() {
      vUv = uv;
      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * mvPos;
      vec3 nNormal = normalize(normalMatrix * normal);
      vec3 nView   = normalize(viewVector - mvPos.xyz);
      opacity = dot(nNormal, nView);
      opacity = 1.0 - abs(opacity * 1.3);
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-fragment">
    uniform vec3 uColor;
    uniform vec2 uResolution;
    uniform float uTime;
    varying vec2 vUv;
    varying float opacity;
    void main() {
      vec2 d = gl_FragCoord.xy / uResolution;
      vec3 fade = vec3(d.x, d.y, 1.0);
      vec3 c = mix(vec3(0.0), fade * uColor, opacity);
      gl_FragColor = vec4(c, 1.0);
    }
  </script>
</head>
<body>

  <!-- 控制面板 HTML - Thick-to-Thin -->
  <div id="thickToThinPanel" class="control-panel thick-to-thin-panel">
    <div class="panel-title">由粗到細 線條控制</div>
    <div class="control-group">
      <label class="control-label">最粗粗度 (強度): <span id="ttStartStrengthValue" class="value-display"></span></label>
      <input type="range" id="ttStartStrengthSlider" min="0" max="0.1" step="0.01">
    </div>
    <div class="control-group">
      <label class="control-label">最細粗度 (強度): <span id="ttEndStrengthValue" class="value-display"></span></label>
      <input type="range" id="ttEndStrengthSlider" min="0.0" max="0.1" step="0.01"> <!-- Allow 0 -->
    </div>
    <div class="control-group">
      <label class="control-label">最短長度: <span id="ttMinLengthValue" class="value-display"></span></label>
      <input type="range" id="ttMinLengthSlider" min="0.5" max="5.0" step="0.1">
    </div>
    <div class="control-group">
      <label class="control-label">最長長度: <span id="ttMaxLengthValue" class="value-display"></span></label>
      <input type="range" id="ttMaxLengthSlider" min="0.5" max="5.0" step="0.1">
    </div>
    <div class="control-group">
      <label class="control-label">收縮速率 (冪): <span id="ttShrinkPowerValue" class="value-display"></span></label>
      <input type="range" id="ttShrinkPowerSlider" min="0.1" max="5.0" step="0.05">
    </div>
    <div class="control-group">
      <label class="control-label">線條數量: <span id="ttNumLinesValue" class="value-display"></span></label>
      <input type="range" id="ttNumLinesSlider" min="0" max="10" step="1"> <!-- Allow 0 -->
    </div>
  </div>

  <!-- 控制面板 HTML - Thin-to-Thick -->
  <div id="thinToThickPanel" class="control-panel thin-to-thick-panel">
      <div class="panel-title">由細到粗 線條控制</div>
      <div class="control-group">
          <label class="control-label">最細粗度 (強度): <span id="thStartStrengthValue" class="value-display"></span></label>
          <input type="range" id="thStartStrengthSlider" min="0.0" max="0.1" step="0.01">
      </div>
      <div class="control-group">
          <label class="control-label">最粗粗度 (強度): <span id="thEndStrengthValue" class="value-display"></span></label>
          <input type="range" id="thEndStrengthSlider" min="0" max="0.1" step="0.01">
      </div>
      <div class="control-group">
          <label class="control-label">最短長度: <span id="thMinLengthValue" class="value-display"></span></label>
          <input type="range" id="thMinLengthSlider" min="0.5" max="5.0" step="0.1">
      </div>
      <div class="control-group">
          <label class="control-label">最長長度: <span id="thMaxLengthValue" class="value-display"></span></label>
          <input type="range" id="thMaxLengthSlider" min="0.5" max="5.0" step="0.1">
      </div>
      <div class="control-group">
          <label class="control-label">膨脹速率 (冪): <span id="thShrinkPowerValue" class="value-display"></span></label> <!-- Label change -->
          <input type="range" id="thShrinkPowerSlider" min="0.1" max="5.0" step="0.05">
      </div>
      <div class="control-group">
          <label class="control-label">線條數量: <span id="thNumLinesValue" class="value-display"></span></label>
          <input type="range" id="thNumLinesSlider" min="0" max="10" step="1">
      </div>
  </div>

  <!-- 通用控制面板 HTML -->
  <div id="commonPanel" class="control-panel common-panel">
      <div class="panel-title">通用控制</div>
       <div class="control-group">
          <label class="control-label">MarchingCubes 解析度: <span id="resolutionValue" class="value-display"></span></label>
          <input type="range" id="resolutionSlider" min="10" max="500" step="1">
      </div>
      <div class="control-group">
          <label class="control-label">MarchingCubes Isolation: <span id="isolationValue" class="value-display"></span></label>
          <input type="range" id="isolationSlider" min="10" max="300" step="10">
      </div>
      <button id="regenerateBtn">重新生成所有線條</button>
      <button id="exportConfigBtn" style="margin-top: 5px;">匯出設定 (JSON)</button>
      <button id="importConfigBtn" style="margin-top: 5px;">匯入設定 (JSON)</button>
      <input type="file" id="importConfigFile" accept=".json" style="display: none;"> <!-- 隱藏的檔案選擇器 -->
      <button id="exportGlbBtn" style="margin-top: 5px;">下載目前模型 (GLB)</button>
      <button id="toggleMaterialBtn" style="margin-top: 5px;">切換為液體材質</button>
      <button id="toggleFlowBtn" style="margin-top: 5px;">開始流動動畫</button>
  </div>

  <script type="module">
    import * as THREE from 'three';  
    import { MarchingCubes } from 'three/addons/objects/MarchingCubes.js';
    import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
    import { GLTFExporter } from 'GLTFExporter';
    import { EffectComposer } from 'EffectComposer';
    import { RenderPass } from 'RenderPass';
    import { ShaderPass } from 'ShaderPass';
    import { FXAAShader } from 'FXAAShader';
    import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';

    // 場景、相機、Renderer
    const scene    = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff); // 設置場景背景為白色
    const camera   = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,0,30); // 拉得更遠以適應更大的縮放
    camera.lookAt(scene.position);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio( Math.min(window.devicePixelRatio, 1.5) );
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(5, 10, 7.5);
    scene.add(dirLight);

    // PMREMGenerator
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    // generateMaterials
    function generateMaterials() {
      return {
        shader: new THREE.ShaderMaterial({
          uniforms: {
            uResolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
            uTime:       { value: 0 },
            uColor:      { value: new THREE.Color(0x000000) }, 
            viewVector:  { value: camera.position }
          },
          vertexShader:   document.getElementById('vertexShader').textContent,
          fragmentShader: document.getElementById('fragmentShader').textContent,
          transparent: true,
          side: THREE.DoubleSide
        }),
        liquid: new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            metalness: 0.9,  
            roughness: 0, 
            transparent: true, 
            opacity: 0.25,      
            side: THREE.DoubleSide, 
            envMap: null
        })
      };
    }
    const materials = generateMaterials();

    // 載入環境貼圖
    new EXRLoader()
        .setPath('./assets/hdr/')
        .load('HDR_Light_Studio_Free_HDRI_Design_05.exr', function (texture) {

            texture.mapping = THREE.EquirectangularReflectionMapping;

            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            pmremGenerator.dispose();
            texture.dispose();

            console.log("本地 EXR 環境貼圖已載入並處理完成。");
            scene.environment = envMap;
            materials.liquid.envMap = envMap;
            materials.liquid.needsUpdate = true;
        }, undefined, function (error) {
            console.error('無法載入本地 EXR 環境貼圖:', error);
            alert('無法載入 assets/studio_small_03_1k.exr，請檢查檔案是否存在或路徑是否正確。');
        });

    // --- Parameters for Thick-to-Thin --- 
    let ttStartStrength = 0.1;   
    let ttEndStrength = 0.01; // 維持非零最小值
    let ttMinWorldLength = 1.5;
    let ttMaxWorldLength = 2.5;   
    let ttShrinkPower = 0.25;     // 改為 0.8 (更平滑的衰減)
    let ttNumLines = 4;        

    // --- Parameters for Thin-to-Thick --- 
    let thStartStrength = 0.01;  // 維持非零最小值
    let thEndStrength = 0.1;     // End thicker
    let thMinWorldLength = 1;
    let thMaxWorldLength = 2;   
    let thShrinkPower = 1.25;     // Linear thickening by default
    let thNumLines = 3;        

    // --- Shared Parameters --- 
    let resolution = 200;    // 提高解析度
    let isolation = 300;     // 降低 isolation 作為嘗試
    let currentMaterial = 'shader'; 
    const growthSpeed = 5.0; 
    const growthEaseOutPower = 0.5; // 新增：生長速度緩和冪次 (0.5 = sqrt)
    const numSegments = 50;   
    const subtract = 20;      
    let isFlowing = false; 
    let savedLineState = null; // << 新增: 保存的線條狀態
    let savedCameraState = null; // << 新增: 保存的相機狀態
    const FLOW_GROWTH_SPEED_FACTOR = 0.2; // << 新增: 流動時生長速度因子 (0.2 = 20% 速度)
    const FLOW_SHRINK_DURATION_FACTOR = 1.5; // << 新增: 流動時收縮時長因子 (1.5 = 1.5倍時間)
    const MAX_INITIAL_FLOW_DELAY = 2.5; // << 新增: 開始流動時的最大初始延遲 (秒)
    let isFirstFlowTrigger = true; // << 新增: 首次觸發流動動畫的標記

    // MarchingCubes setup (使用變數)
    const effect = new MarchingCubes(resolution, materials[currentMaterial], true, true, 100000);
    effect.isolation = isolation; 
    effect.scale.set(8, 8, 8); 
    effect.enableUvs    = false;
    effect.enableColors = false;
    scene.add(effect);

    const clock = new THREE.Clock();
    // 線條數據陣列
    let lineStartTimes = []; 
    let randomDirections = [];
    let currentTargetLengths = [];
    let lineTypes = []; 
    let lineFlowState = []; // 狀態: 'growing', 'pauseAtEnd', 'shrinking', 'pauseAtStart'
    let lineShrinkStartTimes = []; 
    let linePauseAtEndEndTime = []; // << 新增: 末端暫停結束時間
    let linePauseAtStartEndTime = []; // << 新增: 起點暫停結束時間

    // 初始化/重新生成線條函數
    function regenerateLine() {
        const currentTime = clock.getElapsedTime();
        const totalLines = ttNumLines + thNumLines;

        // 調整陣列大小
        lineStartTimes.length = totalLines;
        randomDirections.length = totalLines;
        currentTargetLengths.length = totalLines;
        lineTypes.length = totalLines;
        lineFlowState.length = totalLines; 
        lineShrinkStartTimes.length = totalLines;
        linePauseAtEndEndTime.length = totalLines; // << 新增
        linePauseAtStartEndTime.length = totalLines; // << 新增

        // 更新 Marching Cubes 實例的 resolution 和 isolation
        effect.init(resolution); 
        effect.isolation = isolation;

        let lineIndex = 0;

        // 生成 Thick-to-Thin 線條
        for(let i = 0; i < ttNumLines; i++) {
            if (!randomDirections[lineIndex]) {
                randomDirections[lineIndex] = new THREE.Vector3();
            }
            randomDirections[lineIndex].set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
            currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(ttMinWorldLength, ttMaxWorldLength);
            lineTypes[lineIndex] = 'tt';
            lineStartTimes[lineIndex] = currentTime; 
            lineFlowState[lineIndex] = 'growing'; 
            lineShrinkStartTimes[lineIndex] = undefined; 
            linePauseAtEndEndTime[lineIndex] = undefined; // << 新增
            linePauseAtStartEndTime[lineIndex] = undefined; // << 新增
            lineIndex++;
        }

        // 生成 Thin-to-Thick 線條
        for(let i = 0; i < thNumLines; i++) {
             if (!randomDirections[lineIndex]) {
                randomDirections[lineIndex] = new THREE.Vector3();
            }
            randomDirections[lineIndex].set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
            currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(thMinWorldLength, thMaxWorldLength);
            lineTypes[lineIndex] = 'th';
            lineStartTimes[lineIndex] = currentTime; 
            lineFlowState[lineIndex] = 'growing'; 
            lineShrinkStartTimes[lineIndex] = undefined; 
            linePauseAtEndEndTime[lineIndex] = undefined; // << 新增
            linePauseAtStartEndTime[lineIndex] = undefined; // << 新增
            lineIndex++;
        }
        effect.reset(); 
        isFirstFlowTrigger = true; // << 新增: 全局重新生成後，重置首次觸發標記
    }

    // updateLineMetaball
    function updateLineMetaball(obj) {
        obj.reset(); 
        const currentTime = clock.getElapsedTime();
        const centerOffset = new THREE.Vector3(0.5, 0.5, 0.5); 
        const totalLines = ttNumLines + thNumLines; 
        const BASE_SHRINK_DURATION = 1.0; 
        const MAX_PAUSE_AT_END_DELAY = 10.0; // << 修改: 增加末端最大延遲時間
        const MAX_PAUSE_AT_START_DELAY = 1.0; 
        
        for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {
            
            // << 新增: 如果還沒到隨機開始時間，則跳過 >>
            if (lineStartTimes[lineIndex] === undefined || currentTime < lineStartTimes[lineIndex]) {
                continue;
            }
            // << 結束檢查 >>

            if (currentTargetLengths[lineIndex] === undefined) continue; // 保持原檢查
            const localMaxLength = currentTargetLengths[lineIndex] / obj.scale.x;
            let localCurrentLength = 0;
            let timeSinceStart = currentTime - lineStartTimes[lineIndex]; // timeSinceStart 會是負數或 0，直到真正開始
            const currentFlowState = lineFlowState[lineIndex]; 

            // --- 根據流動狀態計算長度 --- 
            switch (currentFlowState) {
                case 'growing':
                    // --- 正在生長 --- 
                    if (localMaxLength > 0.001) { 
                        const currentGrowthSpeed = isFlowing ? growthSpeed * FLOW_GROWTH_SPEED_FACTOR : growthSpeed; 
                        const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x); 
                        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;
                        const easedTime = Math.pow(normalizedTime, growthEaseOutPower);
                        localCurrentLength = easedTime * localMaxLength;
                    } else {
                        localCurrentLength = 0; 
                    }
                    // 如果正在流動且剛長到最大長度，切換到 pauseAtEnd 狀態
                    if (isFlowing && localCurrentLength >= localMaxLength * 0.999) { 
                        lineFlowState[lineIndex] = 'pauseAtEnd';
                        const randomDelay = Math.random() * MAX_PAUSE_AT_END_DELAY;
                        linePauseAtEndEndTime[lineIndex] = currentTime + randomDelay;
                        localCurrentLength = localMaxLength; // 保持最大長度
                    }
                    break;
                
                case 'pauseAtEnd':
                    // --- 在末端暫停 --- 
                    if (currentTime >= (linePauseAtEndEndTime[lineIndex] || currentTime + 1)) { 
                        // 延遲結束，開始收縮
                        lineFlowState[lineIndex] = 'shrinking';
                        lineShrinkStartTimes[lineIndex] = currentTime;
                        linePauseAtEndEndTime[lineIndex] = undefined;
                        localCurrentLength = localMaxLength; 
                    } else {
                        // 仍在延遲，保持最大長度
                        localCurrentLength = localMaxLength;
                    }
                    break;

                case 'shrinking':
                    // --- 正在收縮 --- 
                    const timeSinceShrinking = currentTime - (lineShrinkStartTimes[lineIndex] || currentTime); 
                    const currentShrinkDuration = BASE_SHRINK_DURATION * FLOW_SHRINK_DURATION_FACTOR; 
                    const shrinkFactor = Math.max(0, 1.0 - timeSinceShrinking / currentShrinkDuration);
                    localCurrentLength = localMaxLength * shrinkFactor;

                    if (shrinkFactor === 0) {
                        // --- 收縮完成 --- 
                        if (isFlowing) {
                            // 若在流動，切換到 pauseAtStart
                            lineFlowState[lineIndex] = 'pauseAtStart';
                            const randomDelay = Math.random() * MAX_PAUSE_AT_START_DELAY;
                            linePauseAtStartEndTime[lineIndex] = currentTime + randomDelay;
                            lineShrinkStartTimes[lineIndex] = undefined; // 清除收縮開始時間
                            localCurrentLength = 0.001; // 保持長度為 0
                        } else {
                            // 若不在流動，直接重置狀態 (會自然消失)
                            lineFlowState[lineIndex] = 'growing'; // 或設為 idle
                            lineShrinkStartTimes[lineIndex] = undefined;
                            lineStartTimes[lineIndex] = undefined; // 讓它不再更新
                            localCurrentLength = 0.001;
                        }
                    }
                    break;

                case 'pauseAtStart':
                    // --- 在起點暫停 --- 
                    if (currentTime >= (linePauseAtStartEndTime[lineIndex] || currentTime + 1)) { 
                        // 延遲結束，重新生成並開始生長
                        if (!randomDirections[lineIndex]) randomDirections[lineIndex] = new THREE.Vector3();
                        randomDirections[lineIndex].set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
                        lineTypes[lineIndex] = (lineIndex < ttNumLines) ? 'tt' : 'th'; 
                        const minL = (lineTypes[lineIndex] === 'tt') ? ttMinWorldLength : thMinWorldLength;
                        const maxL = (lineTypes[lineIndex] === 'tt') ? ttMaxWorldLength : thMaxWorldLength;
                        currentTargetLengths[lineIndex] = THREE.MathUtils.randFloat(minL, maxL);
                        lineStartTimes[lineIndex] = currentTime;
                        lineFlowState[lineIndex] = 'growing'; // 切換回生長
                        linePauseAtStartEndTime[lineIndex] = undefined;
                        localCurrentLength = 0.001; 
                    } else {
                         // 仍在延遲，保持長度為 0
                         localCurrentLength = 0.001;
                    }
                    break;
                
                default: // 包括 isFlowing 為 false 的情況
                     // --- 正常生長邏輯 --- 
                     if (localMaxLength > 0.001 && lineStartTimes[lineIndex] !== undefined) { 
                        const currentGrowthSpeed = growthSpeed; // 使用正常速度
                        const linearDuration = localMaxLength / (currentGrowthSpeed / obj.scale.x); 
                        const normalizedTime = linearDuration > 0 ? Math.min(timeSinceStart / linearDuration, 1.0) : 1.0;
                        const easedTime = Math.pow(normalizedTime, growthEaseOutPower);
                        localCurrentLength = easedTime * localMaxLength;
                    } else {
                        localCurrentLength = 0; 
                    }
                    break;
            }
            // --- 長度計算結束 --- 

            if (localCurrentLength <= 0.001) continue; 

            const currentDirection = randomDirections[lineIndex];
            const currentLineType = lineTypes[lineIndex];
            if (!currentDirection || !currentLineType) continue; 
            
            // 根據類型選擇參數
            let lineStartStrength, lineEndStrength, lineShrinkPower;
            if (currentLineType === 'tt') {
                lineStartStrength = ttStartStrength;
                lineEndStrength = ttEndStrength;
                lineShrinkPower = ttShrinkPower;
            } else { // 'th'
                lineStartStrength = thStartStrength;
                lineEndStrength = thEndStrength;
                lineShrinkPower = thShrinkPower;
            }

            // 計算 Metaball 強度和位置
            for (let i = 0; i <= numSegments; i++) {
                const segmentT = i / numSegments; 
                const strengthFactor = Math.pow(segmentT, lineShrinkPower);
                const baseStrength = THREE.MathUtils.lerp(lineStartStrength, lineEndStrength, strengthFactor);

                // << 恢復: 應用流動強度變化 >>
                let dynamicStrength = baseStrength;
                if (isFlowing) {
                    const flowFrequency = 1.0; 
                    const flowAmplitude = 0.15 * baseStrength; // 使用恢復的幅度
                    const flowOffset = Math.sin(currentTime * flowFrequency - segmentT * Math.PI * 4) * flowAmplitude;
                    dynamicStrength += flowOffset;
                    dynamicStrength = Math.max(dynamicStrength, 0); 
                }
                // << 結束強度變化 >>

                const localPos = currentDirection.clone().multiplyScalar(localCurrentLength * segmentT); 
                const finalPos = localPos.add(centerOffset);

                // << 修改: 使用 dynamicStrength >>
                obj.addBall(finalPos.x, finalPos.y, finalPos.z, dynamicStrength, subtract); 
            }
        }
      
        obj.update(); 
    }

    // --- 匯出/匯入設定檔 --- 

    function exportConfiguration() {
        console.log("開始匯出設定...");
        const serializableDirections = randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null);
        const cameraPosition = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
        const cameraQuaternion = { _x: camera.quaternion.x, _y: camera.quaternion.y, _z: camera.quaternion.z, _w: camera.quaternion.w };

        const config = {
            ttStartStrength: ttStartStrength,
            ttEndStrength: ttEndStrength,
            ttMinWorldLength: ttMinWorldLength,
            ttMaxWorldLength: ttMaxWorldLength,
            ttShrinkPower: ttShrinkPower,
            ttNumLines: ttNumLines,
            thStartStrength: thStartStrength,
            thEndStrength: thEndStrength,
            thMinWorldLength: thMinWorldLength,
            thMaxWorldLength: thMaxWorldLength,
            thShrinkPower: thShrinkPower,
            thNumLines: thNumLines,
            resolution: resolution,
            isolation: isolation,
            currentMaterial: currentMaterial,
            growthSpeed: growthSpeed,
            growthEaseOutPower: growthEaseOutPower,
            numSegments: numSegments,
            subtract: subtract,
            lineTypes: lineTypes,
            randomDirections: serializableDirections,
            currentTargetLengths: currentTargetLengths,
            cameraPosition: cameraPosition,
            cameraQuaternion: cameraQuaternion
        };

        try {
            const configString = JSON.stringify(config, null, 2);
            const blob = new Blob([configString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'metaball_config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("設定已匯出為 metaball_config.json");
        } catch (e) {
            console.error("匯出設定失敗:", e);
            alert("匯出設定失敗！");
        }
    }

    function importConfiguration(event) {
        console.log("開始匯入設定...");
        const file = event.target.files[0];
        if (!file) {
            console.log("未選擇檔案。");
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const config = JSON.parse(e.target.result);
                console.log("讀取的設定:", config);

                if (!config || typeof config !== 'object') throw new Error("無效的設定檔格式");
                const requiredKeys = ['ttStartStrength', 'thStartStrength', 'resolution', 'isolation', 'lineTypes', 'randomDirections', 'currentTargetLengths', 'cameraPosition', 'cameraQuaternion'];
                for (const key of requiredKeys) {
                    if (!(key in config)) throw new Error(`缺少必要欄位: ${key}`);
                }
                const totalLines = config.ttNumLines + config.thNumLines;
                if (!Array.isArray(config.lineTypes) || config.lineTypes.length !== totalLines ||
                    !Array.isArray(config.randomDirections) || config.randomDirections.length !== totalLines ||
                    !Array.isArray(config.currentTargetLengths) || config.currentTargetLengths.length !== totalLines) {
                    throw new Error("線條數據數量與線條總數不符");
                }

                ttStartStrength = config.ttStartStrength;
                ttEndStrength = config.ttEndStrength;
                ttMinWorldLength = config.ttMinWorldLength;
                ttMaxWorldLength = config.ttMaxWorldLength;
                ttShrinkPower = config.ttShrinkPower;
                ttNumLines = config.ttNumLines;
                thStartStrength = config.thStartStrength;
                thEndStrength = config.thEndStrength;
                thMinWorldLength = config.thMinWorldLength;
                thMaxWorldLength = config.thMaxWorldLength;
                thShrinkPower = config.thShrinkPower;
                thNumLines = config.thNumLines;
                resolution = config.resolution;
                isolation = config.isolation;
                currentMaterial = config.currentMaterial || 'shader';

                initControlValues();

                effect.init(resolution);
                effect.isolation = isolation;
                effect.material = materials[currentMaterial];

                if (config.cameraPosition) {
                    camera.position.set(config.cameraPosition.x, config.cameraPosition.y, config.cameraPosition.z);
                }
                if (config.cameraQuaternion) {
                    camera.quaternion.set(config.cameraQuaternion._x, config.cameraQuaternion._y, config.cameraQuaternion._z, config.cameraQuaternion._w);
                }
                controls.update();

                const currentTime = clock.getElapsedTime();
                lineStartTimes.length = totalLines;
                randomDirections.length = totalLines;
                currentTargetLengths.length = totalLines;
                lineTypes.length = totalLines;

                for (let i = 0; i < totalLines; i++) {
                    lineTypes[i] = config.lineTypes[i];
                    currentTargetLengths[i] = config.currentTargetLengths[i];
                    if (config.randomDirections[i]) {
                        randomDirections[i] = new THREE.Vector3(
                            config.randomDirections[i].x,
                            config.randomDirections[i].y,
                            config.randomDirections[i].z
                        );
                    } else {
                        randomDirections[i] = null;
                    }
                    lineStartTimes[i] = currentTime;
                }
                
                effect.reset();
                console.log("設定已成功匯入。");
                alert("設定已載入！");

            } catch (e) {
                console.error("匯入設定失敗:", e);
                alert(`匯入設定失敗！錯誤: ${e.message}`);
            } finally {
                document.getElementById('importConfigFile').value = null;
            }
        };
        reader.onerror = function(e) {
            console.error("讀取檔案錯誤:", e);
            alert("讀取檔案時發生錯誤。");
            document.getElementById('importConfigFile').value = null;
        };
        reader.readAsText(file);
    }

    // --- 恢復: 匯出 GLB --- 
    function exportGLB() {
        console.log("開始匯出 GLB (應用視角, 臨時提高解析度至 200)...");
        const originalResolution = resolution; // 1. 儲存當前解析度
        const originalEffectQuaternion = effect.quaternion.clone(); // << 新增: 儲存原始模型旋轉
        const exporter = new GLTFExporter();

        try {
            // 2. 設定高解析度並重新初始化
            console.log(`  - 原解析度: ${originalResolution}, 臨時設為: 200`);
            resolution = 200;
            effect.init(resolution);
            
            // 3. 強制重新計算模型幾何 (使用高解析度)
            console.log("  - 重新計算高解析度模型...");
            updateLineMetaball(effect); 
            console.log("  - 高解析度模型計算完成.");

            // << 新增: 應用反向攝影機旋轉到模型 >>
            console.log("  - 應用反向攝影機旋轉...");
            const cameraInverseQuaternion = camera.quaternion.clone().invert();
            effect.quaternion.premultiply(cameraInverseQuaternion); // 將反向旋轉應用到模型
            effect.updateMatrixWorld(); // 更新世界矩陣
            console.log("  - 反向旋轉已應用.");
            // << --- >>

            // 4. 執行匯出
            exporter.parse(
                effect, 
                function (result) { // 成功回呼
                    if (result instanceof ArrayBuffer) {
                        try {
                            const blob = new Blob([result], { type: 'model/gltf-binary' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'metaball_model_view_res200.glb'; // 改名
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            console.log("GLB 檔案已匯出: metaball_model_view_res200.glb");
                            alert("高解析度 (含視角) GLB 模型已下載！");
                        } catch (e) {
                            console.error("建立或下載 GLB Blob 時出錯:", e);
                            alert("下載 GLB 時發生錯誤！");
                        }
                    } else {
                        console.error("匯出結果不是預期的 ArrayBuffer:", result);
                        alert("匯出 GLB 失敗：格式錯誤。請檢查控制台。");
                    }
                    // 5. 恢復原始狀態 (成功時)
                    console.log("  - (成功) 恢復原始模型旋轉和解析度...");
                    effect.quaternion.copy(originalEffectQuaternion); // << 新增: 恢復模型旋轉
                    effect.updateMatrixWorld();
                    resolution = originalResolution;
                    effect.init(resolution);
                    console.log("  - 模型旋轉和解析度已恢復.");
                },
                function (error) { // 錯誤回呼
                    console.error('匯出 GLB 時發生錯誤:', error);
                    alert("匯出 GLB 時發生錯誤！請檢查控制台。");
                    // 5. 恢復原始狀態 (錯誤時也要恢復)
                    console.log("  - (錯誤) 恢復原始模型旋轉和解析度...");
                    effect.quaternion.copy(originalEffectQuaternion); // << 新增: 恢復模型旋轉
                    effect.updateMatrixWorld();
                    resolution = originalResolution;
                    effect.init(resolution);
                    console.log("  - 模型旋轉和解析度已恢復.");
                },
                { binary: true } 
            );
        } catch (e) {
             console.error("準備匯出或應用旋轉時出錯:", e);
             alert("準備匯出高解析度模型時發生錯誤！");
             // 確保即使在這裡出錯也恢復狀態
             console.log("  - (Catch) 恢復原始模型旋轉和解析度...");
             effect.quaternion.copy(originalEffectQuaternion); // << 新增: 恢復模型旋轉
             effect.updateMatrixWorld();
             if (resolution !== originalResolution) {
                 resolution = originalResolution;
                 effect.init(resolution);
             }
             console.log("  - 模型旋轉和解析度已恢復.");
        }
    }

    // 初始化控制面板值
    function initControlValues() {
        // Thick-to-Thin Panel
        document.getElementById('ttStartStrengthSlider').value = ttStartStrength;
        document.getElementById('ttStartStrengthValue').textContent = ttStartStrength.toFixed(2);
        document.getElementById('ttEndStrengthSlider').value = ttEndStrength;
        document.getElementById('ttEndStrengthValue').textContent = ttEndStrength.toFixed(2);
        document.getElementById('ttMinLengthSlider').value = ttMinWorldLength;
        document.getElementById('ttMinLengthValue').textContent = ttMinWorldLength.toFixed(1);
        document.getElementById('ttMaxLengthSlider').value = ttMaxWorldLength;
        document.getElementById('ttMaxLengthValue').textContent = ttMaxWorldLength.toFixed(1);
        document.getElementById('ttShrinkPowerSlider').value = ttShrinkPower;
        document.getElementById('ttShrinkPowerValue').textContent = ttShrinkPower.toFixed(2);
        document.getElementById('ttNumLinesSlider').value = ttNumLines;
        document.getElementById('ttNumLinesValue').textContent = ttNumLines;

        // Thin-to-Thick Panel
        document.getElementById('thStartStrengthSlider').value = thStartStrength;
        document.getElementById('thStartStrengthValue').textContent = thStartStrength.toFixed(2);
        document.getElementById('thEndStrengthSlider').value = thEndStrength;
        document.getElementById('thEndStrengthValue').textContent = thEndStrength.toFixed(2);
        document.getElementById('thMinLengthSlider').value = thMinWorldLength;
        document.getElementById('thMinLengthValue').textContent = thMinWorldLength.toFixed(1);
        document.getElementById('thMaxLengthSlider').value = thMaxWorldLength;
        document.getElementById('thMaxLengthValue').textContent = thMaxWorldLength.toFixed(1);
        document.getElementById('thShrinkPowerSlider').value = thShrinkPower;
        document.getElementById('thShrinkPowerValue').textContent = thShrinkPower.toFixed(2);
        document.getElementById('thNumLinesSlider').value = thNumLines;
        document.getElementById('thNumLinesValue').textContent = thNumLines;

        // Common Panel
        document.getElementById('resolutionSlider').value = resolution;
        document.getElementById('resolutionValue').textContent = resolution;
        document.getElementById('isolationSlider').value = isolation;
        document.getElementById('isolationValue').textContent = isolation;
    }

    // 設置UI控件事件監聽
    function setupControls() {
        // --- Thick-to-Thin Controls --- 
        const ttStartStrengthSlider = document.getElementById('ttStartStrengthSlider');
        const ttStartStrengthValue = document.getElementById('ttStartStrengthValue');
        const ttEndStrengthSlider = document.getElementById('ttEndStrengthSlider');
        const ttEndStrengthValue = document.getElementById('ttEndStrengthValue');
        const ttMinLengthSlider = document.getElementById('ttMinLengthSlider');
        const ttMinLengthValue = document.getElementById('ttMinLengthValue');
        const ttMaxLengthSlider = document.getElementById('ttMaxLengthSlider');
        const ttMaxLengthValue = document.getElementById('ttMaxLengthValue');
        const ttShrinkPowerSlider = document.getElementById('ttShrinkPowerSlider');
        const ttShrinkPowerValue = document.getElementById('ttShrinkPowerValue');
        const ttNumLinesSlider = document.getElementById('ttNumLinesSlider');
        const ttNumLinesValue = document.getElementById('ttNumLinesValue');

        // --- Thin-to-Thick Controls --- 
        const thStartStrengthSlider = document.getElementById('thStartStrengthSlider');
        const thStartStrengthValue = document.getElementById('thStartStrengthValue');
        const thEndStrengthSlider = document.getElementById('thEndStrengthSlider');
        const thEndStrengthValue = document.getElementById('thEndStrengthValue');
        const thMinLengthSlider = document.getElementById('thMinLengthSlider');
        const thMinLengthValue = document.getElementById('thMinLengthValue');
        const thMaxLengthSlider = document.getElementById('thMaxLengthSlider');
        const thMaxLengthValue = document.getElementById('thMaxLengthValue');
        const thShrinkPowerSlider = document.getElementById('thShrinkPowerSlider');
        const thShrinkPowerValue = document.getElementById('thShrinkPowerValue');
        const thNumLinesSlider = document.getElementById('thNumLinesSlider');
        const thNumLinesValue = document.getElementById('thNumLinesValue');

        // --- Common Controls ---
        const resolutionSlider = document.getElementById('resolutionSlider');
        const resolutionValue = document.getElementById('resolutionValue');
        const isolationSlider = document.getElementById('isolationSlider');
        const isolationValue = document.getElementById('isolationValue');
        const regenerateBtn = document.getElementById('regenerateBtn');
        const exportConfigBtn = document.getElementById('exportConfigBtn');
        const importConfigBtn = document.getElementById('importConfigBtn');
        const importConfigFile = document.getElementById('importConfigFile');
        const exportGlbBtn = document.getElementById('exportGlbBtn');
        const toggleMaterialBtn = document.getElementById('toggleMaterialBtn');
        const toggleFlowBtn = document.getElementById('toggleFlowBtn');

        // --- Event Listeners for Thick-to-Thin --- 
        ttStartStrengthSlider.addEventListener('input', function() {
            ttStartStrength = parseFloat(this.value);
            ttStartStrengthValue.textContent = ttStartStrength.toFixed(2);
            if (ttStartStrength < ttEndStrength) { // tt: start >= end
                ttEndStrength = ttStartStrength;
                ttEndStrengthSlider.value = ttEndStrength;
                ttEndStrengthValue.textContent = ttEndStrength.toFixed(2);
            }
        });
        ttEndStrengthSlider.addEventListener('input', function() {
            ttEndStrength = parseFloat(this.value);
            ttEndStrengthValue.textContent = ttEndStrength.toFixed(2);
            if (ttEndStrength > ttStartStrength) { // tt: start >= end
                ttStartStrength = ttEndStrength;
                ttStartStrengthSlider.value = ttStartStrength;
                ttStartStrengthValue.textContent = ttStartStrength.toFixed(2);
            }
        });
        ttMinLengthSlider.addEventListener('input', function() {
            ttMinWorldLength = parseFloat(this.value);
            ttMinLengthValue.textContent = ttMinWorldLength.toFixed(1);
            if (ttMinWorldLength > ttMaxWorldLength) {
                ttMaxWorldLength = ttMinWorldLength;
                ttMaxLengthSlider.value = ttMaxWorldLength;
                ttMaxLengthValue.textContent = ttMaxWorldLength.toFixed(1);
            }
        });
        ttMaxLengthSlider.addEventListener('input', function() {
            ttMaxWorldLength = parseFloat(this.value);
            ttMaxLengthValue.textContent = ttMaxWorldLength.toFixed(1);
             if (ttMaxWorldLength < ttMinWorldLength) {
                ttMinWorldLength = ttMaxWorldLength;
                ttMinLengthSlider.value = ttMinWorldLength;
                ttMinLengthValue.textContent = ttMinWorldLength.toFixed(1);
            }
        });
        ttShrinkPowerSlider.addEventListener('input', function() {
            ttShrinkPower = parseFloat(this.value);
            ttShrinkPowerValue.textContent = ttShrinkPower.toFixed(2);
        });
        ttNumLinesSlider.addEventListener('input', function() {
            ttNumLines = parseInt(this.value);
            ttNumLinesValue.textContent = ttNumLines;
            regenerateLine(); 
        });

        // --- Event Listeners for Thin-to-Thick --- 
        thStartStrengthSlider.addEventListener('input', function() {
            thStartStrength = parseFloat(this.value);
            thStartStrengthValue.textContent = thStartStrength.toFixed(2);
             if (thStartStrength > thEndStrength) { // th: start <= end
                thEndStrength = thStartStrength;
                thEndStrengthSlider.value = thEndStrength;
                thEndStrengthValue.textContent = thEndStrength.toFixed(2);
            }
        });
        thEndStrengthSlider.addEventListener('input', function() {
            thEndStrength = parseFloat(this.value);
            thEndStrengthValue.textContent = thEndStrength.toFixed(2);
             if (thEndStrength < thStartStrength) { // th: start <= end
                thStartStrength = thEndStrength;
                thStartStrengthSlider.value = thStartStrength;
                thStartStrengthValue.textContent = thStartStrength.toFixed(2);
            }
        });
         thMinLengthSlider.addEventListener('input', function() {
            thMinWorldLength = parseFloat(this.value);
            thMinLengthValue.textContent = thMinWorldLength.toFixed(1);
            if (thMinWorldLength > thMaxWorldLength) {
                thMaxWorldLength = thMinWorldLength;
                thMaxLengthSlider.value = thMaxWorldLength;
                thMaxLengthValue.textContent = thMaxWorldLength.toFixed(1);
            }
        });
        thMaxLengthSlider.addEventListener('input', function() {
            thMaxWorldLength = parseFloat(this.value);
            thMaxLengthValue.textContent = thMaxWorldLength.toFixed(1);
             if (thMaxWorldLength < thMinWorldLength) {
                thMinWorldLength = thMaxWorldLength;
                thMinLengthSlider.value = thMinWorldLength;
                thMinLengthValue.textContent = thMinWorldLength.toFixed(1);
            }
        });
        thShrinkPowerSlider.addEventListener('input', function() {
            thShrinkPower = parseFloat(this.value);
            thShrinkPowerValue.textContent = thShrinkPower.toFixed(2);
        });
        thNumLinesSlider.addEventListener('input', function() {
            thNumLines = parseInt(this.value);
            thNumLinesValue.textContent = thNumLines;
            regenerateLine(); 
        });

        // --- Event Listeners for Common Controls --- 
        resolutionSlider.addEventListener('input', function() {
            resolution = parseInt(this.value);
            resolutionValue.textContent = resolution;
            effect.init(resolution);
        });
        isolationSlider.addEventListener('input', function() {
            isolation = parseInt(this.value);
            isolationValue.textContent = isolation;
            effect.isolation = isolation;
        });

        // Shared regenerate button listener
        regenerateBtn.addEventListener('click', regenerateLine);
        
        // Export/Import (File) listeners
        exportConfigBtn.addEventListener('click', exportConfiguration);
        importConfigBtn.addEventListener('click', () => {
            importConfigFile.click();
        });
        importConfigFile.addEventListener('change', importConfiguration);
        exportGlbBtn.addEventListener('click', exportGLB);
        
        // Toggle Material listener
        toggleMaterialBtn.addEventListener('click', () => {
            if (currentMaterial === 'shader') {
                currentMaterial = 'liquid';
                toggleMaterialBtn.textContent = '切換為描邊材質';
                scene.background.set(0x111111); // << 新增: 切換為深色背景
            } else {
                currentMaterial = 'shader';
                toggleMaterialBtn.textContent = '切換為液體材質';
                scene.background.set(0xffffff); // << 新增: 切換回白色背景
            }
            effect.material = materials[currentMaterial]; 
            console.log(`材質已切換為: ${currentMaterial}, 背景顏色已更新.`);
        });

        // Toggle Flow listener (修改)
        toggleFlowBtn.addEventListener('click', () => {
            if (isFlowing) {
                // --- 停止流動 --- 
                isFlowing = false;
                toggleFlowBtn.textContent = '開始流動動畫';
                console.log("流動動畫已停止，正在恢復狀態...");
                // isFirstFlowTrigger = true; // << 可選: 如果希望停止後下次又是同時開始，取消此註解
                if (savedLineState) {
                    // 恢復線條數據
                    ttNumLines = savedLineState.ttNumLines;
                    thNumLines = savedLineState.thNumLines;
                    lineTypes = [...savedLineState.lineTypes]; // 恢復數組 (淺拷貝足夠 for string)
                    randomDirections = savedLineState.randomDirections.map(dir => dir ? new THREE.Vector3(dir.x, dir.y, dir.z) : null); // 恢復 Vector3
                    currentTargetLengths = [...savedLineState.currentTargetLengths]; // 恢復數組
                    lineStartTimes = [...savedLineState.lineStartTimes]; // 恢復開始時間
                    
                    // 恢復狀態和收縮時間 (設為 undefined 確保它們按恢復的 start time 正常生長)
                    lineFlowState = lineTypes.map(() => 'growing');
                    lineShrinkStartTimes = lineTypes.map(() => undefined);

                    // 更新 UI
                    document.getElementById('ttNumLinesSlider').value = ttNumLines;
                    document.getElementById('ttNumLinesValue').textContent = ttNumLines;
                    document.getElementById('thNumLinesSlider').value = thNumLines;
                    document.getElementById('thNumLinesValue').textContent = thNumLines;

                    console.log("線條狀態已恢復");
                    savedLineState = null; // 清除保存的狀態
                } else {
                    console.warn("找不到保存的狀態來恢復。")
                }

                if (savedCameraState) {
                     // 恢復相機狀態
                    camera.position.copy(savedCameraState.position);
                    camera.quaternion.copy(savedCameraState.quaternion);
                    controls.update(); // 更新控制器
                    console.log("相機狀態已恢復");
                    savedCameraState = null;
                } else {
                     console.warn("找不到保存的相機狀態來恢復。")
                }
                
                effect.reset(); // 清除當前 metaballs

            } else {
                // --- 開始流動 --- 
                console.log("開始流動動畫，正在保存當前狀態並設置隨機延遲...");
                // 保存當前狀態
                savedLineState = {
                    ttNumLines: ttNumLines,
                    thNumLines: thNumLines,
                    lineTypes: [...lineTypes],
                    randomDirections: randomDirections.map(dir => dir ? { x: dir.x, y: dir.y, z: dir.z } : null), // 序列化 Vector3
                    currentTargetLengths: [...currentTargetLengths],
                    lineStartTimes: [...lineStartTimes]
                };
                savedCameraState = {
                    position: camera.position.clone(),
                    quaternion: camera.quaternion.clone()
                };
                console.log("狀態已保存。");

                isFlowing = true;
                toggleFlowBtn.textContent = '停止流動動畫';
                
                const startTime = clock.getElapsedTime();
                const totalLines = ttNumLines + thNumLines;
                lineFlowState.length = totalLines; // 確保數組大小正確
                lineShrinkStartTimes.length = totalLines;
                linePauseAtEndEndTime.length = totalLines;
                linePauseAtStartEndTime.length = totalLines;

                if (isFirstFlowTrigger) {
                     // << 新增: 首次觸發，所有線條同時開始 >>
                    console.log("首次觸發流動：所有線條同時開始。");
                    for (let i = 0; i < totalLines; i++) {
                        lineStartTimes[i] = startTime; // 同一個開始時間
                        lineFlowState[i] = 'growing'; 
                        lineShrinkStartTimes[i] = undefined;
                        linePauseAtEndEndTime[i] = undefined;
                        linePauseAtStartEndTime[i] = undefined;
                    }
                    isFirstFlowTrigger = false; // 標記為非首次
                } else {
                    // << 修改: 非首次觸發，使用隨機延遲 >>
                    console.log(`非首次觸發流動：各線條將在 ${MAX_INITIAL_FLOW_DELAY.toFixed(1)} 秒內隨機開始。`);
                    for (let i = 0; i < totalLines; i++) {
                        const randomInitialDelay = Math.random() * MAX_INITIAL_FLOW_DELAY;
                        lineStartTimes[i] = startTime + randomInitialDelay; // 不同的開始時間
                        lineFlowState[i] = 'growing'; 
                        lineShrinkStartTimes[i] = undefined;
                        linePauseAtEndEndTime[i] = undefined;
                        linePauseAtStartEndTime[i] = undefined;
                    }
                }
                
                effect.reset(); 
            }
        });
    }

    // animate loop
    function animate() {
      requestAnimationFrame(animate);
      
      effect.material = materials[currentMaterial]; 
      if(currentMaterial === 'shader') {
          const currentTime = clock.getElapsedTime();
          effect.material.uniforms.uTime.value      = currentTime;
          effect.material.uniforms.viewVector.value = camera.position;
      }
      
      updateLineMetaball(effect);
      
      controls.update();
      renderer.render(scene, camera);
    }

    // 初始化
    initControlValues();
    setupControls();
    regenerateLine();
    animate();

    // resize
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      materials.shader.uniforms.uResolution.value.set(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
